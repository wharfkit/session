
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
  </head>
  <body>
    <div id="mocha"></div>
    <script src="https://unpkg.com/chai/chai.js"></script>
    <script src="https://unpkg.com/mocha/mocha.js"></script>
    <script class="mocha-init">
      mocha.setup('tdd');
      mocha.checkLeaks();
    </script>
    <script>(function(require$0$1, require$1$1, require$2, require$4, require$5, path, util, fs, chai) {
    "use strict";
    function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : {
            default: e
        };
    }
    var require$0__default = _interopDefaultLegacy(require$0$1);
    var require$1__default = _interopDefaultLegacy(require$1$1);
    var require$2__default = _interopDefaultLegacy(require$2);
    var require$4__default = _interopDefaultLegacy(require$4);
    var require$5__default = _interopDefaultLegacy(require$5);
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }));
        }
        return new (P || (P = Promise))((function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        }));
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var brorand = {
        exports: {}
    };
    var r$1;
    brorand.exports = function rand(len) {
        if (!r$1) r$1 = new Rand(null);
        return r$1.generate(len);
    };
    function Rand(rand) {
        this.rand = rand;
    }
    brorand.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
        return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes) return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();
        return res;
    };
    if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
            Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                self.crypto.getRandomValues(arr);
                return arr;
            };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
            Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                self.msCrypto.getRandomValues(arr);
                return arr;
            };
        } else if (typeof window === "object") {
            Rand.prototype._rand = function() {
                throw new Error("Not implemented yet");
            };
        }
    } else {
        try {
            var crypto = require("crypto");
            if (typeof crypto.randomBytes !== "function") throw new Error("Not supported");
            Rand.prototype._rand = function _rand(n) {
                return crypto.randomBytes(n);
            };
        } catch (e) {}
    }
    var hash$2 = {};
    var utils$p = {};
    var minimalisticAssert = assert$f;
    function assert$f(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    assert$f.equal = function assertEqual(l, r, msg) {
        if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
    var inherits$4 = {
        exports: {}
    };
    var inherits_browser = {
        exports: {}
    };
    var hasRequiredInherits_browser;
    function requireInherits_browser() {
        if (hasRequiredInherits_browser) return inherits_browser.exports;
        hasRequiredInherits_browser = 1;
        if (typeof Object.create === "function") {
            inherits_browser.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor;
                    ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                }
            };
        } else {
            inherits_browser.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor;
                    ctor.prototype.constructor = ctor;
                }
            };
        }
        return inherits_browser.exports;
    }
    (function(module) {
        try {
            var util = require("util");
            if (typeof util.inherits !== "function") throw "";
            module.exports = util.inherits;
        } catch (e) {
            module.exports = requireInherits_browser();
        }
    })(inherits$4);
    var assert$e = minimalisticAssert;
    var inherits$3 = inherits$4.exports;
    utils$p.inherits = inherits$3;
    function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
            return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
            return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
        if (Array.isArray(msg)) return msg.slice();
        if (!msg) return [];
        var res = [];
        if (typeof msg === "string") {
            if (!enc) {
                var p = 0;
                for (var i = 0; i < msg.length; i++) {
                    var c = msg.charCodeAt(i);
                    if (c < 128) {
                        res[p++] = c;
                    } else if (c < 2048) {
                        res[p++] = c >> 6 | 192;
                        res[p++] = c & 63 | 128;
                    } else if (isSurrogatePair(msg, i)) {
                        c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                        res[p++] = c >> 18 | 240;
                        res[p++] = c >> 12 & 63 | 128;
                        res[p++] = c >> 6 & 63 | 128;
                        res[p++] = c & 63 | 128;
                    } else {
                        res[p++] = c >> 12 | 224;
                        res[p++] = c >> 6 & 63 | 128;
                        res[p++] = c & 63 | 128;
                    }
                }
            } else if (enc === "hex") {
                msg = msg.replace(/[^a-z0-9]+/gi, "");
                if (msg.length % 2 !== 0) msg = "0" + msg;
                for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
        } else {
            for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
        }
        return res;
    }
    utils$p.toArray = toArray;
    function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
        return res;
    }
    utils$p.toHex = toHex;
    function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
    }
    utils$p.htonl = htonl;
    function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
            var w = msg[i];
            if (endian === "little") w = htonl(w);
            res += zero8(w.toString(16));
        }
        return res;
    }
    utils$p.toHex32 = toHex32;
    function zero2(word) {
        if (word.length === 1) return "0" + word; else return word;
    }
    utils$p.zero2 = zero2;
    function zero8(word) {
        if (word.length === 7) return "0" + word; else if (word.length === 6) return "00" + word; else if (word.length === 5) return "000" + word; else if (word.length === 4) return "0000" + word; else if (word.length === 3) return "00000" + word; else if (word.length === 2) return "000000" + word; else if (word.length === 1) return "0000000" + word; else return word;
    }
    utils$p.zero8 = zero8;
    function join32(msg, start, end, endian) {
        var len = end - start;
        assert$e(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
            var w;
            if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3]; else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
            res[i] = w >>> 0;
        }
        return res;
    }
    utils$p.join32 = join32;
    function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
            var m = msg[i];
            if (endian === "big") {
                res[k] = m >>> 24;
                res[k + 1] = m >>> 16 & 255;
                res[k + 2] = m >>> 8 & 255;
                res[k + 3] = m & 255;
            } else {
                res[k + 3] = m >>> 24;
                res[k + 2] = m >>> 16 & 255;
                res[k + 1] = m >>> 8 & 255;
                res[k] = m & 255;
            }
        }
        return res;
    }
    utils$p.split32 = split32;
    function rotr32$1(w, b) {
        return w >>> b | w << 32 - b;
    }
    utils$p.rotr32 = rotr32$1;
    function rotl32$2(w, b) {
        return w << b | w >>> 32 - b;
    }
    utils$p.rotl32 = rotl32$2;
    function sum32$3(a, b) {
        return a + b >>> 0;
    }
    utils$p.sum32 = sum32$3;
    function sum32_3$1(a, b, c) {
        return a + b + c >>> 0;
    }
    utils$p.sum32_3 = sum32_3$1;
    function sum32_4$2(a, b, c, d) {
        return a + b + c + d >>> 0;
    }
    utils$p.sum32_4 = sum32_4$2;
    function sum32_5$2(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
    }
    utils$p.sum32_5 = sum32_5$2;
    function sum64$1(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
    }
    utils$p.sum64 = sum64$1;
    function sum64_hi$1(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
    }
    utils$p.sum64_hi = sum64_hi$1;
    function sum64_lo$1(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
    }
    utils$p.sum64_lo = sum64_lo$1;
    function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
    }
    utils$p.sum64_4_hi = sum64_4_hi$1;
    function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
    }
    utils$p.sum64_4_lo = sum64_4_lo$1;
    function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
    }
    utils$p.sum64_5_hi = sum64_5_hi$1;
    function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
    }
    utils$p.sum64_5_lo = sum64_5_lo$1;
    function rotr64_hi$1(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
    }
    utils$p.rotr64_hi = rotr64_hi$1;
    function rotr64_lo$1(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
    }
    utils$p.rotr64_lo = rotr64_lo$1;
    function shr64_hi$1(ah, al, num) {
        return ah >>> num;
    }
    utils$p.shr64_hi = shr64_hi$1;
    function shr64_lo$1(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
    }
    utils$p.shr64_lo = shr64_lo$1;
    var common$6 = {};
    var utils$o = utils$p;
    var assert$d = minimalisticAssert;
    function BlockHash$4() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
    }
    common$6.BlockHash = BlockHash$4;
    BlockHash$4.prototype.update = function update(msg, enc) {
        msg = utils$o.toArray(msg, enc);
        if (!this.pending) this.pending = msg; else this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
            msg = this.pending;
            var r = msg.length % this._delta8;
            this.pending = msg.slice(msg.length - r, msg.length);
            if (this.pending.length === 0) this.pending = null;
            msg = utils$o.join32(msg, 0, msg.length - r, this.endian);
            for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
        }
        return this;
    };
    BlockHash$4.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert$d(this.pending === null);
        return this._digest(enc);
    };
    BlockHash$4.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++) res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
            for (var t = 8; t < this.padLength; t++) res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = len >>> 24 & 255;
            res[i++] = len >>> 16 & 255;
            res[i++] = len >>> 8 & 255;
            res[i++] = len & 255;
        } else {
            res[i++] = len & 255;
            res[i++] = len >>> 8 & 255;
            res[i++] = len >>> 16 & 255;
            res[i++] = len >>> 24 & 255;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            res[i++] = 0;
            for (t = 8; t < this.padLength; t++) res[i++] = 0;
        }
        return res;
    };
    var sha = {};
    var common$5 = {};
    var utils$n = utils$p;
    var rotr32 = utils$n.rotr32;
    function ft_1$1(s, x, y, z) {
        if (s === 0) return ch32$1(x, y, z);
        if (s === 1 || s === 3) return p32(x, y, z);
        if (s === 2) return maj32$1(x, y, z);
    }
    common$5.ft_1 = ft_1$1;
    function ch32$1(x, y, z) {
        return x & y ^ ~x & z;
    }
    common$5.ch32 = ch32$1;
    function maj32$1(x, y, z) {
        return x & y ^ x & z ^ y & z;
    }
    common$5.maj32 = maj32$1;
    function p32(x, y, z) {
        return x ^ y ^ z;
    }
    common$5.p32 = p32;
    function s0_256$1(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    common$5.s0_256 = s0_256$1;
    function s1_256$1(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    common$5.s1_256 = s1_256$1;
    function g0_256$1(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    common$5.g0_256 = g0_256$1;
    function g1_256$1(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    common$5.g1_256 = g1_256$1;
    var utils$m = utils$p;
    var common$4 = common$6;
    var shaCommon$1 = common$5;
    var rotl32$1 = utils$m.rotl32;
    var sum32$2 = utils$m.sum32;
    var sum32_5$1 = utils$m.sum32_5;
    var ft_1 = shaCommon$1.ft_1;
    var BlockHash$3 = common$4.BlockHash;
    var sha1_K = [ 1518500249, 1859775393, 2400959708, 3395469782 ];
    function SHA1() {
        if (!(this instanceof SHA1)) return new SHA1;
        BlockHash$3.call(this);
        this.h = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];
        this.W = new Array(80);
    }
    utils$m.inherits(SHA1, BlockHash$3);
    var _1 = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) W[i] = msg[start + i];
        for (;i < W.length; i++) W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
            var s = ~~(i / 20);
            var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
            e = d;
            d = c;
            c = rotl32$1(b, 30);
            b = a;
            a = t;
        }
        this.h[0] = sum32$2(this.h[0], a);
        this.h[1] = sum32$2(this.h[1], b);
        this.h[2] = sum32$2(this.h[2], c);
        this.h[3] = sum32$2(this.h[3], d);
        this.h[4] = sum32$2(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils$m.toHex32(this.h, "big"); else return utils$m.split32(this.h, "big");
    };
    var utils$l = utils$p;
    var common$3 = common$6;
    var shaCommon = common$5;
    var assert$c = minimalisticAssert;
    var sum32$1 = utils$l.sum32;
    var sum32_4$1 = utils$l.sum32_4;
    var sum32_5 = utils$l.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash$2 = common$3.BlockHash;
    var sha256_K = [ 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 ];
    function SHA256$1() {
        if (!(this instanceof SHA256$1)) return new SHA256$1;
        BlockHash$2.call(this);
        this.h = [ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ];
        this.k = sha256_K;
        this.W = new Array(64);
    }
    utils$l.inherits(SHA256$1, BlockHash$2);
    var _256 = SHA256$1;
    SHA256$1.blockSize = 512;
    SHA256$1.outSize = 256;
    SHA256$1.hmacStrength = 192;
    SHA256$1.padLength = 64;
    SHA256$1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) W[i] = msg[start + i];
        for (;i < W.length; i++) W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert$c(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
            var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
            var T2 = sum32$1(s0_256(a), maj32(a, b, c));
            h = g;
            g = f;
            f = e;
            e = sum32$1(d, T1);
            d = c;
            c = b;
            b = a;
            a = sum32$1(T1, T2);
        }
        this.h[0] = sum32$1(this.h[0], a);
        this.h[1] = sum32$1(this.h[1], b);
        this.h[2] = sum32$1(this.h[2], c);
        this.h[3] = sum32$1(this.h[3], d);
        this.h[4] = sum32$1(this.h[4], e);
        this.h[5] = sum32$1(this.h[5], f);
        this.h[6] = sum32$1(this.h[6], g);
        this.h[7] = sum32$1(this.h[7], h);
    };
    SHA256$1.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils$l.toHex32(this.h, "big"); else return utils$l.split32(this.h, "big");
    };
    var utils$k = utils$p;
    var SHA256 = _256;
    function SHA224() {
        if (!(this instanceof SHA224)) return new SHA224;
        SHA256.call(this);
        this.h = [ 3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428 ];
    }
    utils$k.inherits(SHA224, SHA256);
    var _224 = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils$k.toHex32(this.h.slice(0, 7), "big"); else return utils$k.split32(this.h.slice(0, 7), "big");
    };
    var utils$j = utils$p;
    var common$2 = common$6;
    var assert$b = minimalisticAssert;
    var rotr64_hi = utils$j.rotr64_hi;
    var rotr64_lo = utils$j.rotr64_lo;
    var shr64_hi = utils$j.shr64_hi;
    var shr64_lo = utils$j.shr64_lo;
    var sum64 = utils$j.sum64;
    var sum64_hi = utils$j.sum64_hi;
    var sum64_lo = utils$j.sum64_lo;
    var sum64_4_hi = utils$j.sum64_4_hi;
    var sum64_4_lo = utils$j.sum64_4_lo;
    var sum64_5_hi = utils$j.sum64_5_hi;
    var sum64_5_lo = utils$j.sum64_5_lo;
    var BlockHash$1 = common$2.BlockHash;
    var sha512_K = [ 1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591 ];
    function SHA512$1() {
        if (!(this instanceof SHA512$1)) return new SHA512$1;
        BlockHash$1.call(this);
        this.h = [ 1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209 ];
        this.k = sha512_K;
        this.W = new Array(160);
    }
    utils$j.inherits(SHA512$1, BlockHash$1);
    var _512 = SHA512$1;
    SHA512$1.blockSize = 1024;
    SHA512$1.outSize = 512;
    SHA512$1.hmacStrength = 192;
    SHA512$1.padLength = 128;
    SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++) W[i] = msg[start + i];
        for (;i < W.length; i += 2) {
            var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
            var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
            var c1_hi = W[i - 14];
            var c1_lo = W[i - 13];
            var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
            var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
            var c3_hi = W[i - 32];
            var c3_lo = W[i - 31];
            W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
            W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
    };
    SHA512$1.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert$b(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
            var c0_hi = hh;
            var c0_lo = hl;
            var c1_hi = s1_512_hi(eh, el);
            var c1_lo = s1_512_lo(eh, el);
            var c2_hi = ch64_hi(eh, el, fh, fl, gh);
            var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
            var c3_hi = this.k[i];
            var c3_lo = this.k[i + 1];
            var c4_hi = W[i];
            var c4_lo = W[i + 1];
            var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
            var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
            c0_hi = s0_512_hi(ah, al);
            c0_lo = s0_512_lo(ah, al);
            c1_hi = maj64_hi(ah, al, bh, bl, ch);
            c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
            var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
            var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
            hh = gh;
            hl = gl;
            gh = fh;
            gl = fl;
            fh = eh;
            fl = el;
            eh = sum64_hi(dh, dl, T1_hi, T1_lo);
            el = sum64_lo(dl, dl, T1_hi, T1_lo);
            dh = ch;
            dl = cl;
            ch = bh;
            cl = bl;
            bh = ah;
            bl = al;
            ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
            al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
    };
    SHA512$1.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils$j.toHex32(this.h, "big"); else return utils$j.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0) r += 4294967296;
        return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0) r += 4294967296;
        return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0) r += 4294967296;
        return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0) r += 4294967296;
        return r;
    }
    function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0) r += 4294967296;
        return r;
    }
    var utils$i = utils$p;
    var SHA512 = _512;
    function SHA384() {
        if (!(this instanceof SHA384)) return new SHA384;
        SHA512.call(this);
        this.h = [ 3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428 ];
    }
    utils$i.inherits(SHA384, SHA512);
    var _384 = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils$i.toHex32(this.h.slice(0, 12), "big"); else return utils$i.split32(this.h.slice(0, 12), "big");
    };
    sha.sha1 = _1;
    sha.sha224 = _224;
    sha.sha256 = _256;
    sha.sha384 = _384;
    sha.sha512 = _512;
    var ripemd = {};
    var utils$h = utils$p;
    var common$1 = common$6;
    var rotl32 = utils$h.rotl32;
    var sum32 = utils$h.sum32;
    var sum32_3 = utils$h.sum32_3;
    var sum32_4 = utils$h.sum32_4;
    var BlockHash = common$1.BlockHash;
    function RIPEMD160() {
        if (!(this instanceof RIPEMD160)) return new RIPEMD160;
        BlockHash.call(this);
        this.h = [ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ];
        this.endian = "little";
    }
    utils$h.inherits(RIPEMD160, BlockHash);
    ripemd.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
            var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
            A = E;
            E = D;
            D = rotl32(C, 10);
            C = B;
            B = T;
            T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
            Ah = Eh;
            Eh = Dh;
            Dh = rotl32(Ch, 10);
            Ch = Bh;
            Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex") return utils$h.toHex32(this.h, "little"); else return utils$h.split32(this.h, "little");
    };
    function f(j, x, y, z) {
        if (j <= 15) return x ^ y ^ z; else if (j <= 31) return x & y | ~x & z; else if (j <= 47) return (x | ~y) ^ z; else if (j <= 63) return x & z | y & ~z; else return x ^ (y | ~z);
    }
    function K(j) {
        if (j <= 15) return 0; else if (j <= 31) return 1518500249; else if (j <= 47) return 1859775393; else if (j <= 63) return 2400959708; else return 2840853838;
    }
    function Kh(j) {
        if (j <= 15) return 1352829926; else if (j <= 31) return 1548603684; else if (j <= 47) return 1836072691; else if (j <= 63) return 2053994217; else return 0;
    }
    var r = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ];
    var rh = [ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ];
    var s = [ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ];
    var sh = [ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ];
    var utils$g = utils$p;
    var assert$a = minimalisticAssert;
    function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils$g.toArray(key, enc));
    }
    var hmac = Hmac;
    Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize) key = (new this.Hash).update(key).digest();
        assert$a(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++) key.push(0);
        for (i = 0; i < key.length; i++) key[i] ^= 54;
        this.inner = (new this.Hash).update(key);
        for (i = 0; i < key.length; i++) key[i] ^= 106;
        this.outer = (new this.Hash).update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
    };
    Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
    };
    (function(exports) {
        var hash = exports;
        hash.utils = utils$p;
        hash.common = common$6;
        hash.sha = sha;
        hash.ripemd = ripemd;
        hash.hmac = hmac;
        hash.sha1 = hash.sha.sha1;
        hash.sha256 = hash.sha.sha256;
        hash.sha224 = hash.sha.sha224;
        hash.sha384 = hash.sha.sha384;
        hash.sha512 = hash.sha.sha512;
        hash.ripemd160 = hash.ripemd.ripemd160;
    })(hash$2);
    var bn = {
        exports: {}
    };
    (function(module) {
        (function(module, exports) {
            function assert(val, msg) {
                if (!val) throw new Error(msg || "Assertion failed");
            }
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor;
                ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
                if (BN.isBN(number)) {
                    return number;
                }
                this.negative = 0;
                this.words = null;
                this.length = 0;
                this.red = null;
                if (number !== null) {
                    if (base === "le" || base === "be") {
                        endian = base;
                        base = 10;
                    }
                    this._init(number || 0, base || 10, endian || "be");
                }
            }
            if (typeof module === "object") {
                module.exports = BN;
            } else {
                exports.BN = BN;
            }
            BN.BN = BN;
            BN.wordSize = 26;
            var Buffer;
            try {
                if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
                    Buffer = window.Buffer;
                } else {
                    Buffer = require("buffer").Buffer;
                }
            } catch (e) {}
            BN.isBN = function isBN(num) {
                if (num instanceof BN) {
                    return true;
                }
                return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
            };
            BN.max = function max(left, right) {
                if (left.cmp(right) > 0) return left;
                return right;
            };
            BN.min = function min(left, right) {
                if (left.cmp(right) < 0) return left;
                return right;
            };
            BN.prototype._init = function init(number, base, endian) {
                if (typeof number === "number") {
                    return this._initNumber(number, base, endian);
                }
                if (typeof number === "object") {
                    return this._initArray(number, base, endian);
                }
                if (base === "hex") {
                    base = 16;
                }
                assert(base === (base | 0) && base >= 2 && base <= 36);
                number = number.toString().replace(/\s+/g, "");
                var start = 0;
                if (number[0] === "-") {
                    start++;
                    this.negative = 1;
                }
                if (start < number.length) {
                    if (base === 16) {
                        this._parseHex(number, start, endian);
                    } else {
                        this._parseBase(number, base, start);
                        if (endian === "le") {
                            this._initArray(this.toArray(), base, endian);
                        }
                    }
                }
            };
            BN.prototype._initNumber = function _initNumber(number, base, endian) {
                if (number < 0) {
                    this.negative = 1;
                    number = -number;
                }
                if (number < 67108864) {
                    this.words = [ number & 67108863 ];
                    this.length = 1;
                } else if (number < 4503599627370496) {
                    this.words = [ number & 67108863, number / 67108864 & 67108863 ];
                    this.length = 2;
                } else {
                    assert(number < 9007199254740992);
                    this.words = [ number & 67108863, number / 67108864 & 67108863, 1 ];
                    this.length = 3;
                }
                if (endian !== "le") return;
                this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(number, base, endian) {
                assert(typeof number.length === "number");
                if (number.length <= 0) {
                    this.words = [ 0 ];
                    this.length = 1;
                    return this;
                }
                this.length = Math.ceil(number.length / 3);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    this.words[i] = 0;
                }
                var j, w;
                var off = 0;
                if (endian === "be") {
                    for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
                        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                } else if (endian === "le") {
                    for (i = 0, j = 0; i < number.length; i += 3) {
                        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
                        this.words[j] |= w << off & 67108863;
                        this.words[j + 1] = w >>> 26 - off & 67108863;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                }
                return this.strip();
            };
            function parseHex4Bits(string, index) {
                var c = string.charCodeAt(index);
                if (c >= 65 && c <= 70) {
                    return c - 55;
                } else if (c >= 97 && c <= 102) {
                    return c - 87;
                } else {
                    return c - 48 & 15;
                }
            }
            function parseHexByte(string, lowerBound, index) {
                var r = parseHex4Bits(string, index);
                if (index - 1 >= lowerBound) {
                    r |= parseHex4Bits(string, index - 1) << 4;
                }
                return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start, endian) {
                this.length = Math.ceil((number.length - start) / 6);
                this.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    this.words[i] = 0;
                }
                var off = 0;
                var j = 0;
                var w;
                if (endian === "be") {
                    for (i = number.length - 1; i >= start; i -= 2) {
                        w = parseHexByte(number, start, i) << off;
                        this.words[j] |= w & 67108863;
                        if (off >= 18) {
                            off -= 18;
                            j += 1;
                            this.words[j] |= w >>> 26;
                        } else {
                            off += 8;
                        }
                    }
                } else {
                    var parseLength = number.length - start;
                    for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
                        w = parseHexByte(number, start, i) << off;
                        this.words[j] |= w & 67108863;
                        if (off >= 18) {
                            off -= 18;
                            j += 1;
                            this.words[j] |= w >>> 26;
                        } else {
                            off += 8;
                        }
                    }
                }
                this.strip();
            };
            function parseBase(str, start, end, mul) {
                var r = 0;
                var len = Math.min(str.length, end);
                for (var i = start; i < len; i++) {
                    var c = str.charCodeAt(i) - 48;
                    r *= mul;
                    if (c >= 49) {
                        r += c - 49 + 10;
                    } else if (c >= 17) {
                        r += c - 17 + 10;
                    } else {
                        r += c;
                    }
                }
                return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
                this.words = [ 0 ];
                this.length = 1;
                for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
                    limbLen++;
                }
                limbLen--;
                limbPow = limbPow / base | 0;
                var total = number.length - start;
                var mod = total % limbLen;
                var end = Math.min(total, total - mod) + start;
                var word = 0;
                for (var i = start; i < end; i += limbLen) {
                    word = parseBase(number, i, i + limbLen, base);
                    this.imuln(limbPow);
                    if (this.words[0] + word < 67108864) {
                        this.words[0] += word;
                    } else {
                        this._iaddn(word);
                    }
                }
                if (mod !== 0) {
                    var pow = 1;
                    word = parseBase(number, i, number.length, base);
                    for (i = 0; i < mod; i++) {
                        pow *= base;
                    }
                    this.imuln(pow);
                    if (this.words[0] + word < 67108864) {
                        this.words[0] += word;
                    } else {
                        this._iaddn(word);
                    }
                }
                this.strip();
            };
            BN.prototype.copy = function copy(dest) {
                dest.words = new Array(this.length);
                for (var i = 0; i < this.length; i++) {
                    dest.words[i] = this.words[i];
                }
                dest.length = this.length;
                dest.negative = this.negative;
                dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
                var r = new BN(null);
                this.copy(r);
                return r;
            };
            BN.prototype._expand = function _expand(size) {
                while (this.length < size) {
                    this.words[this.length++] = 0;
                }
                return this;
            };
            BN.prototype.strip = function strip() {
                while (this.length > 1 && this.words[this.length - 1] === 0) {
                    this.length--;
                }
                return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
                if (this.length === 1 && this.words[0] === 0) {
                    this.negative = 0;
                }
                return this;
            };
            BN.prototype.inspect = function inspect() {
                return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
            };
            var zeros = [ "", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000" ];
            var groupSizes = [ 0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ];
            var groupBases = [ 0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176 ];
            BN.prototype.toString = function toString(base, padding) {
                base = base || 10;
                padding = padding | 0 || 1;
                var out;
                if (base === 16 || base === "hex") {
                    out = "";
                    var off = 0;
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = this.words[i];
                        var word = ((w << off | carry) & 16777215).toString(16);
                        carry = w >>> 24 - off & 16777215;
                        if (carry !== 0 || i !== this.length - 1) {
                            out = zeros[6 - word.length] + word + out;
                        } else {
                            out = word + out;
                        }
                        off += 2;
                        if (off >= 26) {
                            off -= 26;
                            i--;
                        }
                    }
                    if (carry !== 0) {
                        out = carry.toString(16) + out;
                    }
                    while (out.length % padding !== 0) {
                        out = "0" + out;
                    }
                    if (this.negative !== 0) {
                        out = "-" + out;
                    }
                    return out;
                }
                if (base === (base | 0) && base >= 2 && base <= 36) {
                    var groupSize = groupSizes[base];
                    var groupBase = groupBases[base];
                    out = "";
                    var c = this.clone();
                    c.negative = 0;
                    while (!c.isZero()) {
                        var r = c.modn(groupBase).toString(base);
                        c = c.idivn(groupBase);
                        if (!c.isZero()) {
                            out = zeros[groupSize - r.length] + r + out;
                        } else {
                            out = r + out;
                        }
                    }
                    if (this.isZero()) {
                        out = "0" + out;
                    }
                    while (out.length % padding !== 0) {
                        out = "0" + out;
                    }
                    if (this.negative !== 0) {
                        out = "-" + out;
                    }
                    return out;
                }
                assert(false, "Base should be between 2 and 36");
            };
            BN.prototype.toNumber = function toNumber() {
                var ret = this.words[0];
                if (this.length === 2) {
                    ret += this.words[1] * 67108864;
                } else if (this.length === 3 && this.words[2] === 1) {
                    ret += 4503599627370496 + this.words[1] * 67108864;
                } else if (this.length > 2) {
                    assert(false, "Number can only safely store up to 53 bits");
                }
                return this.negative !== 0 ? -ret : ret;
            };
            BN.prototype.toJSON = function toJSON() {
                return this.toString(16);
            };
            BN.prototype.toBuffer = function toBuffer(endian, length) {
                assert(typeof Buffer !== "undefined");
                return this.toArrayLike(Buffer, endian, length);
            };
            BN.prototype.toArray = function toArray(endian, length) {
                return this.toArrayLike(Array, endian, length);
            };
            BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
                var byteLength = this.byteLength();
                var reqLength = length || Math.max(1, byteLength);
                assert(byteLength <= reqLength, "byte array longer than desired length");
                assert(reqLength > 0, "Requested array length <= 0");
                this.strip();
                var littleEndian = endian === "le";
                var res = new ArrayType(reqLength);
                var b, i;
                var q = this.clone();
                if (!littleEndian) {
                    for (i = 0; i < reqLength - byteLength; i++) {
                        res[i] = 0;
                    }
                    for (i = 0; !q.isZero(); i++) {
                        b = q.andln(255);
                        q.iushrn(8);
                        res[reqLength - i - 1] = b;
                    }
                } else {
                    for (i = 0; !q.isZero(); i++) {
                        b = q.andln(255);
                        q.iushrn(8);
                        res[i] = b;
                    }
                    for (;i < reqLength; i++) {
                        res[i] = 0;
                    }
                }
                return res;
            };
            if (Math.clz32) {
                BN.prototype._countBits = function _countBits(w) {
                    return 32 - Math.clz32(w);
                };
            } else {
                BN.prototype._countBits = function _countBits(w) {
                    var t = w;
                    var r = 0;
                    if (t >= 4096) {
                        r += 13;
                        t >>>= 13;
                    }
                    if (t >= 64) {
                        r += 7;
                        t >>>= 7;
                    }
                    if (t >= 8) {
                        r += 4;
                        t >>>= 4;
                    }
                    if (t >= 2) {
                        r += 2;
                        t >>>= 2;
                    }
                    return r + t;
                };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
                if (w === 0) return 26;
                var t = w;
                var r = 0;
                if ((t & 8191) === 0) {
                    r += 13;
                    t >>>= 13;
                }
                if ((t & 127) === 0) {
                    r += 7;
                    t >>>= 7;
                }
                if ((t & 15) === 0) {
                    r += 4;
                    t >>>= 4;
                }
                if ((t & 3) === 0) {
                    r += 2;
                    t >>>= 2;
                }
                if ((t & 1) === 0) {
                    r++;
                }
                return r;
            };
            BN.prototype.bitLength = function bitLength() {
                var w = this.words[this.length - 1];
                var hi = this._countBits(w);
                return (this.length - 1) * 26 + hi;
            };
            function toBitArray(num) {
                var w = new Array(num.bitLength());
                for (var bit = 0; bit < w.length; bit++) {
                    var off = bit / 26 | 0;
                    var wbit = bit % 26;
                    w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
                }
                return w;
            }
            BN.prototype.zeroBits = function zeroBits() {
                if (this.isZero()) return 0;
                var r = 0;
                for (var i = 0; i < this.length; i++) {
                    var b = this._zeroBits(this.words[i]);
                    r += b;
                    if (b !== 26) break;
                }
                return r;
            };
            BN.prototype.byteLength = function byteLength() {
                return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.toTwos = function toTwos(width) {
                if (this.negative !== 0) {
                    return this.abs().inotn(width).iaddn(1);
                }
                return this.clone();
            };
            BN.prototype.fromTwos = function fromTwos(width) {
                if (this.testn(width - 1)) {
                    return this.notn(width).iaddn(1).ineg();
                }
                return this.clone();
            };
            BN.prototype.isNeg = function isNeg() {
                return this.negative !== 0;
            };
            BN.prototype.neg = function neg() {
                return this.clone().ineg();
            };
            BN.prototype.ineg = function ineg() {
                if (!this.isZero()) {
                    this.negative ^= 1;
                }
                return this;
            };
            BN.prototype.iuor = function iuor(num) {
                while (this.length < num.length) {
                    this.words[this.length++] = 0;
                }
                for (var i = 0; i < num.length; i++) {
                    this.words[i] = this.words[i] | num.words[i];
                }
                return this.strip();
            };
            BN.prototype.ior = function ior(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuor(num);
            };
            BN.prototype.or = function or(num) {
                if (this.length > num.length) return this.clone().ior(num);
                return num.clone().ior(this);
            };
            BN.prototype.uor = function uor(num) {
                if (this.length > num.length) return this.clone().iuor(num);
                return num.clone().iuor(this);
            };
            BN.prototype.iuand = function iuand(num) {
                var b;
                if (this.length > num.length) {
                    b = num;
                } else {
                    b = this;
                }
                for (var i = 0; i < b.length; i++) {
                    this.words[i] = this.words[i] & num.words[i];
                }
                this.length = b.length;
                return this.strip();
            };
            BN.prototype.iand = function iand(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuand(num);
            };
            BN.prototype.and = function and(num) {
                if (this.length > num.length) return this.clone().iand(num);
                return num.clone().iand(this);
            };
            BN.prototype.uand = function uand(num) {
                if (this.length > num.length) return this.clone().iuand(num);
                return num.clone().iuand(this);
            };
            BN.prototype.iuxor = function iuxor(num) {
                var a;
                var b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                for (var i = 0; i < b.length; i++) {
                    this.words[i] = a.words[i] ^ b.words[i];
                }
                if (this !== a) {
                    for (;i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }
                this.length = a.length;
                return this.strip();
            };
            BN.prototype.ixor = function ixor(num) {
                assert((this.negative | num.negative) === 0);
                return this.iuxor(num);
            };
            BN.prototype.xor = function xor(num) {
                if (this.length > num.length) return this.clone().ixor(num);
                return num.clone().ixor(this);
            };
            BN.prototype.uxor = function uxor(num) {
                if (this.length > num.length) return this.clone().iuxor(num);
                return num.clone().iuxor(this);
            };
            BN.prototype.inotn = function inotn(width) {
                assert(typeof width === "number" && width >= 0);
                var bytesNeeded = Math.ceil(width / 26) | 0;
                var bitsLeft = width % 26;
                this._expand(bytesNeeded);
                if (bitsLeft > 0) {
                    bytesNeeded--;
                }
                for (var i = 0; i < bytesNeeded; i++) {
                    this.words[i] = ~this.words[i] & 67108863;
                }
                if (bitsLeft > 0) {
                    this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
                }
                return this.strip();
            };
            BN.prototype.notn = function notn(width) {
                return this.clone().inotn(width);
            };
            BN.prototype.setn = function setn(bit, val) {
                assert(typeof bit === "number" && bit >= 0);
                var off = bit / 26 | 0;
                var wbit = bit % 26;
                this._expand(off + 1);
                if (val) {
                    this.words[off] = this.words[off] | 1 << wbit;
                } else {
                    this.words[off] = this.words[off] & ~(1 << wbit);
                }
                return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
                var r;
                if (this.negative !== 0 && num.negative === 0) {
                    this.negative = 0;
                    r = this.isub(num);
                    this.negative ^= 1;
                    return this._normSign();
                } else if (this.negative === 0 && num.negative !== 0) {
                    num.negative = 0;
                    r = this.isub(num);
                    num.negative = 1;
                    return r._normSign();
                }
                var a, b;
                if (this.length > num.length) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    r = (a.words[i] | 0) + carry;
                    this.words[i] = r & 67108863;
                    carry = r >>> 26;
                }
                this.length = a.length;
                if (carry !== 0) {
                    this.words[this.length] = carry;
                    this.length++;
                } else if (a !== this) {
                    for (;i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }
                return this;
            };
            BN.prototype.add = function add(num) {
                var res;
                if (num.negative !== 0 && this.negative === 0) {
                    num.negative = 0;
                    res = this.sub(num);
                    num.negative ^= 1;
                    return res;
                } else if (num.negative === 0 && this.negative !== 0) {
                    this.negative = 0;
                    res = num.sub(this);
                    this.negative = 1;
                    return res;
                }
                if (this.length > num.length) return this.clone().iadd(num);
                return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
                if (num.negative !== 0) {
                    num.negative = 0;
                    var r = this.iadd(num);
                    num.negative = 1;
                    return r._normSign();
                } else if (this.negative !== 0) {
                    this.negative = 0;
                    this.iadd(num);
                    this.negative = 1;
                    return this._normSign();
                }
                var cmp = this.cmp(num);
                if (cmp === 0) {
                    this.negative = 0;
                    this.length = 1;
                    this.words[0] = 0;
                    return this;
                }
                var a, b;
                if (cmp > 0) {
                    a = this;
                    b = num;
                } else {
                    a = num;
                    b = this;
                }
                var carry = 0;
                for (var i = 0; i < b.length; i++) {
                    r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                for (;carry !== 0 && i < a.length; i++) {
                    r = (a.words[i] | 0) + carry;
                    carry = r >> 26;
                    this.words[i] = r & 67108863;
                }
                if (carry === 0 && i < a.length && a !== this) {
                    for (;i < a.length; i++) {
                        this.words[i] = a.words[i];
                    }
                }
                this.length = Math.max(this.length, i);
                if (a !== this) {
                    this.negative = 1;
                }
                return this.strip();
            };
            BN.prototype.sub = function sub(num) {
                return this.clone().isub(num);
            };
            function smallMulTo(self, num, out) {
                out.negative = num.negative ^ self.negative;
                var len = self.length + num.length | 0;
                out.length = len;
                len = len - 1 | 0;
                var a = self.words[0] | 0;
                var b = num.words[0] | 0;
                var r = a * b;
                var lo = r & 67108863;
                var carry = r / 67108864 | 0;
                out.words[0] = lo;
                for (var k = 1; k < len; k++) {
                    var ncarry = carry >>> 26;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                        var i = k - j | 0;
                        a = self.words[i] | 0;
                        b = num.words[j] | 0;
                        r = a * b + rword;
                        ncarry += r / 67108864 | 0;
                        rword = r & 67108863;
                    }
                    out.words[k] = rword | 0;
                    carry = ncarry | 0;
                }
                if (carry !== 0) {
                    out.words[k] = carry | 0;
                } else {
                    out.length--;
                }
                return out.strip();
            }
            var comb10MulTo = function comb10MulTo(self, num, out) {
                var a = self.words;
                var b = num.words;
                var o = out.words;
                var c = 0;
                var lo;
                var mid;
                var hi;
                var a0 = a[0] | 0;
                var al0 = a0 & 8191;
                var ah0 = a0 >>> 13;
                var a1 = a[1] | 0;
                var al1 = a1 & 8191;
                var ah1 = a1 >>> 13;
                var a2 = a[2] | 0;
                var al2 = a2 & 8191;
                var ah2 = a2 >>> 13;
                var a3 = a[3] | 0;
                var al3 = a3 & 8191;
                var ah3 = a3 >>> 13;
                var a4 = a[4] | 0;
                var al4 = a4 & 8191;
                var ah4 = a4 >>> 13;
                var a5 = a[5] | 0;
                var al5 = a5 & 8191;
                var ah5 = a5 >>> 13;
                var a6 = a[6] | 0;
                var al6 = a6 & 8191;
                var ah6 = a6 >>> 13;
                var a7 = a[7] | 0;
                var al7 = a7 & 8191;
                var ah7 = a7 >>> 13;
                var a8 = a[8] | 0;
                var al8 = a8 & 8191;
                var ah8 = a8 >>> 13;
                var a9 = a[9] | 0;
                var al9 = a9 & 8191;
                var ah9 = a9 >>> 13;
                var b0 = b[0] | 0;
                var bl0 = b0 & 8191;
                var bh0 = b0 >>> 13;
                var b1 = b[1] | 0;
                var bl1 = b1 & 8191;
                var bh1 = b1 >>> 13;
                var b2 = b[2] | 0;
                var bl2 = b2 & 8191;
                var bh2 = b2 >>> 13;
                var b3 = b[3] | 0;
                var bl3 = b3 & 8191;
                var bh3 = b3 >>> 13;
                var b4 = b[4] | 0;
                var bl4 = b4 & 8191;
                var bh4 = b4 >>> 13;
                var b5 = b[5] | 0;
                var bl5 = b5 & 8191;
                var bh5 = b5 >>> 13;
                var b6 = b[6] | 0;
                var bl6 = b6 & 8191;
                var bh6 = b6 >>> 13;
                var b7 = b[7] | 0;
                var bl7 = b7 & 8191;
                var bh7 = b7 >>> 13;
                var b8 = b[8] | 0;
                var bl8 = b8 & 8191;
                var bh8 = b8 >>> 13;
                var b9 = b[9] | 0;
                var bl9 = b9 & 8191;
                var bh9 = b9 >>> 13;
                out.negative = self.negative ^ num.negative;
                out.length = 19;
                lo = Math.imul(al0, bl0);
                mid = Math.imul(al0, bh0);
                mid = mid + Math.imul(ah0, bl0) | 0;
                hi = Math.imul(ah0, bh0);
                var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
                w0 &= 67108863;
                lo = Math.imul(al1, bl0);
                mid = Math.imul(al1, bh0);
                mid = mid + Math.imul(ah1, bl0) | 0;
                hi = Math.imul(ah1, bh0);
                lo = lo + Math.imul(al0, bl1) | 0;
                mid = mid + Math.imul(al0, bh1) | 0;
                mid = mid + Math.imul(ah0, bl1) | 0;
                hi = hi + Math.imul(ah0, bh1) | 0;
                var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
                w1 &= 67108863;
                lo = Math.imul(al2, bl0);
                mid = Math.imul(al2, bh0);
                mid = mid + Math.imul(ah2, bl0) | 0;
                hi = Math.imul(ah2, bh0);
                lo = lo + Math.imul(al1, bl1) | 0;
                mid = mid + Math.imul(al1, bh1) | 0;
                mid = mid + Math.imul(ah1, bl1) | 0;
                hi = hi + Math.imul(ah1, bh1) | 0;
                lo = lo + Math.imul(al0, bl2) | 0;
                mid = mid + Math.imul(al0, bh2) | 0;
                mid = mid + Math.imul(ah0, bl2) | 0;
                hi = hi + Math.imul(ah0, bh2) | 0;
                var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
                w2 &= 67108863;
                lo = Math.imul(al3, bl0);
                mid = Math.imul(al3, bh0);
                mid = mid + Math.imul(ah3, bl0) | 0;
                hi = Math.imul(ah3, bh0);
                lo = lo + Math.imul(al2, bl1) | 0;
                mid = mid + Math.imul(al2, bh1) | 0;
                mid = mid + Math.imul(ah2, bl1) | 0;
                hi = hi + Math.imul(ah2, bh1) | 0;
                lo = lo + Math.imul(al1, bl2) | 0;
                mid = mid + Math.imul(al1, bh2) | 0;
                mid = mid + Math.imul(ah1, bl2) | 0;
                hi = hi + Math.imul(ah1, bh2) | 0;
                lo = lo + Math.imul(al0, bl3) | 0;
                mid = mid + Math.imul(al0, bh3) | 0;
                mid = mid + Math.imul(ah0, bl3) | 0;
                hi = hi + Math.imul(ah0, bh3) | 0;
                var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
                w3 &= 67108863;
                lo = Math.imul(al4, bl0);
                mid = Math.imul(al4, bh0);
                mid = mid + Math.imul(ah4, bl0) | 0;
                hi = Math.imul(ah4, bh0);
                lo = lo + Math.imul(al3, bl1) | 0;
                mid = mid + Math.imul(al3, bh1) | 0;
                mid = mid + Math.imul(ah3, bl1) | 0;
                hi = hi + Math.imul(ah3, bh1) | 0;
                lo = lo + Math.imul(al2, bl2) | 0;
                mid = mid + Math.imul(al2, bh2) | 0;
                mid = mid + Math.imul(ah2, bl2) | 0;
                hi = hi + Math.imul(ah2, bh2) | 0;
                lo = lo + Math.imul(al1, bl3) | 0;
                mid = mid + Math.imul(al1, bh3) | 0;
                mid = mid + Math.imul(ah1, bl3) | 0;
                hi = hi + Math.imul(ah1, bh3) | 0;
                lo = lo + Math.imul(al0, bl4) | 0;
                mid = mid + Math.imul(al0, bh4) | 0;
                mid = mid + Math.imul(ah0, bl4) | 0;
                hi = hi + Math.imul(ah0, bh4) | 0;
                var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
                w4 &= 67108863;
                lo = Math.imul(al5, bl0);
                mid = Math.imul(al5, bh0);
                mid = mid + Math.imul(ah5, bl0) | 0;
                hi = Math.imul(ah5, bh0);
                lo = lo + Math.imul(al4, bl1) | 0;
                mid = mid + Math.imul(al4, bh1) | 0;
                mid = mid + Math.imul(ah4, bl1) | 0;
                hi = hi + Math.imul(ah4, bh1) | 0;
                lo = lo + Math.imul(al3, bl2) | 0;
                mid = mid + Math.imul(al3, bh2) | 0;
                mid = mid + Math.imul(ah3, bl2) | 0;
                hi = hi + Math.imul(ah3, bh2) | 0;
                lo = lo + Math.imul(al2, bl3) | 0;
                mid = mid + Math.imul(al2, bh3) | 0;
                mid = mid + Math.imul(ah2, bl3) | 0;
                hi = hi + Math.imul(ah2, bh3) | 0;
                lo = lo + Math.imul(al1, bl4) | 0;
                mid = mid + Math.imul(al1, bh4) | 0;
                mid = mid + Math.imul(ah1, bl4) | 0;
                hi = hi + Math.imul(ah1, bh4) | 0;
                lo = lo + Math.imul(al0, bl5) | 0;
                mid = mid + Math.imul(al0, bh5) | 0;
                mid = mid + Math.imul(ah0, bl5) | 0;
                hi = hi + Math.imul(ah0, bh5) | 0;
                var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
                w5 &= 67108863;
                lo = Math.imul(al6, bl0);
                mid = Math.imul(al6, bh0);
                mid = mid + Math.imul(ah6, bl0) | 0;
                hi = Math.imul(ah6, bh0);
                lo = lo + Math.imul(al5, bl1) | 0;
                mid = mid + Math.imul(al5, bh1) | 0;
                mid = mid + Math.imul(ah5, bl1) | 0;
                hi = hi + Math.imul(ah5, bh1) | 0;
                lo = lo + Math.imul(al4, bl2) | 0;
                mid = mid + Math.imul(al4, bh2) | 0;
                mid = mid + Math.imul(ah4, bl2) | 0;
                hi = hi + Math.imul(ah4, bh2) | 0;
                lo = lo + Math.imul(al3, bl3) | 0;
                mid = mid + Math.imul(al3, bh3) | 0;
                mid = mid + Math.imul(ah3, bl3) | 0;
                hi = hi + Math.imul(ah3, bh3) | 0;
                lo = lo + Math.imul(al2, bl4) | 0;
                mid = mid + Math.imul(al2, bh4) | 0;
                mid = mid + Math.imul(ah2, bl4) | 0;
                hi = hi + Math.imul(ah2, bh4) | 0;
                lo = lo + Math.imul(al1, bl5) | 0;
                mid = mid + Math.imul(al1, bh5) | 0;
                mid = mid + Math.imul(ah1, bl5) | 0;
                hi = hi + Math.imul(ah1, bh5) | 0;
                lo = lo + Math.imul(al0, bl6) | 0;
                mid = mid + Math.imul(al0, bh6) | 0;
                mid = mid + Math.imul(ah0, bl6) | 0;
                hi = hi + Math.imul(ah0, bh6) | 0;
                var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
                w6 &= 67108863;
                lo = Math.imul(al7, bl0);
                mid = Math.imul(al7, bh0);
                mid = mid + Math.imul(ah7, bl0) | 0;
                hi = Math.imul(ah7, bh0);
                lo = lo + Math.imul(al6, bl1) | 0;
                mid = mid + Math.imul(al6, bh1) | 0;
                mid = mid + Math.imul(ah6, bl1) | 0;
                hi = hi + Math.imul(ah6, bh1) | 0;
                lo = lo + Math.imul(al5, bl2) | 0;
                mid = mid + Math.imul(al5, bh2) | 0;
                mid = mid + Math.imul(ah5, bl2) | 0;
                hi = hi + Math.imul(ah5, bh2) | 0;
                lo = lo + Math.imul(al4, bl3) | 0;
                mid = mid + Math.imul(al4, bh3) | 0;
                mid = mid + Math.imul(ah4, bl3) | 0;
                hi = hi + Math.imul(ah4, bh3) | 0;
                lo = lo + Math.imul(al3, bl4) | 0;
                mid = mid + Math.imul(al3, bh4) | 0;
                mid = mid + Math.imul(ah3, bl4) | 0;
                hi = hi + Math.imul(ah3, bh4) | 0;
                lo = lo + Math.imul(al2, bl5) | 0;
                mid = mid + Math.imul(al2, bh5) | 0;
                mid = mid + Math.imul(ah2, bl5) | 0;
                hi = hi + Math.imul(ah2, bh5) | 0;
                lo = lo + Math.imul(al1, bl6) | 0;
                mid = mid + Math.imul(al1, bh6) | 0;
                mid = mid + Math.imul(ah1, bl6) | 0;
                hi = hi + Math.imul(ah1, bh6) | 0;
                lo = lo + Math.imul(al0, bl7) | 0;
                mid = mid + Math.imul(al0, bh7) | 0;
                mid = mid + Math.imul(ah0, bl7) | 0;
                hi = hi + Math.imul(ah0, bh7) | 0;
                var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
                w7 &= 67108863;
                lo = Math.imul(al8, bl0);
                mid = Math.imul(al8, bh0);
                mid = mid + Math.imul(ah8, bl0) | 0;
                hi = Math.imul(ah8, bh0);
                lo = lo + Math.imul(al7, bl1) | 0;
                mid = mid + Math.imul(al7, bh1) | 0;
                mid = mid + Math.imul(ah7, bl1) | 0;
                hi = hi + Math.imul(ah7, bh1) | 0;
                lo = lo + Math.imul(al6, bl2) | 0;
                mid = mid + Math.imul(al6, bh2) | 0;
                mid = mid + Math.imul(ah6, bl2) | 0;
                hi = hi + Math.imul(ah6, bh2) | 0;
                lo = lo + Math.imul(al5, bl3) | 0;
                mid = mid + Math.imul(al5, bh3) | 0;
                mid = mid + Math.imul(ah5, bl3) | 0;
                hi = hi + Math.imul(ah5, bh3) | 0;
                lo = lo + Math.imul(al4, bl4) | 0;
                mid = mid + Math.imul(al4, bh4) | 0;
                mid = mid + Math.imul(ah4, bl4) | 0;
                hi = hi + Math.imul(ah4, bh4) | 0;
                lo = lo + Math.imul(al3, bl5) | 0;
                mid = mid + Math.imul(al3, bh5) | 0;
                mid = mid + Math.imul(ah3, bl5) | 0;
                hi = hi + Math.imul(ah3, bh5) | 0;
                lo = lo + Math.imul(al2, bl6) | 0;
                mid = mid + Math.imul(al2, bh6) | 0;
                mid = mid + Math.imul(ah2, bl6) | 0;
                hi = hi + Math.imul(ah2, bh6) | 0;
                lo = lo + Math.imul(al1, bl7) | 0;
                mid = mid + Math.imul(al1, bh7) | 0;
                mid = mid + Math.imul(ah1, bl7) | 0;
                hi = hi + Math.imul(ah1, bh7) | 0;
                lo = lo + Math.imul(al0, bl8) | 0;
                mid = mid + Math.imul(al0, bh8) | 0;
                mid = mid + Math.imul(ah0, bl8) | 0;
                hi = hi + Math.imul(ah0, bh8) | 0;
                var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
                w8 &= 67108863;
                lo = Math.imul(al9, bl0);
                mid = Math.imul(al9, bh0);
                mid = mid + Math.imul(ah9, bl0) | 0;
                hi = Math.imul(ah9, bh0);
                lo = lo + Math.imul(al8, bl1) | 0;
                mid = mid + Math.imul(al8, bh1) | 0;
                mid = mid + Math.imul(ah8, bl1) | 0;
                hi = hi + Math.imul(ah8, bh1) | 0;
                lo = lo + Math.imul(al7, bl2) | 0;
                mid = mid + Math.imul(al7, bh2) | 0;
                mid = mid + Math.imul(ah7, bl2) | 0;
                hi = hi + Math.imul(ah7, bh2) | 0;
                lo = lo + Math.imul(al6, bl3) | 0;
                mid = mid + Math.imul(al6, bh3) | 0;
                mid = mid + Math.imul(ah6, bl3) | 0;
                hi = hi + Math.imul(ah6, bh3) | 0;
                lo = lo + Math.imul(al5, bl4) | 0;
                mid = mid + Math.imul(al5, bh4) | 0;
                mid = mid + Math.imul(ah5, bl4) | 0;
                hi = hi + Math.imul(ah5, bh4) | 0;
                lo = lo + Math.imul(al4, bl5) | 0;
                mid = mid + Math.imul(al4, bh5) | 0;
                mid = mid + Math.imul(ah4, bl5) | 0;
                hi = hi + Math.imul(ah4, bh5) | 0;
                lo = lo + Math.imul(al3, bl6) | 0;
                mid = mid + Math.imul(al3, bh6) | 0;
                mid = mid + Math.imul(ah3, bl6) | 0;
                hi = hi + Math.imul(ah3, bh6) | 0;
                lo = lo + Math.imul(al2, bl7) | 0;
                mid = mid + Math.imul(al2, bh7) | 0;
                mid = mid + Math.imul(ah2, bl7) | 0;
                hi = hi + Math.imul(ah2, bh7) | 0;
                lo = lo + Math.imul(al1, bl8) | 0;
                mid = mid + Math.imul(al1, bh8) | 0;
                mid = mid + Math.imul(ah1, bl8) | 0;
                hi = hi + Math.imul(ah1, bh8) | 0;
                lo = lo + Math.imul(al0, bl9) | 0;
                mid = mid + Math.imul(al0, bh9) | 0;
                mid = mid + Math.imul(ah0, bl9) | 0;
                hi = hi + Math.imul(ah0, bh9) | 0;
                var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
                w9 &= 67108863;
                lo = Math.imul(al9, bl1);
                mid = Math.imul(al9, bh1);
                mid = mid + Math.imul(ah9, bl1) | 0;
                hi = Math.imul(ah9, bh1);
                lo = lo + Math.imul(al8, bl2) | 0;
                mid = mid + Math.imul(al8, bh2) | 0;
                mid = mid + Math.imul(ah8, bl2) | 0;
                hi = hi + Math.imul(ah8, bh2) | 0;
                lo = lo + Math.imul(al7, bl3) | 0;
                mid = mid + Math.imul(al7, bh3) | 0;
                mid = mid + Math.imul(ah7, bl3) | 0;
                hi = hi + Math.imul(ah7, bh3) | 0;
                lo = lo + Math.imul(al6, bl4) | 0;
                mid = mid + Math.imul(al6, bh4) | 0;
                mid = mid + Math.imul(ah6, bl4) | 0;
                hi = hi + Math.imul(ah6, bh4) | 0;
                lo = lo + Math.imul(al5, bl5) | 0;
                mid = mid + Math.imul(al5, bh5) | 0;
                mid = mid + Math.imul(ah5, bl5) | 0;
                hi = hi + Math.imul(ah5, bh5) | 0;
                lo = lo + Math.imul(al4, bl6) | 0;
                mid = mid + Math.imul(al4, bh6) | 0;
                mid = mid + Math.imul(ah4, bl6) | 0;
                hi = hi + Math.imul(ah4, bh6) | 0;
                lo = lo + Math.imul(al3, bl7) | 0;
                mid = mid + Math.imul(al3, bh7) | 0;
                mid = mid + Math.imul(ah3, bl7) | 0;
                hi = hi + Math.imul(ah3, bh7) | 0;
                lo = lo + Math.imul(al2, bl8) | 0;
                mid = mid + Math.imul(al2, bh8) | 0;
                mid = mid + Math.imul(ah2, bl8) | 0;
                hi = hi + Math.imul(ah2, bh8) | 0;
                lo = lo + Math.imul(al1, bl9) | 0;
                mid = mid + Math.imul(al1, bh9) | 0;
                mid = mid + Math.imul(ah1, bl9) | 0;
                hi = hi + Math.imul(ah1, bh9) | 0;
                var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
                w10 &= 67108863;
                lo = Math.imul(al9, bl2);
                mid = Math.imul(al9, bh2);
                mid = mid + Math.imul(ah9, bl2) | 0;
                hi = Math.imul(ah9, bh2);
                lo = lo + Math.imul(al8, bl3) | 0;
                mid = mid + Math.imul(al8, bh3) | 0;
                mid = mid + Math.imul(ah8, bl3) | 0;
                hi = hi + Math.imul(ah8, bh3) | 0;
                lo = lo + Math.imul(al7, bl4) | 0;
                mid = mid + Math.imul(al7, bh4) | 0;
                mid = mid + Math.imul(ah7, bl4) | 0;
                hi = hi + Math.imul(ah7, bh4) | 0;
                lo = lo + Math.imul(al6, bl5) | 0;
                mid = mid + Math.imul(al6, bh5) | 0;
                mid = mid + Math.imul(ah6, bl5) | 0;
                hi = hi + Math.imul(ah6, bh5) | 0;
                lo = lo + Math.imul(al5, bl6) | 0;
                mid = mid + Math.imul(al5, bh6) | 0;
                mid = mid + Math.imul(ah5, bl6) | 0;
                hi = hi + Math.imul(ah5, bh6) | 0;
                lo = lo + Math.imul(al4, bl7) | 0;
                mid = mid + Math.imul(al4, bh7) | 0;
                mid = mid + Math.imul(ah4, bl7) | 0;
                hi = hi + Math.imul(ah4, bh7) | 0;
                lo = lo + Math.imul(al3, bl8) | 0;
                mid = mid + Math.imul(al3, bh8) | 0;
                mid = mid + Math.imul(ah3, bl8) | 0;
                hi = hi + Math.imul(ah3, bh8) | 0;
                lo = lo + Math.imul(al2, bl9) | 0;
                mid = mid + Math.imul(al2, bh9) | 0;
                mid = mid + Math.imul(ah2, bl9) | 0;
                hi = hi + Math.imul(ah2, bh9) | 0;
                var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
                w11 &= 67108863;
                lo = Math.imul(al9, bl3);
                mid = Math.imul(al9, bh3);
                mid = mid + Math.imul(ah9, bl3) | 0;
                hi = Math.imul(ah9, bh3);
                lo = lo + Math.imul(al8, bl4) | 0;
                mid = mid + Math.imul(al8, bh4) | 0;
                mid = mid + Math.imul(ah8, bl4) | 0;
                hi = hi + Math.imul(ah8, bh4) | 0;
                lo = lo + Math.imul(al7, bl5) | 0;
                mid = mid + Math.imul(al7, bh5) | 0;
                mid = mid + Math.imul(ah7, bl5) | 0;
                hi = hi + Math.imul(ah7, bh5) | 0;
                lo = lo + Math.imul(al6, bl6) | 0;
                mid = mid + Math.imul(al6, bh6) | 0;
                mid = mid + Math.imul(ah6, bl6) | 0;
                hi = hi + Math.imul(ah6, bh6) | 0;
                lo = lo + Math.imul(al5, bl7) | 0;
                mid = mid + Math.imul(al5, bh7) | 0;
                mid = mid + Math.imul(ah5, bl7) | 0;
                hi = hi + Math.imul(ah5, bh7) | 0;
                lo = lo + Math.imul(al4, bl8) | 0;
                mid = mid + Math.imul(al4, bh8) | 0;
                mid = mid + Math.imul(ah4, bl8) | 0;
                hi = hi + Math.imul(ah4, bh8) | 0;
                lo = lo + Math.imul(al3, bl9) | 0;
                mid = mid + Math.imul(al3, bh9) | 0;
                mid = mid + Math.imul(ah3, bl9) | 0;
                hi = hi + Math.imul(ah3, bh9) | 0;
                var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
                w12 &= 67108863;
                lo = Math.imul(al9, bl4);
                mid = Math.imul(al9, bh4);
                mid = mid + Math.imul(ah9, bl4) | 0;
                hi = Math.imul(ah9, bh4);
                lo = lo + Math.imul(al8, bl5) | 0;
                mid = mid + Math.imul(al8, bh5) | 0;
                mid = mid + Math.imul(ah8, bl5) | 0;
                hi = hi + Math.imul(ah8, bh5) | 0;
                lo = lo + Math.imul(al7, bl6) | 0;
                mid = mid + Math.imul(al7, bh6) | 0;
                mid = mid + Math.imul(ah7, bl6) | 0;
                hi = hi + Math.imul(ah7, bh6) | 0;
                lo = lo + Math.imul(al6, bl7) | 0;
                mid = mid + Math.imul(al6, bh7) | 0;
                mid = mid + Math.imul(ah6, bl7) | 0;
                hi = hi + Math.imul(ah6, bh7) | 0;
                lo = lo + Math.imul(al5, bl8) | 0;
                mid = mid + Math.imul(al5, bh8) | 0;
                mid = mid + Math.imul(ah5, bl8) | 0;
                hi = hi + Math.imul(ah5, bh8) | 0;
                lo = lo + Math.imul(al4, bl9) | 0;
                mid = mid + Math.imul(al4, bh9) | 0;
                mid = mid + Math.imul(ah4, bl9) | 0;
                hi = hi + Math.imul(ah4, bh9) | 0;
                var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
                w13 &= 67108863;
                lo = Math.imul(al9, bl5);
                mid = Math.imul(al9, bh5);
                mid = mid + Math.imul(ah9, bl5) | 0;
                hi = Math.imul(ah9, bh5);
                lo = lo + Math.imul(al8, bl6) | 0;
                mid = mid + Math.imul(al8, bh6) | 0;
                mid = mid + Math.imul(ah8, bl6) | 0;
                hi = hi + Math.imul(ah8, bh6) | 0;
                lo = lo + Math.imul(al7, bl7) | 0;
                mid = mid + Math.imul(al7, bh7) | 0;
                mid = mid + Math.imul(ah7, bl7) | 0;
                hi = hi + Math.imul(ah7, bh7) | 0;
                lo = lo + Math.imul(al6, bl8) | 0;
                mid = mid + Math.imul(al6, bh8) | 0;
                mid = mid + Math.imul(ah6, bl8) | 0;
                hi = hi + Math.imul(ah6, bh8) | 0;
                lo = lo + Math.imul(al5, bl9) | 0;
                mid = mid + Math.imul(al5, bh9) | 0;
                mid = mid + Math.imul(ah5, bl9) | 0;
                hi = hi + Math.imul(ah5, bh9) | 0;
                var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
                w14 &= 67108863;
                lo = Math.imul(al9, bl6);
                mid = Math.imul(al9, bh6);
                mid = mid + Math.imul(ah9, bl6) | 0;
                hi = Math.imul(ah9, bh6);
                lo = lo + Math.imul(al8, bl7) | 0;
                mid = mid + Math.imul(al8, bh7) | 0;
                mid = mid + Math.imul(ah8, bl7) | 0;
                hi = hi + Math.imul(ah8, bh7) | 0;
                lo = lo + Math.imul(al7, bl8) | 0;
                mid = mid + Math.imul(al7, bh8) | 0;
                mid = mid + Math.imul(ah7, bl8) | 0;
                hi = hi + Math.imul(ah7, bh8) | 0;
                lo = lo + Math.imul(al6, bl9) | 0;
                mid = mid + Math.imul(al6, bh9) | 0;
                mid = mid + Math.imul(ah6, bl9) | 0;
                hi = hi + Math.imul(ah6, bh9) | 0;
                var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
                w15 &= 67108863;
                lo = Math.imul(al9, bl7);
                mid = Math.imul(al9, bh7);
                mid = mid + Math.imul(ah9, bl7) | 0;
                hi = Math.imul(ah9, bh7);
                lo = lo + Math.imul(al8, bl8) | 0;
                mid = mid + Math.imul(al8, bh8) | 0;
                mid = mid + Math.imul(ah8, bl8) | 0;
                hi = hi + Math.imul(ah8, bh8) | 0;
                lo = lo + Math.imul(al7, bl9) | 0;
                mid = mid + Math.imul(al7, bh9) | 0;
                mid = mid + Math.imul(ah7, bl9) | 0;
                hi = hi + Math.imul(ah7, bh9) | 0;
                var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
                w16 &= 67108863;
                lo = Math.imul(al9, bl8);
                mid = Math.imul(al9, bh8);
                mid = mid + Math.imul(ah9, bl8) | 0;
                hi = Math.imul(ah9, bh8);
                lo = lo + Math.imul(al8, bl9) | 0;
                mid = mid + Math.imul(al8, bh9) | 0;
                mid = mid + Math.imul(ah8, bl9) | 0;
                hi = hi + Math.imul(ah8, bh9) | 0;
                var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
                w17 &= 67108863;
                lo = Math.imul(al9, bl9);
                mid = Math.imul(al9, bh9);
                mid = mid + Math.imul(ah9, bl9) | 0;
                hi = Math.imul(ah9, bh9);
                var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
                c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
                w18 &= 67108863;
                o[0] = w0;
                o[1] = w1;
                o[2] = w2;
                o[3] = w3;
                o[4] = w4;
                o[5] = w5;
                o[6] = w6;
                o[7] = w7;
                o[8] = w8;
                o[9] = w9;
                o[10] = w10;
                o[11] = w11;
                o[12] = w12;
                o[13] = w13;
                o[14] = w14;
                o[15] = w15;
                o[16] = w16;
                o[17] = w17;
                o[18] = w18;
                if (c !== 0) {
                    o[19] = c;
                    out.length++;
                }
                return out;
            };
            if (!Math.imul) {
                comb10MulTo = smallMulTo;
            }
            function bigMulTo(self, num, out) {
                out.negative = num.negative ^ self.negative;
                out.length = self.length + num.length;
                var carry = 0;
                var hncarry = 0;
                for (var k = 0; k < out.length - 1; k++) {
                    var ncarry = hncarry;
                    hncarry = 0;
                    var rword = carry & 67108863;
                    var maxJ = Math.min(k, num.length - 1);
                    for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                        var i = k - j;
                        var a = self.words[i] | 0;
                        var b = num.words[j] | 0;
                        var r = a * b;
                        var lo = r & 67108863;
                        ncarry = ncarry + (r / 67108864 | 0) | 0;
                        lo = lo + rword | 0;
                        rword = lo & 67108863;
                        ncarry = ncarry + (lo >>> 26) | 0;
                        hncarry += ncarry >>> 26;
                        ncarry &= 67108863;
                    }
                    out.words[k] = rword;
                    carry = ncarry;
                    ncarry = hncarry;
                }
                if (carry !== 0) {
                    out.words[k] = carry;
                } else {
                    out.length--;
                }
                return out.strip();
            }
            function jumboMulTo(self, num, out) {
                var fftm = new FFTM;
                return fftm.mulp(self, num, out);
            }
            BN.prototype.mulTo = function mulTo(num, out) {
                var res;
                var len = this.length + num.length;
                if (this.length === 10 && num.length === 10) {
                    res = comb10MulTo(this, num, out);
                } else if (len < 63) {
                    res = smallMulTo(this, num, out);
                } else if (len < 1024) {
                    res = bigMulTo(this, num, out);
                } else {
                    res = jumboMulTo(this, num, out);
                }
                return res;
            };
            function FFTM(x, y) {
                this.x = x;
                this.y = y;
            }
            FFTM.prototype.makeRBT = function makeRBT(N) {
                var t = new Array(N);
                var l = BN.prototype._countBits(N) - 1;
                for (var i = 0; i < N; i++) {
                    t[i] = this.revBin(i, l, N);
                }
                return t;
            };
            FFTM.prototype.revBin = function revBin(x, l, N) {
                if (x === 0 || x === N - 1) return x;
                var rb = 0;
                for (var i = 0; i < l; i++) {
                    rb |= (x & 1) << l - i - 1;
                    x >>= 1;
                }
                return rb;
            };
            FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
                for (var i = 0; i < N; i++) {
                    rtws[i] = rws[rbt[i]];
                    itws[i] = iws[rbt[i]];
                }
            };
            FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
                this.permute(rbt, rws, iws, rtws, itws, N);
                for (var s = 1; s < N; s <<= 1) {
                    var l = s << 1;
                    var rtwdf = Math.cos(2 * Math.PI / l);
                    var itwdf = Math.sin(2 * Math.PI / l);
                    for (var p = 0; p < N; p += l) {
                        var rtwdf_ = rtwdf;
                        var itwdf_ = itwdf;
                        for (var j = 0; j < s; j++) {
                            var re = rtws[p + j];
                            var ie = itws[p + j];
                            var ro = rtws[p + j + s];
                            var io = itws[p + j + s];
                            var rx = rtwdf_ * ro - itwdf_ * io;
                            io = rtwdf_ * io + itwdf_ * ro;
                            ro = rx;
                            rtws[p + j] = re + ro;
                            itws[p + j] = ie + io;
                            rtws[p + j + s] = re - ro;
                            itws[p + j + s] = ie - io;
                            if (j !== l) {
                                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                                rtwdf_ = rx;
                            }
                        }
                    }
                }
            };
            FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
                var N = Math.max(m, n) | 1;
                var odd = N & 1;
                var i = 0;
                for (N = N / 2 | 0; N; N = N >>> 1) {
                    i++;
                }
                return 1 << i + 1 + odd;
            };
            FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
                if (N <= 1) return;
                for (var i = 0; i < N / 2; i++) {
                    var t = rws[i];
                    rws[i] = rws[N - i - 1];
                    rws[N - i - 1] = t;
                    t = iws[i];
                    iws[i] = -iws[N - i - 1];
                    iws[N - i - 1] = -t;
                }
            };
            FFTM.prototype.normalize13b = function normalize13b(ws, N) {
                var carry = 0;
                for (var i = 0; i < N / 2; i++) {
                    var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
                    ws[i] = w & 67108863;
                    if (w < 67108864) {
                        carry = 0;
                    } else {
                        carry = w / 67108864 | 0;
                    }
                }
                return ws;
            };
            FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
                var carry = 0;
                for (var i = 0; i < len; i++) {
                    carry = carry + (ws[i] | 0);
                    rws[2 * i] = carry & 8191;
                    carry = carry >>> 13;
                    rws[2 * i + 1] = carry & 8191;
                    carry = carry >>> 13;
                }
                for (i = 2 * len; i < N; ++i) {
                    rws[i] = 0;
                }
                assert(carry === 0);
                assert((carry & ~8191) === 0);
            };
            FFTM.prototype.stub = function stub(N) {
                var ph = new Array(N);
                for (var i = 0; i < N; i++) {
                    ph[i] = 0;
                }
                return ph;
            };
            FFTM.prototype.mulp = function mulp(x, y, out) {
                var N = 2 * this.guessLen13b(x.length, y.length);
                var rbt = this.makeRBT(N);
                var _ = this.stub(N);
                var rws = new Array(N);
                var rwst = new Array(N);
                var iwst = new Array(N);
                var nrws = new Array(N);
                var nrwst = new Array(N);
                var niwst = new Array(N);
                var rmws = out.words;
                rmws.length = N;
                this.convert13b(x.words, x.length, rws, N);
                this.convert13b(y.words, y.length, nrws, N);
                this.transform(rws, _, rwst, iwst, N, rbt);
                this.transform(nrws, _, nrwst, niwst, N, rbt);
                for (var i = 0; i < N; i++) {
                    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
                    rwst[i] = rx;
                }
                this.conjugate(rwst, iwst, N);
                this.transform(rwst, iwst, rmws, _, N, rbt);
                this.conjugate(rmws, _, N);
                this.normalize13b(rmws, N);
                out.negative = x.negative ^ y.negative;
                out.length = x.length + y.length;
                return out.strip();
            };
            BN.prototype.mul = function mul(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return this.mulTo(num, out);
            };
            BN.prototype.mulf = function mulf(num) {
                var out = new BN(null);
                out.words = new Array(this.length + num.length);
                return jumboMulTo(this, num, out);
            };
            BN.prototype.imul = function imul(num) {
                return this.clone().mulTo(num, this);
            };
            BN.prototype.imuln = function imuln(num) {
                assert(typeof num === "number");
                assert(num < 67108864);
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                    var w = (this.words[i] | 0) * num;
                    var lo = (w & 67108863) + (carry & 67108863);
                    carry >>= 26;
                    carry += w / 67108864 | 0;
                    carry += lo >>> 26;
                    this.words[i] = lo & 67108863;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.muln = function muln(num) {
                return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
                return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
                return this.imul(this.clone());
            };
            BN.prototype.pow = function pow(num) {
                var w = toBitArray(num);
                if (w.length === 0) return new BN(1);
                var res = this;
                for (var i = 0; i < w.length; i++, res = res.sqr()) {
                    if (w[i] !== 0) break;
                }
                if (++i < w.length) {
                    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                        if (w[i] === 0) continue;
                        res = res.mul(q);
                    }
                }
                return res;
            };
            BN.prototype.iushln = function iushln(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                var carryMask = 67108863 >>> 26 - r << 26 - r;
                var i;
                if (r !== 0) {
                    var carry = 0;
                    for (i = 0; i < this.length; i++) {
                        var newCarry = this.words[i] & carryMask;
                        var c = (this.words[i] | 0) - newCarry << r;
                        this.words[i] = c | carry;
                        carry = newCarry >>> 26 - r;
                    }
                    if (carry) {
                        this.words[i] = carry;
                        this.length++;
                    }
                }
                if (s !== 0) {
                    for (i = this.length - 1; i >= 0; i--) {
                        this.words[i + s] = this.words[i];
                    }
                    for (i = 0; i < s; i++) {
                        this.words[i] = 0;
                    }
                    this.length += s;
                }
                return this.strip();
            };
            BN.prototype.ishln = function ishln(bits) {
                assert(this.negative === 0);
                return this.iushln(bits);
            };
            BN.prototype.iushrn = function iushrn(bits, hint, extended) {
                assert(typeof bits === "number" && bits >= 0);
                var h;
                if (hint) {
                    h = (hint - hint % 26) / 26;
                } else {
                    h = 0;
                }
                var r = bits % 26;
                var s = Math.min((bits - r) / 26, this.length);
                var mask = 67108863 ^ 67108863 >>> r << r;
                var maskedWords = extended;
                h -= s;
                h = Math.max(0, h);
                if (maskedWords) {
                    for (var i = 0; i < s; i++) {
                        maskedWords.words[i] = this.words[i];
                    }
                    maskedWords.length = s;
                }
                if (s === 0) ; else if (this.length > s) {
                    this.length -= s;
                    for (i = 0; i < this.length; i++) {
                        this.words[i] = this.words[i + s];
                    }
                } else {
                    this.words[0] = 0;
                    this.length = 1;
                }
                var carry = 0;
                for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                    var word = this.words[i] | 0;
                    this.words[i] = carry << 26 - r | word >>> r;
                    carry = word & mask;
                }
                if (maskedWords && carry !== 0) {
                    maskedWords.words[maskedWords.length++] = carry;
                }
                if (this.length === 0) {
                    this.words[0] = 0;
                    this.length = 1;
                }
                return this.strip();
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                assert(this.negative === 0);
                return this.iushrn(bits, hint, extended);
            };
            BN.prototype.shln = function shln(bits) {
                return this.clone().ishln(bits);
            };
            BN.prototype.ushln = function ushln(bits) {
                return this.clone().iushln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
                return this.clone().ishrn(bits);
            };
            BN.prototype.ushrn = function ushrn(bits) {
                return this.clone().iushrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
                assert(typeof bit === "number" && bit >= 0);
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) return false;
                var w = this.words[s];
                return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
                assert(typeof bits === "number" && bits >= 0);
                var r = bits % 26;
                var s = (bits - r) / 26;
                assert(this.negative === 0, "imaskn works only with positive numbers");
                if (this.length <= s) {
                    return this;
                }
                if (r !== 0) {
                    s++;
                }
                this.length = Math.min(s, this.length);
                if (r !== 0) {
                    var mask = 67108863 ^ 67108863 >>> r << r;
                    this.words[this.length - 1] &= mask;
                }
                return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
                return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
                assert(typeof num === "number");
                assert(num < 67108864);
                if (num < 0) return this.isubn(-num);
                if (this.negative !== 0) {
                    if (this.length === 1 && (this.words[0] | 0) < num) {
                        this.words[0] = num - (this.words[0] | 0);
                        this.negative = 0;
                        return this;
                    }
                    this.negative = 0;
                    this.isubn(num);
                    this.negative = 1;
                    return this;
                }
                return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
                this.words[0] += num;
                for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
                    this.words[i] -= 67108864;
                    if (i === this.length - 1) {
                        this.words[i + 1] = 1;
                    } else {
                        this.words[i + 1]++;
                    }
                }
                this.length = Math.max(this.length, i + 1);
                return this;
            };
            BN.prototype.isubn = function isubn(num) {
                assert(typeof num === "number");
                assert(num < 67108864);
                if (num < 0) return this.iaddn(-num);
                if (this.negative !== 0) {
                    this.negative = 0;
                    this.iaddn(num);
                    this.negative = 1;
                    return this;
                }
                this.words[0] -= num;
                if (this.length === 1 && this.words[0] < 0) {
                    this.words[0] = -this.words[0];
                    this.negative = 1;
                } else {
                    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                        this.words[i] += 67108864;
                        this.words[i + 1] -= 1;
                    }
                }
                return this.strip();
            };
            BN.prototype.addn = function addn(num) {
                return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
                return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
                this.negative = 0;
                return this;
            };
            BN.prototype.abs = function abs() {
                return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                var len = num.length + shift;
                var i;
                this._expand(len);
                var w;
                var carry = 0;
                for (i = 0; i < num.length; i++) {
                    w = (this.words[i + shift] | 0) + carry;
                    var right = (num.words[i] | 0) * mul;
                    w -= right & 67108863;
                    carry = (w >> 26) - (right / 67108864 | 0);
                    this.words[i + shift] = w & 67108863;
                }
                for (;i < this.length - shift; i++) {
                    w = (this.words[i + shift] | 0) + carry;
                    carry = w >> 26;
                    this.words[i + shift] = w & 67108863;
                }
                if (carry === 0) return this.strip();
                assert(carry === -1);
                carry = 0;
                for (i = 0; i < this.length; i++) {
                    w = -(this.words[i] | 0) + carry;
                    carry = w >> 26;
                    this.words[i] = w & 67108863;
                }
                this.negative = 1;
                return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
                var shift = this.length - num.length;
                var a = this.clone();
                var b = num;
                var bhi = b.words[b.length - 1] | 0;
                var bhiBits = this._countBits(bhi);
                shift = 26 - bhiBits;
                if (shift !== 0) {
                    b = b.ushln(shift);
                    a.iushln(shift);
                    bhi = b.words[b.length - 1] | 0;
                }
                var m = a.length - b.length;
                var q;
                if (mode !== "mod") {
                    q = new BN(null);
                    q.length = m + 1;
                    q.words = new Array(q.length);
                    for (var i = 0; i < q.length; i++) {
                        q.words[i] = 0;
                    }
                }
                var diff = a.clone()._ishlnsubmul(b, 1, m);
                if (diff.negative === 0) {
                    a = diff;
                    if (q) {
                        q.words[m] = 1;
                    }
                }
                for (var j = m - 1; j >= 0; j--) {
                    var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
                    qj = Math.min(qj / bhi | 0, 67108863);
                    a._ishlnsubmul(b, qj, j);
                    while (a.negative !== 0) {
                        qj--;
                        a.negative = 0;
                        a._ishlnsubmul(b, 1, j);
                        if (!a.isZero()) {
                            a.negative ^= 1;
                        }
                    }
                    if (q) {
                        q.words[j] = qj;
                    }
                }
                if (q) {
                    q.strip();
                }
                a.strip();
                if (mode !== "div" && shift !== 0) {
                    a.iushrn(shift);
                }
                return {
                    div: q || null,
                    mod: a
                };
            };
            BN.prototype.divmod = function divmod(num, mode, positive) {
                assert(!num.isZero());
                if (this.isZero()) {
                    return {
                        div: new BN(0),
                        mod: new BN(0)
                    };
                }
                var div, mod, res;
                if (this.negative !== 0 && num.negative === 0) {
                    res = this.neg().divmod(num, mode);
                    if (mode !== "mod") {
                        div = res.div.neg();
                    }
                    if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                            mod.iadd(num);
                        }
                    }
                    return {
                        div: div,
                        mod: mod
                    };
                }
                if (this.negative === 0 && num.negative !== 0) {
                    res = this.divmod(num.neg(), mode);
                    if (mode !== "mod") {
                        div = res.div.neg();
                    }
                    return {
                        div: div,
                        mod: res.mod
                    };
                }
                if ((this.negative & num.negative) !== 0) {
                    res = this.neg().divmod(num.neg(), mode);
                    if (mode !== "div") {
                        mod = res.mod.neg();
                        if (positive && mod.negative !== 0) {
                            mod.isub(num);
                        }
                    }
                    return {
                        div: res.div,
                        mod: mod
                    };
                }
                if (num.length > this.length || this.cmp(num) < 0) {
                    return {
                        div: new BN(0),
                        mod: this
                    };
                }
                if (num.length === 1) {
                    if (mode === "div") {
                        return {
                            div: this.divn(num.words[0]),
                            mod: null
                        };
                    }
                    if (mode === "mod") {
                        return {
                            div: null,
                            mod: new BN(this.modn(num.words[0]))
                        };
                    }
                    return {
                        div: this.divn(num.words[0]),
                        mod: new BN(this.modn(num.words[0]))
                    };
                }
                return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
                return this.divmod(num, "div", false).div;
            };
            BN.prototype.mod = function mod(num) {
                return this.divmod(num, "mod", false).mod;
            };
            BN.prototype.umod = function umod(num) {
                return this.divmod(num, "mod", true).mod;
            };
            BN.prototype.divRound = function divRound(num) {
                var dm = this.divmod(num);
                if (dm.mod.isZero()) return dm.div;
                var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
                var half = num.ushrn(1);
                var r2 = num.andln(1);
                var cmp = mod.cmp(half);
                if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
                return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
                assert(num <= 67108863);
                var p = (1 << 26) % num;
                var acc = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    acc = (p * acc + (this.words[i] | 0)) % num;
                }
                return acc;
            };
            BN.prototype.idivn = function idivn(num) {
                assert(num <= 67108863);
                var carry = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var w = (this.words[i] | 0) + carry * 67108864;
                    this.words[i] = w / num | 0;
                    carry = w % num;
                }
                return this.strip();
            };
            BN.prototype.divn = function divn(num) {
                return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
                assert(p.negative === 0);
                assert(!p.isZero());
                var x = this;
                var y = p.clone();
                if (x.negative !== 0) {
                    x = x.umod(p);
                } else {
                    x = x.clone();
                }
                var A = new BN(1);
                var B = new BN(0);
                var C = new BN(0);
                var D = new BN(1);
                var g = 0;
                while (x.isEven() && y.isEven()) {
                    x.iushrn(1);
                    y.iushrn(1);
                    ++g;
                }
                var yp = y.clone();
                var xp = x.clone();
                while (!x.isZero()) {
                    for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                    if (i > 0) {
                        x.iushrn(i);
                        while (i-- > 0) {
                            if (A.isOdd() || B.isOdd()) {
                                A.iadd(yp);
                                B.isub(xp);
                            }
                            A.iushrn(1);
                            B.iushrn(1);
                        }
                    }
                    for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                    if (j > 0) {
                        y.iushrn(j);
                        while (j-- > 0) {
                            if (C.isOdd() || D.isOdd()) {
                                C.iadd(yp);
                                D.isub(xp);
                            }
                            C.iushrn(1);
                            D.iushrn(1);
                        }
                    }
                    if (x.cmp(y) >= 0) {
                        x.isub(y);
                        A.isub(C);
                        B.isub(D);
                    } else {
                        y.isub(x);
                        C.isub(A);
                        D.isub(B);
                    }
                }
                return {
                    a: C,
                    b: D,
                    gcd: y.iushln(g)
                };
            };
            BN.prototype._invmp = function _invmp(p) {
                assert(p.negative === 0);
                assert(!p.isZero());
                var a = this;
                var b = p.clone();
                if (a.negative !== 0) {
                    a = a.umod(p);
                } else {
                    a = a.clone();
                }
                var x1 = new BN(1);
                var x2 = new BN(0);
                var delta = b.clone();
                while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                    for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
                    if (i > 0) {
                        a.iushrn(i);
                        while (i-- > 0) {
                            if (x1.isOdd()) {
                                x1.iadd(delta);
                            }
                            x1.iushrn(1);
                        }
                    }
                    for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
                    if (j > 0) {
                        b.iushrn(j);
                        while (j-- > 0) {
                            if (x2.isOdd()) {
                                x2.iadd(delta);
                            }
                            x2.iushrn(1);
                        }
                    }
                    if (a.cmp(b) >= 0) {
                        a.isub(b);
                        x1.isub(x2);
                    } else {
                        b.isub(a);
                        x2.isub(x1);
                    }
                }
                var res;
                if (a.cmpn(1) === 0) {
                    res = x1;
                } else {
                    res = x2;
                }
                if (res.cmpn(0) < 0) {
                    res.iadd(p);
                }
                return res;
            };
            BN.prototype.gcd = function gcd(num) {
                if (this.isZero()) return num.abs();
                if (num.isZero()) return this.abs();
                var a = this.clone();
                var b = num.clone();
                a.negative = 0;
                b.negative = 0;
                for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                    a.iushrn(1);
                    b.iushrn(1);
                }
                do {
                    while (a.isEven()) {
                        a.iushrn(1);
                    }
                    while (b.isEven()) {
                        b.iushrn(1);
                    }
                    var r = a.cmp(b);
                    if (r < 0) {
                        var t = a;
                        a = b;
                        b = t;
                    } else if (r === 0 || b.cmpn(1) === 0) {
                        break;
                    }
                    a.isub(b);
                } while (true);
                return b.iushln(shift);
            };
            BN.prototype.invm = function invm(num) {
                return this.egcd(num).a.umod(num);
            };
            BN.prototype.isEven = function isEven() {
                return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
                return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
                return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
                assert(typeof bit === "number");
                var r = bit % 26;
                var s = (bit - r) / 26;
                var q = 1 << r;
                if (this.length <= s) {
                    this._expand(s + 1);
                    this.words[s] |= q;
                    return this;
                }
                var carry = q;
                for (var i = s; carry !== 0 && i < this.length; i++) {
                    var w = this.words[i] | 0;
                    w += carry;
                    carry = w >>> 26;
                    w &= 67108863;
                    this.words[i] = w;
                }
                if (carry !== 0) {
                    this.words[i] = carry;
                    this.length++;
                }
                return this;
            };
            BN.prototype.isZero = function isZero() {
                return this.length === 1 && this.words[0] === 0;
            };
            BN.prototype.cmpn = function cmpn(num) {
                var negative = num < 0;
                if (this.negative !== 0 && !negative) return -1;
                if (this.negative === 0 && negative) return 1;
                this.strip();
                var res;
                if (this.length > 1) {
                    res = 1;
                } else {
                    if (negative) {
                        num = -num;
                    }
                    assert(num <= 67108863, "Number is too big");
                    var w = this.words[0] | 0;
                    res = w === num ? 0 : w < num ? -1 : 1;
                }
                if (this.negative !== 0) return -res | 0;
                return res;
            };
            BN.prototype.cmp = function cmp(num) {
                if (this.negative !== 0 && num.negative === 0) return -1;
                if (this.negative === 0 && num.negative !== 0) return 1;
                var res = this.ucmp(num);
                if (this.negative !== 0) return -res | 0;
                return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
                if (this.length > num.length) return 1;
                if (this.length < num.length) return -1;
                var res = 0;
                for (var i = this.length - 1; i >= 0; i--) {
                    var a = this.words[i] | 0;
                    var b = num.words[i] | 0;
                    if (a === b) continue;
                    if (a < b) {
                        res = -1;
                    } else if (a > b) {
                        res = 1;
                    }
                    break;
                }
                return res;
            };
            BN.prototype.gtn = function gtn(num) {
                return this.cmpn(num) === 1;
            };
            BN.prototype.gt = function gt(num) {
                return this.cmp(num) === 1;
            };
            BN.prototype.gten = function gten(num) {
                return this.cmpn(num) >= 0;
            };
            BN.prototype.gte = function gte(num) {
                return this.cmp(num) >= 0;
            };
            BN.prototype.ltn = function ltn(num) {
                return this.cmpn(num) === -1;
            };
            BN.prototype.lt = function lt(num) {
                return this.cmp(num) === -1;
            };
            BN.prototype.lten = function lten(num) {
                return this.cmpn(num) <= 0;
            };
            BN.prototype.lte = function lte(num) {
                return this.cmp(num) <= 0;
            };
            BN.prototype.eqn = function eqn(num) {
                return this.cmpn(num) === 0;
            };
            BN.prototype.eq = function eq(num) {
                return this.cmp(num) === 0;
            };
            BN.red = function red(num) {
                return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                assert(this.negative === 0, "red works only with positives");
                return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
                assert(this.red, "fromRed works only with numbers in reduction context");
                return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
                this.red = ctx;
                return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
                assert(!this.red, "Already a number in reduction context");
                return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
                assert(this.red, "redAdd works only with red numbers");
                return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
                assert(this.red, "redIAdd works only with red numbers");
                return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
                assert(this.red, "redSub works only with red numbers");
                return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
                assert(this.red, "redISub works only with red numbers");
                return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
                assert(this.red, "redShl works only with red numbers");
                return this.red.shl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
                assert(this.red, "redMul works only with red numbers");
                this.red._verify2(this, num);
                return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
                assert(this.red, "redSqr works only with red numbers");
                this.red._verify1(this);
                return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
                assert(this.red, "redISqr works only with red numbers");
                this.red._verify1(this);
                return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
                assert(this.red, "redSqrt works only with red numbers");
                this.red._verify1(this);
                return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
                assert(this.red, "redInvm works only with red numbers");
                this.red._verify1(this);
                return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
                assert(this.red, "redNeg works only with red numbers");
                this.red._verify1(this);
                return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
                assert(this.red && !num.red, "redPow(normalNum)");
                this.red._verify1(this);
                return this.red.pow(this, num);
            };
            var primes = {
                k256: null,
                p224: null,
                p192: null,
                p25519: null
            };
            function MPrime(name, p) {
                this.name = name;
                this.p = new BN(p, 16);
                this.n = this.p.bitLength();
                this.k = new BN(1).iushln(this.n).isub(this.p);
                this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
                var tmp = new BN(null);
                tmp.words = new Array(Math.ceil(this.n / 13));
                return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
                var r = num;
                var rlen;
                do {
                    this.split(r, this.tmp);
                    r = this.imulK(r);
                    r = r.iadd(this.tmp);
                    rlen = r.bitLength();
                } while (rlen > this.n);
                var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                if (cmp === 0) {
                    r.words[0] = 0;
                    r.length = 1;
                } else if (cmp > 0) {
                    r.isub(this.p);
                } else {
                    if (r.strip !== undefined) {
                        r.strip();
                    } else {
                        r._strip();
                    }
                }
                return r;
            };
            MPrime.prototype.split = function split(input, out) {
                input.iushrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
                return num.imul(this.k);
            };
            function K256() {
                MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
                var mask = 4194303;
                var outLen = Math.min(input.length, 9);
                for (var i = 0; i < outLen; i++) {
                    output.words[i] = input.words[i];
                }
                output.length = outLen;
                if (input.length <= 9) {
                    input.words[0] = 0;
                    input.length = 1;
                    return;
                }
                var prev = input.words[9];
                output.words[output.length++] = prev & mask;
                for (i = 10; i < input.length; i++) {
                    var next = input.words[i] | 0;
                    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
                    prev = next;
                }
                prev >>>= 22;
                input.words[i - 10] = prev;
                if (prev === 0 && input.length > 10) {
                    input.length -= 10;
                } else {
                    input.length -= 9;
                }
            };
            K256.prototype.imulK = function imulK(num) {
                num.words[num.length] = 0;
                num.words[num.length + 1] = 0;
                num.length += 2;
                var lo = 0;
                for (var i = 0; i < num.length; i++) {
                    var w = num.words[i] | 0;
                    lo += w * 977;
                    num.words[i] = lo & 67108863;
                    lo = w * 64 + (lo / 67108864 | 0);
                }
                if (num.words[num.length - 1] === 0) {
                    num.length--;
                    if (num.words[num.length - 1] === 0) {
                        num.length--;
                    }
                }
                return num;
            };
            function P224() {
                MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
            }
            inherits(P224, MPrime);
            function P192() {
                MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
            }
            inherits(P192, MPrime);
            function P25519() {
                MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
                var carry = 0;
                for (var i = 0; i < num.length; i++) {
                    var hi = (num.words[i] | 0) * 19 + carry;
                    var lo = hi & 67108863;
                    hi >>>= 26;
                    num.words[i] = lo;
                    carry = hi;
                }
                if (carry !== 0) {
                    num.words[num.length++] = carry;
                }
                return num;
            };
            BN._prime = function prime(name) {
                if (primes[name]) return primes[name];
                var prime;
                if (name === "k256") {
                    prime = new K256;
                } else if (name === "p224") {
                    prime = new P224;
                } else if (name === "p192") {
                    prime = new P192;
                } else if (name === "p25519") {
                    prime = new P25519;
                } else {
                    throw new Error("Unknown prime " + name);
                }
                primes[name] = prime;
                return prime;
            };
            function Red(m) {
                if (typeof m === "string") {
                    var prime = BN._prime(m);
                    this.m = prime.p;
                    this.prime = prime;
                } else {
                    assert(m.gtn(1), "modulus must be greater than 1");
                    this.m = m;
                    this.prime = null;
                }
            }
            Red.prototype._verify1 = function _verify1(a) {
                assert(a.negative === 0, "red works only with positives");
                assert(a.red, "red works only with red numbers");
            };
            Red.prototype._verify2 = function _verify2(a, b) {
                assert((a.negative | b.negative) === 0, "red works only with positives");
                assert(a.red && a.red === b.red, "red works only with red numbers");
            };
            Red.prototype.imod = function imod(a) {
                if (this.prime) return this.prime.ireduce(a)._forceRed(this);
                return a.umod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
                if (a.isZero()) {
                    return a.clone();
                }
                return this.m.sub(a)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
                this._verify2(a, b);
                var res = a.add(b);
                if (res.cmp(this.m) >= 0) {
                    res.isub(this.m);
                }
                return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
                this._verify2(a, b);
                var res = a.iadd(b);
                if (res.cmp(this.m) >= 0) {
                    res.isub(this.m);
                }
                return res;
            };
            Red.prototype.sub = function sub(a, b) {
                this._verify2(a, b);
                var res = a.sub(b);
                if (res.cmpn(0) < 0) {
                    res.iadd(this.m);
                }
                return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
                this._verify2(a, b);
                var res = a.isub(b);
                if (res.cmpn(0) < 0) {
                    res.iadd(this.m);
                }
                return res;
            };
            Red.prototype.shl = function shl(a, num) {
                this._verify1(a);
                return this.imod(a.ushln(num));
            };
            Red.prototype.imul = function imul(a, b) {
                this._verify2(a, b);
                return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
                this._verify2(a, b);
                return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
                return this.imul(a, a.clone());
            };
            Red.prototype.sqr = function sqr(a) {
                return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
                if (a.isZero()) return a.clone();
                var mod3 = this.m.andln(3);
                assert(mod3 % 2 === 1);
                if (mod3 === 3) {
                    var pow = this.m.add(new BN(1)).iushrn(2);
                    return this.pow(a, pow);
                }
                var q = this.m.subn(1);
                var s = 0;
                while (!q.isZero() && q.andln(1) === 0) {
                    s++;
                    q.iushrn(1);
                }
                assert(!q.isZero());
                var one = new BN(1).toRed(this);
                var nOne = one.redNeg();
                var lpow = this.m.subn(1).iushrn(1);
                var z = this.m.bitLength();
                z = new BN(2 * z * z).toRed(this);
                while (this.pow(z, lpow).cmp(nOne) !== 0) {
                    z.redIAdd(nOne);
                }
                var c = this.pow(z, q);
                var r = this.pow(a, q.addn(1).iushrn(1));
                var t = this.pow(a, q);
                var m = s;
                while (t.cmp(one) !== 0) {
                    var tmp = t;
                    for (var i = 0; tmp.cmp(one) !== 0; i++) {
                        tmp = tmp.redSqr();
                    }
                    assert(i < m);
                    var b = this.pow(c, new BN(1).iushln(m - i - 1));
                    r = r.redMul(b);
                    c = b.redSqr();
                    t = t.redMul(c);
                    m = i;
                }
                return r;
            };
            Red.prototype.invm = function invm(a) {
                var inv = a._invmp(this.m);
                if (inv.negative !== 0) {
                    inv.negative = 0;
                    return this.imod(inv).redNeg();
                } else {
                    return this.imod(inv);
                }
            };
            Red.prototype.pow = function pow(a, num) {
                if (num.isZero()) return new BN(1).toRed(this);
                if (num.cmpn(1) === 0) return a.clone();
                var windowSize = 4;
                var wnd = new Array(1 << windowSize);
                wnd[0] = new BN(1).toRed(this);
                wnd[1] = a;
                for (var i = 2; i < wnd.length; i++) {
                    wnd[i] = this.mul(wnd[i - 1], a);
                }
                var res = wnd[0];
                var current = 0;
                var currentLen = 0;
                var start = num.bitLength() % 26;
                if (start === 0) {
                    start = 26;
                }
                for (i = num.length - 1; i >= 0; i--) {
                    var word = num.words[i];
                    for (var j = start - 1; j >= 0; j--) {
                        var bit = word >> j & 1;
                        if (res !== wnd[0]) {
                            res = this.sqr(res);
                        }
                        if (bit === 0 && current === 0) {
                            currentLen = 0;
                            continue;
                        }
                        current <<= 1;
                        current |= bit;
                        currentLen++;
                        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                        res = this.mul(res, wnd[current]);
                        currentLen = 0;
                        current = 0;
                    }
                    start = 26;
                }
                return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
                var r = num.umod(this.m);
                return r === num ? r.clone() : r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
                var res = num.clone();
                res.red = null;
                return res;
            };
            BN.mont = function mont(num) {
                return new Mont(num);
            };
            function Mont(m) {
                Red.call(this, m);
                this.shift = this.m.bitLength();
                if (this.shift % 26 !== 0) {
                    this.shift += 26 - this.shift % 26;
                }
                this.r = new BN(1).iushln(this.shift);
                this.r2 = this.imod(this.r.sqr());
                this.rinv = this.r._invmp(this.m);
                this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                this.minv = this.minv.umod(this.r);
                this.minv = this.r.sub(this.minv);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
                return this.imod(num.ushln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
                var r = this.imod(num.mul(this.rinv));
                r.red = null;
                return r;
            };
            Mont.prototype.imul = function imul(a, b) {
                if (a.isZero() || b.isZero()) {
                    a.words[0] = 0;
                    a.length = 1;
                    return a;
                }
                var t = a.imul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) {
                    res = u.isub(this.m);
                } else if (u.cmpn(0) < 0) {
                    res = u.iadd(this.m);
                }
                return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
                if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
                var t = a.mul(b);
                var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                var u = t.isub(c).iushrn(this.shift);
                var res = u;
                if (u.cmp(this.m) >= 0) {
                    res = u.isub(this.m);
                } else if (u.cmpn(0) < 0) {
                    res = u.iadd(this.m);
                }
                return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
                var res = this.imod(a._invmp(this.m).mul(this.r2));
                return res._forceRed(this);
            };
        })(module, commonjsGlobal);
    })(bn);
    var BN$8 = bn.exports;
    var elliptic = {};
    var name = "elliptic";
    var version = "6.5.4";
    var description = "EC cryptography";
    var main = "lib/elliptic.js";
    var files = [ "lib" ];
    var scripts = {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
    };
    var repository = {
        type: "git",
        url: "git@github.com:indutny/elliptic"
    };
    var keywords = [ "EC", "Elliptic", "curve", "Cryptography" ];
    var author = "Fedor Indutny <fedor@indutny.com>";
    var license = "MIT";
    var bugs = {
        url: "https://github.com/indutny/elliptic/issues"
    };
    var homepage = "https://github.com/indutny/elliptic";
    var devDependencies = {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
    };
    var dependencies = {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
    };
    var require$0 = {
        name: name,
        version: version,
        description: description,
        main: main,
        files: files,
        scripts: scripts,
        repository: repository,
        keywords: keywords,
        author: author,
        license: license,
        bugs: bugs,
        homepage: homepage,
        devDependencies: devDependencies,
        dependencies: dependencies
    };
    var utils$f = {};
    var utils$e = {};
    (function(exports) {
        var utils = exports;
        function toArray(msg, enc) {
            if (Array.isArray(msg)) return msg.slice();
            if (!msg) return [];
            var res = [];
            if (typeof msg !== "string") {
                for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
                return res;
            }
            if (enc === "hex") {
                msg = msg.replace(/[^a-z0-9]+/gi, "");
                if (msg.length % 2 !== 0) msg = "0" + msg;
                for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
            } else {
                for (var i = 0; i < msg.length; i++) {
                    var c = msg.charCodeAt(i);
                    var hi = c >> 8;
                    var lo = c & 255;
                    if (hi) res.push(hi, lo); else res.push(lo);
                }
            }
            return res;
        }
        utils.toArray = toArray;
        function zero2(word) {
            if (word.length === 1) return "0" + word; else return word;
        }
        utils.zero2 = zero2;
        function toHex(msg) {
            var res = "";
            for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
            return res;
        }
        utils.toHex = toHex;
        utils.encode = function encode(arr, enc) {
            if (enc === "hex") return toHex(arr); else return arr;
        };
    })(utils$e);
    (function(exports) {
        var utils = exports;
        var BN = bn.exports;
        var minAssert = minimalisticAssert;
        var minUtils = utils$e;
        utils.assert = minAssert;
        utils.toArray = minUtils.toArray;
        utils.zero2 = minUtils.zero2;
        utils.toHex = minUtils.toHex;
        utils.encode = minUtils.encode;
        function getNAF(num, w, bits) {
            var naf = new Array(Math.max(num.bitLength(), bits) + 1);
            naf.fill(0);
            var ws = 1 << w + 1;
            var k = num.clone();
            for (var i = 0; i < naf.length; i++) {
                var z;
                var mod = k.andln(ws - 1);
                if (k.isOdd()) {
                    if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod; else z = mod;
                    k.isubn(z);
                } else {
                    z = 0;
                }
                naf[i] = z;
                k.iushrn(1);
            }
            return naf;
        }
        utils.getNAF = getNAF;
        function getJSF(k1, k2) {
            var jsf = [ [], [] ];
            k1 = k1.clone();
            k2 = k2.clone();
            var d1 = 0;
            var d2 = 0;
            var m8;
            while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
                var m14 = k1.andln(3) + d1 & 3;
                var m24 = k2.andln(3) + d2 & 3;
                if (m14 === 3) m14 = -1;
                if (m24 === 3) m24 = -1;
                var u1;
                if ((m14 & 1) === 0) {
                    u1 = 0;
                } else {
                    m8 = k1.andln(7) + d1 & 7;
                    if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14; else u1 = m14;
                }
                jsf[0].push(u1);
                var u2;
                if ((m24 & 1) === 0) {
                    u2 = 0;
                } else {
                    m8 = k2.andln(7) + d2 & 7;
                    if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24; else u2 = m24;
                }
                jsf[1].push(u2);
                if (2 * d1 === u1 + 1) d1 = 1 - d1;
                if (2 * d2 === u2 + 1) d2 = 1 - d2;
                k1.iushrn(1);
                k2.iushrn(1);
            }
            return jsf;
        }
        utils.getJSF = getJSF;
        function cachedProperty(obj, name, computer) {
            var key = "_" + name;
            obj.prototype[name] = function cachedProperty() {
                return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
            };
        }
        utils.cachedProperty = cachedProperty;
        function parseBytes(bytes) {
            return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
        }
        utils.parseBytes = parseBytes;
        function intFromLE(bytes) {
            return new BN(bytes, "hex", "le");
        }
        utils.intFromLE = intFromLE;
    })(utils$f);
    var curve = {};
    var BN$7 = bn.exports;
    var utils$d = utils$f;
    var getNAF = utils$d.getNAF;
    var getJSF = utils$d.getJSF;
    var assert$9 = utils$d.assert;
    function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN$7(conf.p, 16);
        this.red = conf.prime ? BN$7.red(conf.prime) : BN$7.mont(this.p);
        this.zero = new BN$7(0).toRed(this.red);
        this.one = new BN$7(1).toRed(this.red);
        this.two = new BN$7(2).toRed(this.red);
        this.n = conf.n && new BN$7(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
            this.redN = null;
        } else {
            this._maxwellTrick = true;
            this.redN = this.n.toRed(this.red);
        }
    }
    var base$1 = BaseCurve;
    BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert$9(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
            nafW = 0;
            for (var l = j + doubles.step - 1; l >= j; l--) nafW = (nafW << 1) + naf[l];
            repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
            for (j = 0; j < repr.length; j++) {
                nafW = repr[j];
                if (nafW === i) b = b.mixedAdd(doubles.points[j]); else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
            }
            a = a.add(b);
        }
        return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
            for (var l = 0; i >= 0 && naf[i] === 0; i--) l++;
            if (i >= 0) l++;
            acc = acc.dblp(l);
            if (i < 0) break;
            var z = naf[i];
            assert$9(z !== 0);
            if (p.type === "affine") {
                if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]); else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
            } else {
                if (z > 0) acc = acc.add(wnd[z - 1 >> 1]); else acc = acc.add(wnd[-z - 1 >> 1].neg());
            }
        }
        return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
            p = points[i];
            var nafPoints = p._getNAFPoints(defW);
            wndWidth[i] = nafPoints.wnd;
            wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
            var a = i - 1;
            var b = i;
            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
                naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
            }
            var comb = [ points[a], null, null, points[b] ];
            if (points[a].y.cmp(points[b].y) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
            } else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
            }
            var index = [ -3, -1, -5, -7, 0, 7, 5, 1, 3 ];
            var jsf = getJSF(coeffs[a], coeffs[b]);
            max = Math.max(jsf[0].length, max);
            naf[a] = new Array(max);
            naf[b] = new Array(max);
            for (j = 0; j < max; j++) {
                var ja = jsf[0][j] | 0;
                var jb = jsf[1][j] | 0;
                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
            }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
            var k = 0;
            while (i >= 0) {
                var zero = true;
                for (j = 0; j < len; j++) {
                    tmp[j] = naf[j][i] | 0;
                    if (tmp[j] !== 0) zero = false;
                }
                if (!zero) break;
                k++;
                i--;
            }
            if (i >= 0) k++;
            acc = acc.dblp(k);
            if (i < 0) break;
            for (j = 0; j < len; j++) {
                var z = tmp[j];
                if (z === 0) continue; else if (z > 0) p = wnd[j][z - 1 >> 1]; else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
                if (p.type === "affine") acc = acc.mixedAdd(p); else acc = acc.add(p);
            }
        }
        for (i = 0; i < len; i++) wnd[i] = null;
        if (jacobianResult) return acc; else return acc.toP();
    };
    function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils$d.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
            if (bytes[0] === 6) assert$9(bytes[bytes.length - 1] % 2 === 0); else if (bytes[0] === 7) assert$9(bytes[bytes.length - 1] % 2 === 1);
            var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
            return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
            return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact) return [ this.getY().isEven() ? 2 : 3 ].concat(x);
        return [ 4 ].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
        return utils$d.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed) return this;
        var precomputed = {
            doubles: null,
            naf: null,
            beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed) return false;
        var doubles = this.precomputed.doubles;
        if (!doubles) return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        var doubles = [ this ];
        var acc = this;
        for (var i = 0; i < power; i += step) {
            for (var j = 0; j < step; j++) acc = acc.dbl();
            doubles.push(acc);
        }
        return {
            step: step,
            points: doubles
        };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        var res = [ this ];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
        return {
            wnd: wnd,
            points: res
        };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
        return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++) r = r.dbl();
        return r;
    };
    var utils$c = utils$f;
    var BN$6 = bn.exports;
    var inherits$2 = inherits$4.exports;
    var Base$2 = base$1;
    var assert$8 = utils$c.assert;
    function ShortCurve(conf) {
        Base$2.call(this, "short", conf);
        this.a = new BN$6(conf.a, 16).toRed(this.red);
        this.b = new BN$6(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
    }
    inherits$2(ShortCurve, Base$2);
    var short = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
        var beta;
        var lambda;
        if (conf.beta) {
            beta = new BN$6(conf.beta, 16).toRed(this.red);
        } else {
            var betas = this._getEndoRoots(this.p);
            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
            beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
            lambda = new BN$6(conf.lambda, 16);
        } else {
            var lambdas = this._getEndoRoots(this.n);
            if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                lambda = lambdas[0];
            } else {
                lambda = lambdas[1];
                assert$8(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
            }
        }
        var basis;
        if (conf.basis) {
            basis = conf.basis.map((function(vec) {
                return {
                    a: new BN$6(vec.a, 16),
                    b: new BN$6(vec.b, 16)
                };
            }));
        } else {
            basis = this._getEndoBasis(lambda);
        }
        return {
            beta: beta,
            lambda: lambda,
            basis: basis
        };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN$6.mont(num);
        var tinv = new BN$6(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN$6(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [ l1, l2 ];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN$6(1);
        var y1 = new BN$6(0);
        var x2 = new BN$6(0);
        var y2 = new BN$6(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
            var q = v.div(u);
            r = v.sub(q.mul(u));
            x = x2.sub(q.mul(x1));
            var y = y2.sub(q.mul(y1));
            if (!a1 && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
            } else if (a1 && ++i === 2) {
                break;
            }
            prevR = r;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
            y2 = y1;
            y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
            a2 = a0;
            b2 = b0;
        }
        if (a1.negative) {
            a1 = a1.neg();
            b1 = b1.neg();
        }
        if (a2.negative) {
            a2 = a2.neg();
            b2 = b2.neg();
        }
        return [ {
            a: a1,
            b: b1
        }, {
            a: a2,
            b: b2
        } ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return {
            k1: k1,
            k2: k2
        };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN$6(x, 16);
        if (!x.red) x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
        return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
        if (point.inf) return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
            var split = this._endoSplit(coeffs[i]);
            var p = points[i];
            var beta = p._getBeta();
            if (split.k1.negative) {
                split.k1.ineg();
                p = p.neg(true);
            }
            if (split.k2.negative) {
                split.k2.ineg();
                beta = beta.neg(true);
            }
            npoints[i * 2] = p;
            npoints[i * 2 + 1] = beta;
            ncoeffs[i * 2] = split.k1;
            ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
            npoints[j] = null;
            ncoeffs[j] = null;
        }
        return res;
    };
    function Point$2(curve, x, y, isRed) {
        Base$2.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
            this.x = null;
            this.y = null;
            this.inf = true;
        } else {
            this.x = new BN$6(x, 16);
            this.y = new BN$6(y, 16);
            if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
            }
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            this.inf = false;
        }
    }
    inherits$2(Point$2, Base$2.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point$2(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point$2.fromJSON(this, obj, red);
    };
    Point$2.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo) return;
        var pre = this.precomputed;
        if (pre && pre.beta) return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
            var curve = this.curve;
            var endoMul = function(p) {
                return curve.point(p.x.redMul(curve.endo.beta), p.y);
            };
            pre.beta = beta;
            beta.precomputed = {
                beta: null,
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(endoMul)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(endoMul)
                }
            };
        }
        return beta;
    };
    Point$2.prototype.toJSON = function toJSON() {
        if (!this.precomputed) return [ this.x, this.y ];
        return [ this.x, this.y, this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        } ];
    };
    Point$2.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string") obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2]) return res;
        function obj2point(obj) {
            return curve.point(obj[0], obj[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
            beta: null,
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: [ res ].concat(pre.doubles.points.map(obj2point))
            },
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: [ res ].concat(pre.naf.points.map(obj2point))
            }
        };
        return res;
    };
    Point$2.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point$2.prototype.isInfinity = function isInfinity() {
        return this.inf;
    };
    Point$2.prototype.add = function add(p) {
        if (this.inf) return p;
        if (p.inf) return this;
        if (this.eq(p)) return this.dbl();
        if (this.neg().eq(p)) return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };
    Point$2.prototype.dbl = function dbl() {
        if (this.inf) return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
    };
    Point$2.prototype.getX = function getX() {
        return this.x.fromRed();
    };
    Point$2.prototype.getY = function getY() {
        return this.y.fromRed();
    };
    Point$2.prototype.mul = function mul(k) {
        k = new BN$6(k, 16);
        if (this.isInfinity()) return this; else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k); else if (this.curve.endo) return this.curve._endoWnafMulAdd([ this ], [ k ]); else return this.curve._wnafMul(this, k);
    };
    Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [ this, p2 ];
        var coeffs = [ k1, k2 ];
        if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs); else return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [ this, p2 ];
        var coeffs = [ k1, k2 ];
        if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true); else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point$2.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point$2.prototype.neg = function neg(_precompute) {
        if (this.inf) return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
            var pre = this.precomputed;
            var negate = function(p) {
                return p.neg();
            };
            res.precomputed = {
                naf: pre.naf && {
                    wnd: pre.naf.wnd,
                    points: pre.naf.points.map(negate)
                },
                doubles: pre.doubles && {
                    step: pre.doubles.step,
                    points: pre.doubles.points.map(negate)
                }
            };
        }
        return res;
    };
    Point$2.prototype.toJ = function toJ() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
    };
    function JPoint(curve, x, y, z) {
        Base$2.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
            this.x = this.curve.one;
            this.y = this.curve.one;
            this.z = new BN$6(0);
        } else {
            this.x = new BN$6(x, 16);
            this.y = new BN$6(y, 16);
            this.z = new BN$6(z, 16);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
    }
    inherits$2(JPoint, Base$2.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
        if (this.isInfinity()) return p;
        if (p.isInfinity()) return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null); else return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity()) return p.toJ();
        if (p.isInfinity()) return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
            if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null); else return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0) return this;
        if (this.isInfinity()) return this;
        if (!pow) return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
            var r = this;
            for (i = 0; i < pow; i++) r = r.dbl();
            return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
            var jx2 = jx.redSqr();
            var jyd2 = jyd.redSqr();
            var jyd4 = jyd2.redSqr();
            var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
            var t1 = jx.redMul(jyd2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);
            var dny = c.redMul(t2);
            dny = dny.redIAdd(dny).redISub(jyd4);
            var nz = jyd.redMul(jz);
            if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
            jx = nx;
            jz = nz;
            jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity()) return this;
        if (this.curve.zeroA) return this._zeroDbl(); else if (this.curve.threeA) return this._threeDbl(); else return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var yyyy = yy.redSqr();
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            var m = xx.redAdd(xx).redIAdd(xx);
            var t = m.redSqr().redISub(s).redISub(s);
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            nx = t;
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            nz = this.y.redAdd(this.y);
        } else {
            var a = this.x.redSqr();
            var b = this.y.redSqr();
            var c = b.redSqr();
            var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
            d = d.redIAdd(d);
            var e = a.redAdd(a).redIAdd(a);
            var f = e.redSqr();
            var c8 = c.redIAdd(c);
            c8 = c8.redIAdd(c8);
            c8 = c8.redIAdd(c8);
            nx = f.redISub(d).redISub(d);
            ny = e.redMul(d.redISub(nx)).redISub(c8);
            nz = this.y.redMul(this.z);
            nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var yyyy = yy.redSqr();
            var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
            s = s.redIAdd(s);
            var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
            var t = m.redSqr().redISub(s).redISub(s);
            nx = t;
            var yyyy8 = yyyy.redIAdd(yyyy);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            yyyy8 = yyyy8.redIAdd(yyyy8);
            ny = m.redMul(s.redISub(t)).redISub(yyyy8);
            nz = this.y.redAdd(this.y);
        } else {
            var delta = this.z.redSqr();
            var gamma = this.y.redSqr();
            var beta = this.x.redMul(gamma);
            var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
            alpha = alpha.redAdd(alpha).redIAdd(alpha);
            var beta4 = beta.redIAdd(beta);
            beta4 = beta4.redIAdd(beta4);
            var beta8 = beta4.redAdd(beta4);
            nx = alpha.redSqr().redISub(beta8);
            nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
            var ggamma8 = gamma.redSqr();
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ggamma8 = ggamma8.redIAdd(ggamma8);
            ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN$6(k, kbase);
        return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine") return this.eq(p.toJ());
        if (this === p) return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0) return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (;;) {
            xc.iadd(this.curve.n);
            if (xc.cmp(this.curve.p) >= 0) return false;
            rx.redIAdd(t);
            if (this.x.cmp(rx) === 0) return true;
        }
    };
    JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
    };
    var BN$5 = bn.exports;
    var inherits$1 = inherits$4.exports;
    var Base$1 = base$1;
    var utils$b = utils$f;
    function MontCurve(conf) {
        Base$1.call(this, "mont", conf);
        this.a = new BN$5(conf.a, 16).toRed(this.red);
        this.b = new BN$5(conf.b, 16).toRed(this.red);
        this.i4 = new BN$5(4).toRed(this.red).redInvm();
        this.two = new BN$5(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits$1(MontCurve, Base$1);
    var mont = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
    };
    function Point$1(curve, x, z) {
        Base$1.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
            this.x = this.curve.one;
            this.z = this.curve.zero;
        } else {
            this.x = new BN$5(x, 16);
            this.z = new BN$5(z, 16);
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        }
    }
    inherits$1(Point$1, Base$1.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils$b.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
        return new Point$1(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point$1.fromJSON(this, obj);
    };
    Point$1.prototype.precompute = function precompute() {};
    Point$1.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point$1.fromJSON = function fromJSON(curve, obj) {
        return new Point$1(curve, obj[0], obj[1] || curve.one);
    };
    Point$1.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point$1.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
    };
    Point$1.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
    };
    Point$1.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point$1.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
    };
    Point$1.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
            if (bits[i] === 0) {
                a = a.diffAdd(b, c);
                b = b.dbl();
            } else {
                b = a.diffAdd(b, c);
                a = a.dbl();
            }
        }
        return b;
    };
    Point$1.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point$1.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
    };
    Point$1.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
    };
    Point$1.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
    };
    Point$1.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };
    var utils$a = utils$f;
    var BN$4 = bn.exports;
    var inherits = inherits$4.exports;
    var Base = base$1;
    var assert$7 = utils$a.assert;
    function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN$4(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN$4(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN$4(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert$7(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    var edwards = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA) return num.redNeg(); else return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC) return num; else return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN$4(x, 16);
        if (!x.red) x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
        return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN$4(y, 16);
        if (!y.red) y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
            if (odd) throw new Error("invalid point"); else return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd) x = x.redNeg();
        return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity()) return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
            this.x = this.curve.zero;
            this.y = this.curve.one;
            this.z = this.curve.one;
            this.t = this.curve.zero;
            this.zOne = true;
        } else {
            this.x = new BN$4(x, 16);
            this.y = new BN$4(y, 16);
            this.z = z ? new BN$4(z, 16) : this.curve.one;
            this.t = t && new BN$4(t, 16);
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
            this.zOne = this.z === this.curve.one;
            if (this.curve.extended && !this.t) {
                this.t = this.x.redMul(this.y);
                if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
            }
        }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
        if (this.isInfinity()) return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
            e = this.curve._mulA(c);
            var f = e.redAdd(d);
            if (this.zOne) {
                nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                ny = f.redMul(e.redSub(d));
                nz = f.redSqr().redSub(f).redSub(f);
            } else {
                h = this.z.redSqr();
                j = f.redSub(h).redISub(h);
                nx = b.redSub(c).redISub(d).redMul(j);
                ny = f.redMul(e.redSub(d));
                nz = f.redMul(j);
            }
        } else {
            e = c.redAdd(d);
            h = this.curve._mulC(this.z).redSqr();
            j = e.redSub(h).redSub(h);
            nx = this.curve._mulC(b.redISub(e)).redMul(j);
            ny = this.curve._mulC(e).redMul(c.redISub(d));
            nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
        if (this.isInfinity()) return this;
        if (this.curve.extended) return this._extDbl(); else return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
            ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
            nz = f.redMul(g);
        } else {
            ny = a.redMul(g).redMul(d.redSub(c));
            nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
        if (this.isInfinity()) return p;
        if (p.isInfinity()) return this;
        if (this.curve.extended) return this._extAdd(p); else return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k); else return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
    };
    Point.prototype.normalize = function normalize() {
        if (this.zOne) return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t) this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
    };
    Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0) return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (;;) {
            xc.iadd(this.curve.n);
            if (xc.cmp(this.curve.p) >= 0) return false;
            rx.redIAdd(t);
            if (this.x.cmp(rx) === 0) return true;
        }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
    (function(exports) {
        var curve = exports;
        curve.base = base$1;
        curve.short = short;
        curve.mont = mont;
        curve.edwards = edwards;
    })(curve);
    var curves$3 = {};
    var secp256k1;
    var hasRequiredSecp256k1;
    function requireSecp256k1() {
        if (hasRequiredSecp256k1) return secp256k1;
        hasRequiredSecp256k1 = 1;
        secp256k1 = {
            doubles: {
                step: 4,
                points: [ [ "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821" ], [ "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf" ], [ "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695" ], [ "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9" ], [ "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36" ], [ "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f" ], [ "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999" ], [ "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09" ], [ "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d" ], [ "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088" ], [ "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d" ], [ "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8" ], [ "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a" ], [ "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453" ], [ "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160" ], [ "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0" ], [ "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6" ], [ "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589" ], [ "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17" ], [ "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda" ], [ "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd" ], [ "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2" ], [ "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6" ], [ "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f" ], [ "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01" ], [ "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3" ], [ "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f" ], [ "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7" ], [ "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78" ], [ "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1" ], [ "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150" ], [ "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82" ], [ "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc" ], [ "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b" ], [ "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51" ], [ "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45" ], [ "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120" ], [ "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84" ], [ "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d" ], [ "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d" ], [ "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8" ], [ "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8" ], [ "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac" ], [ "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f" ], [ "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962" ], [ "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907" ], [ "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec" ], [ "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d" ], [ "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414" ], [ "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd" ], [ "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0" ], [ "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811" ], [ "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1" ], [ "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c" ], [ "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73" ], [ "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd" ], [ "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405" ], [ "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589" ], [ "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e" ], [ "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27" ], [ "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1" ], [ "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482" ], [ "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945" ], [ "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573" ], [ "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82" ] ]
            },
            naf: {
                wnd: 7,
                points: [ [ "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672" ], [ "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6" ], [ "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da" ], [ "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37" ], [ "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b" ], [ "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81" ], [ "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58" ], [ "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77" ], [ "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a" ], [ "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c" ], [ "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67" ], [ "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402" ], [ "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55" ], [ "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482" ], [ "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82" ], [ "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396" ], [ "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49" ], [ "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf" ], [ "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a" ], [ "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7" ], [ "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933" ], [ "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a" ], [ "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6" ], [ "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37" ], [ "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e" ], [ "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6" ], [ "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476" ], [ "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40" ], [ "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61" ], [ "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683" ], [ "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5" ], [ "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b" ], [ "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417" ], [ "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868" ], [ "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a" ], [ "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6" ], [ "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996" ], [ "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e" ], [ "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d" ], [ "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2" ], [ "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e" ], [ "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437" ], [ "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311" ], [ "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4" ], [ "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575" ], [ "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d" ], [ "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d" ], [ "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629" ], [ "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06" ], [ "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374" ], [ "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee" ], [ "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1" ], [ "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b" ], [ "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661" ], [ "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6" ], [ "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e" ], [ "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d" ], [ "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc" ], [ "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4" ], [ "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c" ], [ "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b" ], [ "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913" ], [ "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154" ], [ "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865" ], [ "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc" ], [ "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224" ], [ "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e" ], [ "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6" ], [ "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511" ], [ "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b" ], [ "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2" ], [ "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c" ], [ "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3" ], [ "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d" ], [ "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700" ], [ "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4" ], [ "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196" ], [ "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4" ], [ "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257" ], [ "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13" ], [ "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096" ], [ "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38" ], [ "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f" ], [ "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448" ], [ "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a" ], [ "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4" ], [ "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437" ], [ "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7" ], [ "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d" ], [ "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a" ], [ "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54" ], [ "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77" ], [ "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517" ], [ "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10" ], [ "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125" ], [ "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e" ], [ "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1" ], [ "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2" ], [ "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423" ], [ "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8" ], [ "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758" ], [ "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375" ], [ "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d" ], [ "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec" ], [ "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0" ], [ "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c" ], [ "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4" ], [ "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f" ], [ "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649" ], [ "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826" ], [ "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5" ], [ "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87" ], [ "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b" ], [ "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc" ], [ "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c" ], [ "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f" ], [ "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a" ], [ "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46" ], [ "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f" ], [ "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03" ], [ "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08" ], [ "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8" ], [ "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373" ], [ "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3" ], [ "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8" ], [ "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1" ], [ "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9" ] ]
            }
        };
        return secp256k1;
    }
    (function(exports) {
        var curves = exports;
        var hash = hash$2;
        var curve$1 = curve;
        var utils = utils$f;
        var assert = utils.assert;
        function PresetCurve(options) {
            if (options.type === "short") this.curve = new curve$1.short(options); else if (options.type === "edwards") this.curve = new curve$1.edwards(options); else this.curve = new curve$1.mont(options);
            this.g = this.curve.g;
            this.n = this.curve.n;
            this.hash = options.hash;
            assert(this.g.validate(), "Invalid curve");
            assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        curves.PresetCurve = PresetCurve;
        function defineCurve(name, options) {
            Object.defineProperty(curves, name, {
                configurable: true,
                enumerable: true,
                get: function() {
                    var curve = new PresetCurve(options);
                    Object.defineProperty(curves, name, {
                        configurable: true,
                        enumerable: true,
                        value: curve
                    });
                    return curve;
                }
            });
        }
        defineCurve("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: hash.sha256,
            gRed: false,
            g: [ "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811" ]
        });
        defineCurve("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: hash.sha256,
            gRed: false,
            g: [ "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34" ]
        });
        defineCurve("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: hash.sha256,
            gRed: false,
            g: [ "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5" ]
        });
        defineCurve("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f " + "5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 " + "f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: hash.sha384,
            gRed: false,
            g: [ "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 " + "5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 " + "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f" ]
        });
        defineCurve("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b " + "99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd " + "3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff " + "ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 " + "f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: hash.sha512,
            gRed: false,
            g: [ "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 " + "053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 " + "a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 " + "579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 " + "3fad0761 353c7086 a272c240 88be9476 9fd16650" ]
        });
        defineCurve("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: hash.sha256,
            gRed: false,
            g: [ "9" ]
        });
        defineCurve("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: hash.sha256,
            gRed: false,
            g: [ "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658" ]
        });
        var pre;
        try {
            pre = requireSecp256k1();
        } catch (e) {
            pre = undefined;
        }
        defineCurve("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: hash.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [ {
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            } ],
            gRed: false,
            g: [ "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre ]
        });
    })(curves$3);
    var hash$1 = hash$2;
    var utils$9 = utils$e;
    var assert$6 = minimalisticAssert;
    function HmacDRBG$1(options) {
        if (!(this instanceof HmacDRBG$1)) return new HmacDRBG$1(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils$9.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils$9.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils$9.toArray(options.pers, options.persEnc || "hex");
        assert$6(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
    }
    var hmacDrbg = HmacDRBG$1;
    HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
            this.K[i] = 0;
            this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
    };
    HmacDRBG$1.prototype._hmac = function hmac() {
        return new hash$1.hmac(this.hash, this.K);
    };
    HmacDRBG$1.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([ 0 ]);
        if (seed) kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed) return;
        this.K = this._hmac().update(this.V).update([ 1 ]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
            addEnc = add;
            add = entropyEnc;
            entropyEnc = null;
        }
        entropy = utils$9.toArray(entropy, entropyEnc);
        add = utils$9.toArray(add, addEnc);
        assert$6(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
    };
    HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        if (typeof enc !== "string") {
            addEnc = add;
            add = enc;
            enc = null;
        }
        if (add) {
            add = utils$9.toArray(add, addEnc || "hex");
            this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
            this.V = this._hmac().update(this.V).digest();
            temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils$9.encode(res, enc);
    };
    var BN$3 = bn.exports;
    var utils$8 = utils$f;
    var assert$5 = utils$8.assert;
    function KeyPair$3(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv) this._importPrivate(options.priv, options.privEnc);
        if (options.pub) this._importPublic(options.pub, options.pubEnc);
    }
    var key$1 = KeyPair$3;
    KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair$3) return pub;
        return new KeyPair$3(ec, {
            pub: pub,
            pubEnc: enc
        });
    };
    KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair$3) return priv;
        return new KeyPair$3(ec, {
            priv: priv,
            privEnc: enc
        });
    };
    KeyPair$3.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity()) return {
            result: false,
            reason: "Invalid public key"
        };
        if (!pub.validate()) return {
            result: false,
            reason: "Public key is not a point"
        };
        if (!pub.mul(this.ec.curve.n).isInfinity()) return {
            result: false,
            reason: "Public key * N != O"
        };
        return {
            result: true,
            reason: null
        };
    };
    KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
            enc = compact;
            compact = null;
        }
        if (!this.pub) this.pub = this.ec.g.mul(this.priv);
        if (!enc) return this.pub;
        return this.pub.encode(enc, compact);
    };
    KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex") return this.priv.toString(16, 2); else return this.priv;
    };
    KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN$3(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
            if (this.ec.curve.type === "mont") {
                assert$5(key.x, "Need x coordinate");
            } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
                assert$5(key.x && key.y, "Need both x and y coordinate");
            }
            this.pub = this.ec.curve.point(key.x, key.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair$3.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
            assert$5(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
    };
    KeyPair$3.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
    };
    KeyPair$3.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
    };
    KeyPair$3.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    var BN$2 = bn.exports;
    var utils$7 = utils$f;
    var assert$4 = utils$7.assert;
    function Signature$4(options, enc) {
        if (options instanceof Signature$4) return options;
        if (this._importDER(options, enc)) return;
        assert$4(options.r && options.s, "Signature without r or s");
        this.r = new BN$2(options.r, 16);
        this.s = new BN$2(options.s, 16);
        if (options.recoveryParam === undefined) this.recoveryParam = null; else this.recoveryParam = options.recoveryParam;
    }
    var signature$1 = Signature$4;
    function Position() {
        this.place = 0;
    }
    function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
            return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
            return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
            val <<= 8;
            val |= buf[off];
            val >>>= 0;
        }
        if (val <= 127) {
            return false;
        }
        p.place = off;
        return val;
    }
    function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
            i++;
        }
        if (i === 0) {
            return buf;
        }
        return buf.slice(i);
    }
    Signature$4.prototype._importDER = function _importDER(data, enc) {
        data = utils$7.toArray(data, enc);
        var p = new Position;
        if (data[p.place++] !== 48) {
            return false;
        }
        var len = getLength(data, p);
        if (len === false) {
            return false;
        }
        if (len + p.place !== data.length) {
            return false;
        }
        if (data[p.place++] !== 2) {
            return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
            return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
            return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
            return false;
        }
        if (data.length !== slen + p.place) {
            return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
            if (r[1] & 128) {
                r = r.slice(1);
            } else {
                return false;
            }
        }
        if (s[0] === 0) {
            if (s[1] & 128) {
                s = s.slice(1);
            } else {
                return false;
            }
        }
        this.r = new BN$2(r);
        this.s = new BN$2(s);
        this.recoveryParam = null;
        return true;
    };
    function constructLength(arr, len) {
        if (len < 128) {
            arr.push(len);
            return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
            arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
    }
    Signature$4.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128) r = [ 0 ].concat(r);
        if (s[0] & 128) s = [ 0 ].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
            s = s.slice(1);
        }
        var arr = [ 2 ];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [ 48 ];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils$7.encode(res, enc);
    };
    var BN$1 = bn.exports;
    var HmacDRBG = hmacDrbg;
    var utils$6 = utils$f;
    var curves$2 = curves$3;
    var rand = brorand.exports;
    var assert$3 = utils$6.assert;
    var KeyPair$2 = key$1;
    var Signature$3 = signature$1;
    function EC(options) {
        if (!(this instanceof EC)) return new EC(options);
        if (typeof options === "string") {
            assert$3(Object.prototype.hasOwnProperty.call(curves$2, options), "Unknown curve " + options);
            options = curves$2[options];
        }
        if (options instanceof curves$2.PresetCurve) options = {
            curve: options
        };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
    }
    var ec = EC;
    EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair$2(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair$2.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair$2.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options) options = {};
        var drbg = new HmacDRBG({
            hash: this.hash,
            pers: options.pers,
            persEnc: options.persEnc || "utf8",
            entropy: options.entropy || rand(this.hash.hmacStrength),
            entropyEnc: options.entropy && options.entropyEnc || "utf8",
            nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN$1(2));
        for (;;) {
            var priv = new BN$1(drbg.generate(bytes));
            if (priv.cmp(ns2) > 0) continue;
            priv.iaddn(1);
            return this.keyFromPrivate(priv);
        }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0) msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n); else return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
            options = enc;
            enc = null;
        }
        if (!options) options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN$1(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({
            hash: this.hash,
            entropy: bkey,
            nonce: nonce,
            pers: options.pers,
            persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN$1(1));
        for (var iter = 0; ;iter++) {
            var k = options.k ? options.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
            k = this._truncateToN(k, true);
            if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
            var kp = this.g.mul(k);
            if (kp.isInfinity()) continue;
            var kpX = kp.getX();
            var r = kpX.umod(this.n);
            if (r.cmpn(0) === 0) continue;
            var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
            s = s.umod(this.n);
            if (s.cmpn(0) === 0) continue;
            var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
            if (options.canonical && s.cmp(this.nh) > 0) {
                s = this.n.sub(s);
                recoveryParam ^= 1;
            }
            return new Signature$3({
                r: r,
                s: s,
                recoveryParam: recoveryParam
            });
        }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN$1(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature$3(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
            p = this.g.mulAdd(u1, key.getPublic(), u2);
            if (p.isInfinity()) return false;
            return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert$3((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature$3(signature, enc);
        var n = this.n;
        var e = new BN$1(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
        if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd); else r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature$3(signature, enc);
        if (signature.recoveryParam !== null) return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
            var Qprime;
            try {
                Qprime = this.recoverPubKey(e, signature, i);
            } catch (e) {
                continue;
            }
            if (Qprime.eq(Q)) return i;
        }
        throw new Error("Unable to find valid recovery factor");
    };
    var utils$5 = utils$f;
    var assert$2 = utils$5.assert;
    var parseBytes$2 = utils$5.parseBytes;
    var cachedProperty$1 = utils$5.cachedProperty;
    function KeyPair$1(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes$2(params.secret);
        if (eddsa.isPoint(params.pub)) this._pub = params.pub; else this._pubBytes = parseBytes$2(params.pub);
    }
    KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair$1) return pub;
        return new KeyPair$1(eddsa, {
            pub: pub
        });
    };
    KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair$1) return secret;
        return new KeyPair$1(eddsa, {
            secret: secret
        });
    };
    KeyPair$1.prototype.secret = function secret() {
        return this._secret;
    };
    cachedProperty$1(KeyPair$1, "pubBytes", (function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
    }));
    cachedProperty$1(KeyPair$1, "pub", (function pub() {
        if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
    }));
    cachedProperty$1(KeyPair$1, "privBytes", (function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
    }));
    cachedProperty$1(KeyPair$1, "priv", (function priv() {
        return this.eddsa.decodeInt(this.privBytes());
    }));
    cachedProperty$1(KeyPair$1, "hash", (function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
    }));
    cachedProperty$1(KeyPair$1, "messagePrefix", (function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
    }));
    KeyPair$1.prototype.sign = function sign(message) {
        assert$2(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
    };
    KeyPair$1.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
    };
    KeyPair$1.prototype.getSecret = function getSecret(enc) {
        assert$2(this._secret, "KeyPair is public only");
        return utils$5.encode(this.secret(), enc);
    };
    KeyPair$1.prototype.getPublic = function getPublic(enc) {
        return utils$5.encode(this.pubBytes(), enc);
    };
    var key = KeyPair$1;
    var BN = bn.exports;
    var utils$4 = utils$f;
    var assert$1 = utils$4.assert;
    var cachedProperty = utils$4.cachedProperty;
    var parseBytes$1 = utils$4.parseBytes;
    function Signature$2(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object") sig = parseBytes$1(sig);
        if (Array.isArray(sig)) {
            sig = {
                R: sig.slice(0, eddsa.encodingLength),
                S: sig.slice(eddsa.encodingLength)
            };
        }
        assert$1(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R)) this._R = sig.R;
        if (sig.S instanceof BN) this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature$2, "S", (function S() {
        return this.eddsa.decodeInt(this.Sencoded());
    }));
    cachedProperty(Signature$2, "R", (function R() {
        return this.eddsa.decodePoint(this.Rencoded());
    }));
    cachedProperty(Signature$2, "Rencoded", (function Rencoded() {
        return this.eddsa.encodePoint(this.R());
    }));
    cachedProperty(Signature$2, "Sencoded", (function Sencoded() {
        return this.eddsa.encodeInt(this.S());
    }));
    Signature$2.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
    };
    Signature$2.prototype.toHex = function toHex() {
        return utils$4.encode(this.toBytes(), "hex").toUpperCase();
    };
    var signature = Signature$2;
    var hash = hash$2;
    var curves$1 = curves$3;
    var utils$3 = utils$f;
    var assert = utils$3.assert;
    var parseBytes = utils$3.parseBytes;
    var KeyPair = key;
    var Signature$1 = signature;
    function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA)) return new EDDSA(curve);
        curve = curves$1[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
    }
    var eddsa = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({
            R: R,
            S: S,
            Rencoded: Rencoded
        });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
        var hash = this.hash();
        for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);
        return utils$3.intFromLE(hash.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature$1) return sig;
        return new Signature$1(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils$3.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils$3.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils$3.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
    };
    (function(exports) {
        var elliptic = exports;
        elliptic.version = require$0.version;
        elliptic.utils = utils$f;
        elliptic.rand = brorand.exports;
        elliptic.curve = curve;
        elliptic.curves = curves$3;
        elliptic.ec = ec;
        elliptic.eddsa = eddsa;
    })(elliptic);
    /**
     * EOSIO Core v0.6.4
     * https://github.com/greymass/eosio-core
     *
     * @license
     * Copyright (c) 2020 FFF00 Agents AB & Greymass Inc. All Rights Reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification,
     * are permitted provided that the following conditions are met:
     * 
     *  1. Redistribution of source code must retain the above copyright notice, this
     *     list of conditions and the following disclaimer.
     * 
     *  2. Redistribution in binary form must reproduce the above copyright notice,
     *     this list of conditions and the following disclaimer in the documentation
     *     and/or other materials provided with the distribution.
     * 
     *  3. Neither the name of the copyright holder nor the names of its contributors
     *     may be used to endorse or promote products derived from this software without
     *     specific prior written permission.
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
     * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     * OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
     * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
     */    function arrayEquals(a, b) {
        const len = a.length;
        if (len !== b.length) {
            return false;
        }
        for (let i = 0; i < len; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    function arrayEquatableEquals(a, b) {
        const len = a.length;
        if (len !== b.length) {
            return false;
        }
        for (let i = 0; i < len; i++) {
            if (!a[i].equals(b[i])) {
                return false;
            }
        }
        return true;
    }
    const hexLookup = {};
    function buildHexLookup() {
        hexLookup.enc = new Array(255);
        hexLookup.dec = {};
        for (let i = 0; i <= 255; ++i) {
            const b = i.toString(16).padStart(2, "0");
            hexLookup.enc[i] = b;
            hexLookup.dec[b] = i;
        }
    }
    function arrayToHex(array) {
        if (!hexLookup.enc) {
            buildHexLookup();
        }
        const len = array.length;
        const rv = new Array(len);
        for (let i = 0; i < len; ++i) {
            rv[i] = hexLookup.enc[array[i]];
        }
        return rv.join("");
    }
    function hexToArray(hex) {
        if (!hexLookup.dec) {
            buildHexLookup();
        }
        if (typeof hex !== "string") {
            throw new Error("Expected string containing hex digits");
        }
        if (hex.length % 2) {
            throw new Error("Odd number of hex digits");
        }
        hex = hex.toLowerCase();
        const len = hex.length / 2;
        const result = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            const b = hexLookup.dec[hex[i * 2] + hex[i * 2 + 1]];
            if (b === undefined) {
                throw new Error("Expected hex string");
            }
            result[i] = b;
        }
        return result;
    }
    function secureRandom(length) {
        return brorand.exports(length);
    }
    let didWarn = false;
    function isInstanceOf(object, someClass) {
        if (object instanceof someClass) {
            return true;
        }
        if (object == null || typeof object !== "object") {
            return false;
        }
        const className = someClass["__className"] || someClass["abiName"];
        if (!className) {
            return false;
        }
        let instanceClass = object.constructor;
        let isAlienInstance = false;
        while (instanceClass && !isAlienInstance) {
            const instanceClassName = instanceClass["__className"] || instanceClass["abiName"];
            if (!instanceClassName) {
                break;
            }
            isAlienInstance = className == instanceClassName;
            instanceClass = Object.getPrototypeOf(instanceClass);
        }
        if (isAlienInstance && !didWarn) {
            console.warn(`Detected alien instance of ${className}, this usually means more than one version of @greymass/eosio has been included in your bundle.`);
            didWarn = true;
        }
        return isAlienInstance;
    }
    class Bytes {
        constructor(array = new Uint8Array) {
            this.array = array;
        }
        static from(value, encoding) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            if (typeof value === "string") {
                return this.fromString(value, encoding);
            }
            if (ArrayBuffer.isView(value)) {
                return new this(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));
            }
            if (isInstanceOf(value["array"], Uint8Array)) {
                return new this(value["array"]);
            }
            return new this(new Uint8Array(value));
        }
        static fromString(value, encoding = "hex") {
            if (encoding === "hex") {
                const array = hexToArray(value);
                return new this(array);
            } else if (encoding == "utf8") {
                const encoder = new TextEncoder;
                return new this(encoder.encode(value));
            } else {
                throw new Error(`Unknown encoding: ${encoding}`);
            }
        }
        static fromABI(decoder) {
            const len = decoder.readVaruint32();
            return new this(decoder.readArray(len));
        }
        static abiDefault() {
            return new Bytes;
        }
        static equal(a, b) {
            return this.from(a).equals(this.from(b));
        }
        static random(length) {
            return new this(secureRandom(length));
        }
        static isBytes(value) {
            if (isInstanceOf(value, Bytes) || isInstanceOf(value, Uint8Array)) {
                return true;
            }
            if (Array.isArray(value) && value.every((v => typeof v === "number"))) {
                return true;
            }
            if (typeof value === "string" && (/[\da-f]/i.test(value) || value === "")) {
                return true;
            }
            return false;
        }
        get length() {
            return this.array.byteLength;
        }
        get hexString() {
            return arrayToHex(this.array);
        }
        get utf8String() {
            return (new TextDecoder).decode(this.array);
        }
        append(other) {
            other = Bytes.from(other);
            const newSize = this.array.byteLength + other.array.byteLength;
            const buffer = new ArrayBuffer(newSize);
            const array = new Uint8Array(buffer);
            array.set(this.array);
            array.set(other.array, this.array.byteLength);
            this.array = array;
        }
        appending(other) {
            const rv = new Bytes(this.array);
            rv.append(other);
            return rv;
        }
        zeropad(n, truncate = false) {
            const newSize = truncate ? n : Math.max(n, this.array.byteLength);
            const buffer = new ArrayBuffer(newSize);
            const array = new Uint8Array(buffer);
            array.fill(0);
            if (truncate && this.array.byteLength > newSize) {
                array.set(this.array.slice(0, newSize), 0);
            } else {
                array.set(this.array, newSize - this.array.byteLength);
            }
            this.array = array;
        }
        zeropadded(n, truncate = false) {
            const rv = new Bytes(this.array);
            rv.zeropad(n, truncate);
            return rv;
        }
        dropFirst(n = 1) {
            this.array = this.array.subarray(n);
        }
        droppingFirst(n = 1) {
            return new Bytes(this.array.subarray(n));
        }
        copy() {
            const buffer = new ArrayBuffer(this.array.byteLength);
            const array = new Uint8Array(buffer);
            array.set(this.array);
            return new Bytes(array);
        }
        equals(other) {
            return arrayEquals(this.array, Bytes.from(other).array);
        }
        toString(encoding = "hex") {
            if (encoding === "hex") {
                return this.hexString;
            } else if (encoding === "utf8") {
                return this.utf8String;
            } else {
                throw new Error(`Unknown encoding: ${encoding}`);
            }
        }
        toABI(encoder) {
            encoder.writeVaruint32(this.array.byteLength);
            encoder.writeArray(this.array);
        }
        toJSON() {
            return this.hexString;
        }
    }
    Bytes.abiName = "bytes";
    class Checksum {
        constructor(array) {
            const byteSize = this.constructor.byteSize;
            if (array.byteLength !== byteSize) {
                throw new Error(`Checksum size mismatch, expected ${byteSize} bytes got ${array.byteLength}`);
            }
            this.array = array;
        }
        static from(value) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            if (isInstanceOf(value, Checksum)) {
                return new this(value.array);
            }
            return new this(Bytes.from(value).array);
        }
        static fromABI(decoder) {
            return new this(decoder.readArray(this.byteSize));
        }
        static abiDefault() {
            return new this(new Uint8Array(this.byteSize));
        }
        equals(other) {
            const self = this.constructor;
            try {
                return arrayEquals(this.array, self.from(other).array);
            } catch {
                return false;
            }
        }
        get hexString() {
            return arrayToHex(this.array);
        }
        toABI(encoder) {
            encoder.writeArray(this.array);
        }
        toString() {
            return this.hexString;
        }
        toJSON() {
            return this.toString();
        }
    }
    Checksum.abiName = "__checksum";
    class Checksum256 extends Checksum {
        static from(value) {
            return super.from(value);
        }
        static hash(data) {
            const digest = new Uint8Array(hash$2.sha256().update(Bytes.from(data).array).digest());
            return new Checksum256(digest);
        }
    }
    Checksum256.abiName = "checksum256";
    Checksum256.byteSize = 32;
    class Checksum512 extends Checksum {
        static from(value) {
            return super.from(value);
        }
        static hash(data) {
            const digest = new Uint8Array(hash$2.sha512().update(Bytes.from(data).array).digest());
            return new Checksum512(digest);
        }
    }
    Checksum512.abiName = "checksum512";
    Checksum512.byteSize = 64;
    class Checksum160 extends Checksum {
        static from(value) {
            return super.from(value);
        }
        static hash(data) {
            const digest = new Uint8Array(hash$2.ripemd160().update(Bytes.from(data).array).digest());
            return new Checksum160(digest);
        }
    }
    Checksum160.abiName = "checksum160";
    Checksum160.byteSize = 20;
    var KeyType;
    (function(KeyType) {
        KeyType["K1"] = "K1";
        KeyType["R1"] = "R1";
        KeyType["WA"] = "WA";
    })(KeyType || (KeyType = {}));
    (function(KeyType) {
        function indexFor(value) {
            switch (value) {
              case KeyType.K1:
                return 0;

              case KeyType.R1:
                return 1;

              case KeyType.WA:
                return 2;

              default:
                throw new Error(`Unknown curve type: ${value}`);
            }
        }
        KeyType.indexFor = indexFor;
        function from(value) {
            let index;
            if (typeof value !== "number") {
                index = KeyType.indexFor(value);
            } else {
                index = value;
            }
            switch (index) {
              case 0:
                return KeyType.K1;

              case 1:
                return KeyType.R1;

              case 2:
                return KeyType.WA;

              default:
                throw new Error("Unknown curve type");
            }
        }
        KeyType.from = from;
    })(KeyType || (KeyType = {}));
    class Int {
        constructor(value) {
            const self = this.constructor;
            if (self.isSigned === undefined || self.byteWidth === undefined) {
                throw new Error("Cannot instantiate abstract class Int");
            }
            if (value.gt(self.max)) {
                throw new Error(`Number ${value} overflows ${self.abiName}`);
            }
            if (value.lt(self.min)) {
                throw new Error(`Number ${value} underflows ${self.abiName}`);
            }
            this.value = value;
        }
        static get max() {
            return new BN$8(2).pow(new BN$8(this.byteWidth * 8 - (this.isSigned ? 1 : 0))).isubn(1);
        }
        static get min() {
            return this.isSigned ? this.max.ineg().isubn(1) : new BN$8(0);
        }
        static add(lhs, rhs, overflow = "truncate") {
            return Int.operator(lhs, rhs, overflow, ((a, b) => a.add(b)));
        }
        static sub(lhs, rhs, overflow) {
            return Int.operator(lhs, rhs, overflow, ((a, b) => a.sub(b)));
        }
        static mul(lhs, rhs, overflow) {
            return Int.operator(lhs, rhs, overflow, ((a, b) => a.mul(b)));
        }
        static div(lhs, rhs, overflow) {
            return Int.operator(lhs, rhs, overflow, ((a, b) => {
                if (b.isZero()) {
                    throw new Error("Division by zero");
                }
                return a.div(b);
            }));
        }
        static divRound(lhs, rhs, overflow) {
            return Int.operator(lhs, rhs, overflow, ((a, b) => {
                if (b.isZero()) {
                    throw new Error("Division by zero");
                }
                return a.divRound(b);
            }));
        }
        static divCeil(lhs, rhs, overflow) {
            return Int.operator(lhs, rhs, overflow, ((a, b) => {
                if (b.isZero()) {
                    throw new Error("Division by zero");
                }
                const dm = a.divmod(b);
                if (dm.mod.isZero()) return dm.div;
                return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
            }));
        }
        static operator(lhs, rhs, overflow = "truncate", fn) {
            const {a: a, b: b} = convert(lhs, rhs);
            const type = a.constructor;
            const result = fn(a.value, b.value);
            return type.from(result, overflow);
        }
        static from(value, overflow) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            let fromType = this;
            let bn;
            if (isInstanceOf(value, Int)) {
                fromType = value.constructor;
                bn = value.value.clone();
            } else if (value instanceof Uint8Array) {
                bn = new BN$8(value, undefined, "le");
                if (fromType.isSigned) {
                    bn = bn.fromTwos(fromType.byteWidth * 8);
                }
            } else {
                if (typeof value === "string" && !/[0-9]+/.test(value) || typeof value === "number" && !Number.isFinite(value)) {
                    throw new Error("Invalid number");
                }
                bn = BN$8.isBN(value) ? value.clone() : new BN$8(value, 10);
                if (bn.isNeg() && !fromType.isSigned) {
                    fromType = {
                        byteWidth: fromType.byteWidth,
                        isSigned: true
                    };
                }
            }
            switch (overflow) {
              case "clamp":
                bn = clamp(bn, this.min, this.max);
                break;

              case "truncate":
                bn = truncate(bn, fromType, this);
                break;
            }
            return new this(bn);
        }
        static fromABI(decoder) {
            return this.from(decoder.readArray(this.byteWidth));
        }
        static abiDefault() {
            return this.from(0);
        }
        static random() {
            return this.from(secureRandom(this.byteWidth));
        }
        cast(type, overflow = "truncate") {
            if (this.constructor === type) {
                return this;
            }
            return type.from(this, overflow);
        }
        get byteArray() {
            const self = this.constructor;
            const value = self.isSigned ? this.value.toTwos(self.byteWidth * 8) : this.value;
            return value.toArrayLike(Uint8Array, "le", self.byteWidth);
        }
        equals(other, strict = false) {
            const self = this.constructor;
            if (strict === true && isInstanceOf(other, Int)) {
                const otherType = other.constructor;
                if (self.byteWidth !== otherType.byteWidth || self.isSigned !== otherType.isSigned) {
                    return false;
                }
            }
            try {
                return this.value.eq(self.from(other).value);
            } catch {
                return false;
            }
        }
        add(num) {
            this.value = this.operator(num, Int.add).value;
        }
        adding(num) {
            return this.operator(num, Int.add);
        }
        subtract(num) {
            this.value = this.operator(num, Int.sub).value;
        }
        subtracting(num) {
            return this.operator(num, Int.sub);
        }
        multiply(by) {
            this.value = this.operator(by, Int.mul).value;
        }
        multiplying(by) {
            return this.operator(by, Int.mul);
        }
        divide(by, behavior) {
            this.value = this.dividing(by, behavior).value;
        }
        dividing(by, behavior) {
            let op = Int.div;
            switch (behavior) {
              case "ceil":
                op = Int.divCeil;
                break;

              case "round":
                op = Int.divRound;
                break;
            }
            return this.operator(by, op);
        }
        operator(other, fn) {
            let rhs;
            if (isInstanceOf(other, Int)) {
                rhs = other;
            } else {
                rhs = Int64.from(other, "truncate");
            }
            return fn(this, rhs).cast(this.constructor);
        }
        toNumber() {
            return this.value.toNumber();
        }
        toString() {
            return this.value.toString();
        }
        [Symbol.toPrimitive](type) {
            if (type === "number") {
                return this.toNumber();
            } else {
                return this.toString();
            }
        }
        toABI(encoder) {
            encoder.writeArray(this.byteArray);
        }
        toJSON() {
            if (this.value.bitLength() > 32) {
                return this.value.toString();
            } else {
                return this.value.toNumber();
            }
        }
    }
    Int.abiName = "__int";
    class Int8 extends Int {}
    Int8.abiName = "int8";
    Int8.byteWidth = 1;
    Int8.isSigned = true;
    class Int16 extends Int {}
    Int16.abiName = "int16";
    Int16.byteWidth = 2;
    Int16.isSigned = true;
    class Int32 extends Int {}
    Int32.abiName = "int32";
    Int32.byteWidth = 4;
    Int32.isSigned = true;
    class Int64 extends Int {}
    Int64.abiName = "int64";
    Int64.byteWidth = 8;
    Int64.isSigned = true;
    class Int128 extends Int {}
    Int128.abiName = "int128";
    Int128.byteWidth = 16;
    Int128.isSigned = true;
    class UInt8 extends Int {}
    UInt8.abiName = "uint8";
    UInt8.byteWidth = 1;
    UInt8.isSigned = false;
    class UInt16 extends Int {}
    UInt16.abiName = "uint16";
    UInt16.byteWidth = 2;
    UInt16.isSigned = false;
    class UInt32 extends Int {}
    UInt32.abiName = "uint32";
    UInt32.byteWidth = 4;
    UInt32.isSigned = false;
    class UInt64 extends Int {}
    UInt64.abiName = "uint64";
    UInt64.byteWidth = 8;
    UInt64.isSigned = false;
    class UInt128 extends Int {}
    UInt128.abiName = "uint128";
    UInt128.byteWidth = 16;
    UInt128.isSigned = false;
    class VarInt extends Int {
        static fromABI(decoder) {
            return new this(new BN$8(decoder.readVarint32()));
        }
        toABI(encoder) {
            encoder.writeVarint32(Number(this));
        }
    }
    VarInt.abiName = "varint32";
    VarInt.byteWidth = 32;
    VarInt.isSigned = true;
    class VarUInt extends Int {
        static fromABI(decoder) {
            return new this(new BN$8(decoder.readVaruint32()));
        }
        toABI(encoder) {
            encoder.writeVaruint32(Number(this));
        }
    }
    VarUInt.abiName = "varuint32";
    VarUInt.byteWidth = 32;
    VarUInt.isSigned = false;
    function clamp(num, min, max) {
        return BN$8.min(BN$8.max(num, min), max);
    }
    function truncate(value, from, to) {
        const fill = value.isNeg() ? 255 : 0;
        const fromValue = from.isSigned ? value.toTwos(from.byteWidth * 8) : value;
        const fromBytes = fromValue.toArrayLike(Uint8Array, "le");
        const toBytes = new Uint8Array(to.byteWidth);
        toBytes.fill(fill);
        toBytes.set(fromBytes.slice(0, to.byteWidth));
        const toValue = new BN$8(toBytes, undefined, "le");
        return to.isSigned ? toValue.fromTwos(to.byteWidth * 8) : toValue;
    }
    function convert(a, b) {
        a = promote(a);
        b = promote(b);
        const aType = a.constructor;
        const bType = b.constructor;
        if (aType !== bType) {
            if (aType.isSigned === bType.isSigned) {
                if (aType.byteWidth > bType.byteWidth) {
                    b = b.cast(aType);
                } else if (bType.byteWidth > aType.byteWidth) {
                    a = a.cast(bType);
                }
            } else {
                if (aType.isSigned === false && aType.byteWidth >= bType.byteWidth) {
                    b = b.cast(aType);
                } else if (bType.isSigned === false && bType.byteWidth >= aType.byteWidth) {
                    a = a.cast(bType);
                } else {
                    if (aType.isSigned === true && aType.max.gte(bType.max) && aType.min.lte(bType.min)) {
                        b = b.cast(aType);
                    } else if (bType.isSigned === true && bType.max.gte(aType.max) && bType.min.lte(aType.min)) {
                        a = a.cast(bType);
                    } else ;
                }
            }
        }
        return {
            a: a,
            b: b
        };
    }
    function promote(n) {
        let rv = n;
        const type = n.constructor;
        if (type.byteWidth < 4) {
            rv = n.cast(Int32);
        }
        return rv;
    }
    function synthesizeABI(type) {
        const structs = [];
        const variants = [];
        const aliases = [];
        const seen = new Set;
        const resolveAbiType = t => {
            let typeName;
            if (typeof t.type !== "string") {
                typeName = resolve(t.type);
            } else {
                typeName = t.type;
            }
            if (t.array === true) {
                typeName += "[]";
            }
            if (t.optional === true) {
                typeName += "?";
            }
            if (t.extension === true) {
                typeName += "$";
            }
            return typeName;
        };
        const resolve = t => {
            if (!t.abiName) {
                throw new Error("Encountered non-conforming type");
            } else if (t.abiName === "__struct") {
                throw new Error("Misconfigured Struct subclass, did you forget @Struct.type?");
            }
            if (seen.has(t)) {
                return t.abiName;
            }
            seen.add(t);
            if (t.abiAlias) {
                aliases.push({
                    new_type_name: t.abiName,
                    type: resolveAbiType(t.abiAlias)
                });
            } else if (t.abiFields) {
                const fields = t.abiFields.map((field => ({
                    name: field.name,
                    type: resolveAbiType(field)
                })));
                const struct = {
                    base: t.abiBase ? resolve(t.abiBase) : "",
                    name: t.abiName,
                    fields: fields
                };
                structs.push(struct);
            } else if (t.abiVariant) {
                const variant = {
                    name: t.abiName,
                    types: t.abiVariant.map(resolveAbiType)
                };
                variants.push(variant);
            }
            return t.abiName;
        };
        const root = resolve(type);
        return {
            abi: ABI.from({
                structs: structs,
                variants: variants,
                types: aliases
            }),
            types: Array.from(seen),
            root: root
        };
    }
    function abiTypeString(type) {
        let typeName = typeof type.type === "string" ? type.type : type.type.abiName;
        if (type.array === true) {
            typeName += "[]";
        }
        if (type.optional === true) {
            typeName += "?";
        }
        if (type.extension === true) {
            typeName += "$";
        }
        return typeName;
    }
    function isTypeDescriptor(type) {
        return typeof type !== "string" && type.abiName === undefined && type.type !== undefined;
    }
    function toTypeDescriptor(type) {
        if (typeof type === "string") {
            return {
                type: type
            };
        }
        if (typeof type.abiName !== "undefined") {
            return {
                type: type
            };
        }
        return type;
    }
    const StringType = {
        abiName: "string",
        abiDefault: () => "",
        fromABI: decoder => decoder.readString(),
        from: string => string,
        toABI: (string, encoder) => {
            encoder.writeString(string);
        }
    };
    const BoolType = {
        abiName: "bool",
        abiDefault: () => false,
        fromABI: decoder => decoder.readByte() === 1,
        from: value => value,
        toABI: (value, encoder) => {
            encoder.writeByte(value === true ? 1 : 0);
        }
    };
    function getBuiltins() {
        return [ BoolType, StringType, Asset, Asset.Symbol, Asset.SymbolCode, BlockTimestamp, Bytes, Checksum160, Checksum256, Checksum512, ExtendedAsset, Float128, Float32, Float64, Int128, Int16, Int32, Int64, Int8, Name, PublicKey, Signature, TimePoint, TimePointSec, UInt128, UInt16, UInt32, UInt64, UInt8, VarInt, VarUInt ];
    }
    function buildTypeLookup(additional = []) {
        const rv = {};
        const builtins = getBuiltins();
        for (const type of builtins) {
            rv[type.abiName] = type;
        }
        for (const type of additional) {
            if (!type.abiName) {
                throw new Error("Invalid type");
            }
            rv[type.abiName] = type;
        }
        return rv;
    }
    function getTypeName(object) {
        if (object.constructor && object.constructor.abiName !== undefined) {
            return object.constructor.abiName;
        }
        if (Array.isArray(object)) {
            const types = object.map(getTypeName);
            const type = types[0];
            if (!type || !types.every((t => t === type))) {
                return;
            }
            return type + "[]";
        }
        switch (typeof object) {
          case "boolean":
            return "bool";

          case "string":
            return "string";
        }
    }
    function getType(object, name = "jsobj") {
        var _a;
        if (object.constructor && object.constructor.abiName !== undefined) {
            return object.constructor;
        }
        if (Array.isArray(object)) {
            const types = object.map((v => getType(v, name)));
            const type = types[0];
            if (!type) {
                return;
            }
            if (!types.every((t => t && t.abiName === type.abiName))) {
                return;
            }
            return type;
        }
        const objectType = typeof object;
        if (objectType === "object" && object !== null) {
            const fields = Object.keys(object).map((key => ({
                name: key,
                type: getType(object[key], name + "_nested")
            })));
            if (fields.find((field => !field.type))) {
                return;
            }
            return _a = class extends Struct {}, _a.abiName = name, _a.abiFields = fields, _a;
        }
        switch (objectType) {
          case "boolean":
            return BoolType;

          case "string":
            return StringType;
        }
    }
    class DecodingError extends Error {
        constructor(ctx, underlyingError) {
            const path = ctx.codingPath.map((({field: field, type: type}) => {
                if (typeof field === "number") {
                    return field;
                } else {
                    return `${field}<${type.typeName}>`;
                }
            })).join(".");
            super(`Decoding error at ${path}: ${underlyingError.message}`);
            this.stack = underlyingError.stack;
            this.ctx = ctx;
            this.underlyingError = underlyingError;
        }
    }
    DecodingError.__className = "DecodingError";
    function abiDecode(args) {
        const descriptor = toTypeDescriptor(args.type);
        const typeName = abiTypeString(descriptor);
        const customTypes = args.customTypes || [];
        let abi;
        if (args.abi) {
            abi = ABI.from(args.abi);
        } else {
            try {
                let type;
                if (typeof descriptor.type === "string") {
                    const lookup = buildTypeLookup(customTypes);
                    const rName = new ABI.ResolvedType(descriptor.type).name;
                    type = lookup[rName];
                    if (!type) {
                        throw new Error(`Unknown type: ${descriptor.type}`);
                    }
                } else {
                    type = descriptor.type;
                }
                const synthesized = synthesizeABI(type);
                abi = synthesized.abi;
                customTypes.push(...synthesized.types);
            } catch (error) {
                throw Error(`Unable to synthesize ABI for: ${typeName} (${error.message}). ` + "To decode non-class types you need to pass the ABI definition manually.");
            }
        }
        const resolved = abi.resolveType(typeName);
        if (typeof descriptor.type !== "string") {
            customTypes.unshift(descriptor.type);
        }
        const ctx = {
            types: buildTypeLookup(customTypes),
            strictExtensions: args.strictExtensions || false,
            codingPath: [ {
                field: "root",
                type: resolved
            } ]
        };
        try {
            if (args.data) {
                let decoder;
                if (isInstanceOf(args.data, ABIDecoder)) {
                    decoder = args.data;
                } else {
                    const bytes = Bytes.from(args.data);
                    decoder = new ABIDecoder(bytes.array);
                }
                if (args.metadata) {
                    decoder.metadata = args.metadata;
                }
                return decodeBinary(resolved, decoder, ctx);
            } else if (args.object !== undefined) {
                return decodeObject(args.object, resolved, ctx);
            } else if (args.json) {
                return decodeObject(JSON.parse(args.json), resolved, ctx);
            } else {
                throw new Error("Nothing to decode, you must set one of data, json, object");
            }
        } catch (error) {
            throw new DecodingError(ctx, error);
        }
    }
    const Resolved = Symbol("Resolved");
    function decodeBinary(type, decoder, ctx) {
        if (ctx.codingPath.length > 32) {
            throw new Error("Maximum decoding depth exceeded");
        }
        if (type.isExtension) {
            if (!decoder.canRead()) {
                if (ctx.strictExtensions) {
                    return defaultValue(type, ctx);
                } else {
                    return null;
                }
            }
        }
        if (type.isOptional) {
            if (decoder.readByte() === 0) {
                return null;
            }
        }
        if (type.isArray) {
            const len = decoder.readVaruint32();
            const rv = [];
            for (let i = 0; i < len; i++) {
                ctx.codingPath.push({
                    field: i,
                    type: type
                });
                rv.push(decodeInner());
                ctx.codingPath.pop();
            }
            return rv;
        } else {
            return decodeInner();
        }
        function decodeInner() {
            const abiType = ctx.types[type.name];
            if (abiType && abiType.fromABI) {
                return abiType.fromABI(decoder);
            } else {
                if (type.ref) {
                    ctx.codingPath.push({
                        field: "",
                        type: type.ref
                    });
                    const rv = decodeBinary(type.ref, decoder, ctx);
                    ctx.codingPath.pop();
                    return rv;
                } else if (type.fields) {
                    const fields = type.allFields;
                    if (!fields) {
                        throw new Error("Invalid struct fields");
                    }
                    const rv = {};
                    for (const field of fields) {
                        ctx.codingPath.push({
                            field: field.name,
                            type: field.type
                        });
                        rv[field.name] = decodeBinary(field.type, decoder, ctx);
                        ctx.codingPath.pop();
                    }
                    if (abiType) {
                        rv[Resolved] = true;
                        return abiType.from(rv);
                    } else {
                        return rv;
                    }
                } else if (type.variant) {
                    const vIdx = decoder.readByte();
                    const vType = type.variant[vIdx];
                    if (!vType) {
                        throw new Error(`Unknown variant idx: ${vIdx}`);
                    }
                    ctx.codingPath.push({
                        field: `v${vIdx}`,
                        type: vType
                    });
                    const rv = [ vType.typeName, decodeBinary(vType, decoder, ctx) ];
                    ctx.codingPath.pop();
                    if (abiType) {
                        return abiType.from(rv);
                    } else {
                        return rv;
                    }
                } else if (abiType) {
                    throw new Error("Invalid type");
                } else {
                    throw new Error(type.name === "any" ? "Unable to decode 'any' type from binary" : "Unknown type");
                }
            }
        }
    }
    function decodeObject(value, type, ctx) {
        if (value === null || value === undefined) {
            if (type.isOptional) {
                return null;
            }
            if (type.isExtension) {
                if (ctx.strictExtensions) {
                    return defaultValue(type, ctx);
                } else {
                    return null;
                }
            }
            throw new Error(`Unexpectedly encountered ${value} for non-optional`);
        } else if (type.isArray) {
            if (!Array.isArray(value)) {
                throw new Error("Expected array");
            }
            const rv = [];
            const len = value.length;
            for (let i = 0; i < len; i++) {
                ctx.codingPath.push({
                    field: i,
                    type: type
                });
                rv.push(decodeInner(value[i]));
                ctx.codingPath.pop();
            }
            return rv;
        } else {
            return decodeInner(value);
        }
        function decodeInner(value) {
            const abiType = ctx.types[type.name];
            if (type.ref && !abiType) {
                return decodeObject(value, type.ref, ctx);
            } else if (type.fields) {
                if (typeof value !== "object") {
                    throw new Error("Expected object");
                }
                if (typeof abiType === "function" && isInstanceOf(value, abiType)) {
                    return value;
                }
                const fields = type.allFields;
                if (!fields) {
                    throw new Error("Invalid struct fields");
                }
                const struct = {};
                for (const field of fields) {
                    ctx.codingPath.push({
                        field: field.name,
                        type: field.type
                    });
                    struct[field.name] = decodeObject(value[field.name], field.type, ctx);
                    ctx.codingPath.pop();
                }
                if (abiType) {
                    struct[Resolved] = true;
                    return abiType.from(struct);
                } else {
                    return struct;
                }
            } else if (type.variant) {
                let vName;
                if (Array.isArray(value) && value.length === 2 && typeof value[0] === "string") {
                    vName = value[0];
                    value = value[1];
                } else if (isInstanceOf(value, Variant)) {
                    vName = value.variantName;
                    value = value.value;
                } else {
                    vName = getTypeName(value);
                }
                const vIdx = type.variant.findIndex((t => t.typeName === vName));
                if (vIdx === -1) {
                    throw new Error(`Unknown variant type: ${vName}`);
                }
                const vType = type.variant[vIdx];
                ctx.codingPath.push({
                    field: `v${vIdx}`,
                    type: vType
                });
                const rv = [ vType.typeName, decodeObject(value, vType, ctx) ];
                ctx.codingPath.pop();
                if (abiType) {
                    rv[Resolved] = true;
                    return abiType.from(rv);
                } else {
                    return rv;
                }
            } else {
                if (!abiType) {
                    if (type.name === "any") {
                        return value;
                    }
                    throw new Error("Unknown type");
                }
                return abiType.from(value);
            }
        }
    }
    function defaultValue(type, ctx, seen = new Set) {
        if (type.isArray) {
            return [];
        }
        if (type.isOptional) {
            return null;
        }
        const abiType = ctx.types[type.name];
        if (abiType && abiType.abiDefault) {
            return abiType.abiDefault();
        }
        if (seen.has(type.name)) {
            throw new Error("Circular type reference");
        }
        seen.add(type.name);
        if (type.allFields) {
            const rv = {};
            for (const field of type.allFields) {
                ctx.codingPath.push({
                    field: field.name,
                    type: field.type
                });
                rv[field.name] = defaultValue(field.type, ctx, seen);
                ctx.codingPath.pop();
            }
            if (abiType) {
                rv[Resolved] = true;
                return abiType.from(rv);
            }
            return rv;
        }
        if (type.variant && type.variant.length > 0) {
            const rv = [ type.variant[0].typeName, defaultValue(type.variant[0], ctx) ];
            if (abiType) {
                rv[Resolved] = true;
                return abiType.from(rv);
            }
            return rv;
        }
        if (type.ref) {
            ctx.codingPath.push({
                field: "",
                type: type.ref
            });
            const rv = defaultValue(type.ref, ctx, seen);
            ctx.codingPath.pop();
            return rv;
        }
        throw new Error("Unable to determine default value");
    }
    class ABIDecoder {
        constructor(array) {
            this.array = array;
            this.pos = 0;
            this.textDecoder = new TextDecoder("utf-8", {
                fatal: true
            });
            this.metadata = {};
            this.data = new DataView(array.buffer, array.byteOffset, array.byteLength);
        }
        canRead(bytes = 1) {
            return !(this.pos + bytes > this.array.byteLength);
        }
        ensure(bytes) {
            if (!this.canRead(bytes)) {
                throw new Error("Read past end of buffer");
            }
        }
        setPosition(pos) {
            if (pos < 0 || pos > this.array.byteLength) {
                throw new Error("Invalid position");
            }
            this.pos = pos;
        }
        getPosition() {
            return this.pos;
        }
        advance(bytes) {
            this.ensure(bytes);
            this.pos += bytes;
        }
        readByte() {
            this.ensure(1);
            return this.array[this.pos++];
        }
        readFloat(byteWidth) {
            this.ensure(byteWidth);
            let rv;
            switch (byteWidth) {
              case 4:
                rv = this.data.getFloat32(this.pos, true);
                break;

              case 8:
                rv = this.data.getFloat64(this.pos, true);
                break;

              default:
                throw new Error("Invalid float size");
            }
            this.pos += byteWidth;
            return rv;
        }
        readVaruint32() {
            let v = 0;
            let bit = 0;
            for (;;) {
                const b = this.readByte();
                v |= (b & 127) << bit;
                bit += 7;
                if (!(b & 128)) {
                    break;
                }
            }
            return v >>> 0;
        }
        readVarint32() {
            const v = this.readVaruint32();
            if (v & 1) {
                return ~v >> 1 | 2147483648;
            } else {
                return v >>> 1;
            }
        }
        readArray(length) {
            this.ensure(length);
            const rv = this.array.subarray(this.pos, this.pos + length);
            this.pos += length;
            return rv;
        }
        readString() {
            const length = this.readVaruint32();
            return this.textDecoder.decode(this.readArray(length));
        }
    }
    ABIDecoder.__className = "ABIDecoder";
    class EncodingError extends Error {
        constructor(ctx, underlyingError) {
            const path = ctx.codingPath.map((({field: field, type: type}) => {
                if (typeof field === "number") {
                    return field;
                } else {
                    return `${field}<${type.typeName}>`;
                }
            })).join(".");
            super(`Encoding error at ${path}: ${underlyingError.message}`);
            this.stack = underlyingError.stack;
            this.ctx = ctx;
            this.underlyingError = underlyingError;
        }
    }
    EncodingError.__className = "EncodingError";
    function abiEncode(args) {
        let type;
        let typeName;
        if (typeof args.type === "string") {
            typeName = args.type;
        } else if (args.type && isTypeDescriptor(args.type)) {
            if (typeof args.type.type !== "string") {
                type = args.type.type;
            }
            typeName = abiTypeString(args.type);
        } else if (args.type && args.type.abiName !== undefined) {
            type = args.type;
            typeName = args.type.abiName;
        } else {
            type = getType(args.object);
            if (type) {
                typeName = type.abiName;
                if (Array.isArray(args.object)) {
                    typeName += "[]";
                }
            }
        }
        const customTypes = args.customTypes ? args.customTypes.slice() : [];
        if (type) {
            customTypes.unshift(type);
        } else if (typeName) {
            const rootName = new ABI.ResolvedType(typeName).name;
            type = customTypes.find((t => t.abiName === rootName));
        }
        let rootType;
        if (args.abi && typeName) {
            rootType = ABI.from(args.abi).resolveType(typeName);
        } else if (type) {
            const synthesized = synthesizeABI(type);
            rootType = synthesized.abi.resolveType(typeName || type.abiName);
            customTypes.push(...synthesized.types);
        } else if (typeName) {
            rootType = new ABI.ResolvedType(typeName);
        } else {
            throw new Error("Unable to determine the type of the object to be encoded. " + "To encode custom ABI types you must pass the type argument.");
        }
        const types = buildTypeLookup(customTypes);
        const encoder = args.encoder || new ABIEncoder;
        if (args.metadata) {
            encoder.metadata = args.metadata;
        }
        const ctx = {
            types: types,
            encoder: encoder,
            codingPath: [ {
                field: "root",
                type: rootType
            } ]
        };
        try {
            encodeAny(args.object, rootType, ctx);
        } catch (error) {
            throw new EncodingError(ctx, error);
        }
        return Bytes.from(encoder.getData());
    }
    function encodeAny(value, type, ctx) {
        const valueExists = value !== undefined && value !== null;
        if (type.isOptional) {
            ctx.encoder.writeByte(valueExists ? 1 : 0);
            if (!valueExists) {
                return;
            }
        }
        if (type.isArray) {
            if (!Array.isArray(value)) {
                throw new Error(`Expected array for: ${type.typeName}`);
            }
            const len = value.length;
            ctx.encoder.writeVaruint32(len);
            for (let i = 0; i < len; i++) {
                ctx.codingPath.push({
                    field: i,
                    type: type
                });
                encodeInner(value[i]);
                ctx.codingPath.pop();
            }
        } else {
            encodeInner(value);
        }
        function encodeInner(value) {
            const abiType = ctx.types[type.name];
            if (type.ref && !abiType) {
                encodeAny(value, type.ref, ctx);
                return;
            }
            if (!valueExists) {
                if (type.isExtension) {
                    return;
                }
                throw new Error(`Found ${value} for non-optional type: ${type.typeName}`);
            }
            if (abiType && abiType.toABI) {
                abiType.toABI(value, ctx.encoder);
            } else if (typeof value.toABI === "function" && value.constructor.abiName === type.name) {
                value.toABI(ctx.encoder);
            } else {
                if (type.fields) {
                    if (typeof value !== "object") {
                        throw new Error(`Expected object for: ${type.name}`);
                    }
                    const fields = type.allFields;
                    if (!fields) {
                        throw new Error("Invalid struct fields");
                    }
                    for (const field of fields) {
                        ctx.codingPath.push({
                            field: field.name,
                            type: field.type
                        });
                        encodeAny(value[field.name], field.type, ctx);
                        ctx.codingPath.pop();
                    }
                } else if (type.variant) {
                    let vName;
                    if (Array.isArray(value) && value.length === 2 && typeof value[0] === "string") {
                        vName = value[0];
                        value = value[1];
                    } else if (isInstanceOf(value, Variant)) {
                        vName = value.variantName;
                        value = value.value;
                    } else {
                        vName = getTypeName(value);
                    }
                    const vIdx = type.variant.findIndex((t => t.typeName === vName));
                    if (vIdx === -1) {
                        const types = type.variant.map((t => `'${t.typeName}'`)).join(", ");
                        throw new Error(`Unknown variant type '${vName}', expected one of ${types}`);
                    }
                    const vType = type.variant[vIdx];
                    ctx.encoder.writeVaruint32(vIdx);
                    ctx.codingPath.push({
                        field: `v${vIdx}`,
                        type: vType
                    });
                    encodeAny(value, vType, ctx);
                    ctx.codingPath.pop();
                } else {
                    if (!abiType) {
                        throw new Error(type.name === "any" ? "Unable to encode any type to binary" : "Unknown type");
                    }
                    const instance = abiType.from(value);
                    if (!instance.toABI) {
                        throw new Error(`Invalid type ${type.name}, no encoding methods implemented`);
                    }
                    instance.toABI(ctx.encoder);
                }
            }
        }
    }
    class ABIEncoder {
        constructor(pageSize = 1024) {
            this.pageSize = pageSize;
            this.pos = 0;
            this.textEncoder = new TextEncoder;
            this.metadata = {};
            const buffer = new ArrayBuffer(pageSize);
            this.data = new DataView(buffer);
            this.array = new Uint8Array(buffer);
        }
        ensure(bytes) {
            if (this.data.byteLength >= this.pos + bytes) {
                return;
            }
            const pages = Math.ceil(bytes / this.pageSize);
            const newSize = this.data.byteLength + this.pageSize * pages;
            const buffer = new ArrayBuffer(newSize);
            const data = new DataView(buffer);
            const array = new Uint8Array(buffer);
            array.set(this.array);
            this.data = data;
            this.array = array;
        }
        writeByte(byte) {
            this.ensure(1);
            this.array[this.pos++] = byte;
        }
        writeArray(bytes) {
            const size = bytes.length;
            this.ensure(size);
            this.array.set(bytes, this.pos);
            this.pos += size;
        }
        writeFloat(value, byteWidth) {
            this.ensure(byteWidth);
            switch (byteWidth) {
              case 4:
                this.data.setFloat32(this.pos, value, true);
                break;

              case 8:
                this.data.setFloat64(this.pos, value, true);
                break;

              default:
                throw new Error("Invalid float size");
            }
            this.pos += byteWidth;
        }
        writeVaruint32(v) {
            this.ensure(4);
            for (;;) {
                if (v >>> 7) {
                    this.array[this.pos++] = 128 | v & 127;
                    v = v >>> 7;
                } else {
                    this.array[this.pos++] = v;
                    break;
                }
            }
        }
        writeVarint32(v) {
            this.writeVaruint32(v << 1 ^ v >> 31);
        }
        writeString(v) {
            const data = this.textEncoder.encode(v);
            this.writeVaruint32(data.byteLength);
            this.writeArray(data);
        }
        getData() {
            return new Uint8Array(this.array.buffer, this.array.byteOffset, this.pos);
        }
        getBytes() {
            return new Bytes(this.getData());
        }
    }
    ABIEncoder.__className = "ABIEncoder";
    class Struct {
        constructor(object) {
            const self = this.constructor;
            for (const field of self.structFields) {
                this[field.name] = object[field.name];
            }
        }
        static from(value) {
            if (value[Resolved] === true) {
                return new this(value);
            }
            if (isInstanceOf(value, this)) {
                return value;
            }
            return abiDecode({
                object: value,
                type: this
            });
        }
        static get structFields() {
            const rv = [];
            const walk = t => {
                if (t.abiBase) {
                    walk(t.abiBase);
                }
                for (const field of t.abiFields || []) {
                    rv.push(field);
                }
            };
            walk(this);
            return rv;
        }
        equals(other) {
            const self = this.constructor;
            if (other.constructor && typeof other.constructor.abiName === "string" && other.constructor.abiName !== self.abiName) {
                return false;
            }
            return abiEncode({
                object: this
            }).equals(abiEncode({
                object: self.from(other)
            }));
        }
        toJSON() {
            const self = this.constructor;
            const rv = {};
            for (const field of self.structFields) {
                rv[field.name] = this[field.name];
            }
            return rv;
        }
    }
    Struct.abiName = "__struct";
    (function(Struct) {
        const FieldsOwner = Symbol("FieldsOwner");
        function type(name) {
            return function(struct) {
                struct.abiName = name;
                return struct;
            };
        }
        Struct.type = type;
        function field(type, options) {
            if (!options) options = {};
            return (target, name) => {
                const ctor = target.constructor;
                if (!ctor.abiFields) {
                    ctor.abiFields = [];
                    ctor.abiFields[FieldsOwner] = ctor;
                } else if (ctor.abiFields[FieldsOwner] !== ctor) {
                    ctor.abiBase = ctor.abiFields[FieldsOwner];
                    ctor.abiFields = [];
                    ctor.abiFields[FieldsOwner] = ctor;
                }
                ctor.abiFields.push({
                    ...options,
                    name: name,
                    type: type
                });
            };
        }
        Struct.field = field;
    })(Struct || (Struct = {}));
    function TypeAlias(name) {
        return function(typeAlias) {
            typeAlias.abiAlias = {
                type: Object.getPrototypeOf(typeAlias.prototype).constructor
            };
            typeAlias.abiName = name;
            return typeAlias;
        };
    }
    class Variant {
        constructor(variant) {
            const abiVariant = this.constructor.abiVariant;
            this.value = variant[1];
            const variantIdx = abiVariant.map(abiTypeString).findIndex((t => t === variant[0]));
            if (0 > variantIdx || abiVariant.length <= variantIdx) {
                throw new Error(`Unknown variant ${variant[0]}`);
            }
            this.variantIdx = variantIdx;
        }
        static from(object) {
            if (object[Resolved]) {
                return new this(object);
            }
            if (isInstanceOf(object, this)) {
                return object;
            }
            return abiDecode({
                object: object,
                type: this
            });
        }
        equals(other) {
            const self = this.constructor;
            const otherVariant = self.from(other);
            if (this.variantIdx !== otherVariant.variantIdx) {
                return false;
            }
            return abiEncode({
                object: this
            }).equals(abiEncode({
                object: otherVariant
            }));
        }
        get variantName() {
            const variant = this.constructor.abiVariant[this.variantIdx];
            return abiTypeString(variant);
        }
        toJSON() {
            return [ this.variantName, this.value ];
        }
    }
    Variant.abiName = "__variant";
    Variant.abiVariant = [];
    (function(Variant) {
        function type(name, types) {
            return function(variant) {
                variant.abiName = name;
                variant.abiVariant = types.map(toTypeDescriptor);
                return variant;
            };
        }
        Variant.type = type;
    })(Variant || (Variant = {}));
    class Float {
        constructor(value) {
            if (!Number.isFinite(value)) {
                throw new Error("Invalid number");
            }
            this.value = value;
        }
        static from(value) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            if (typeof value === "string") {
                value = Number.parseFloat(value);
            } else if (isInstanceOf(value, Float)) {
                value = value.value;
            }
            return new this(value);
        }
        static fromABI(decoder) {
            return new this(decoder.readFloat(this.byteWidth));
        }
        static abiDefault() {
            return this.from(0);
        }
        static random() {
            const bytes = secureRandom(this.byteWidth);
            const decoder = new ABIDecoder(bytes);
            return this.fromABI(decoder);
        }
        equals(other) {
            const self = this.constructor;
            return this.value === self.from(other).value;
        }
        toABI(encoder) {
            const self = this.constructor;
            encoder.writeFloat(this.value, self.byteWidth);
        }
        toString() {
            return this.value.toString();
        }
        toJSON() {
            return this.toString();
        }
    }
    Float.abiName = "__float";
    class Float32 extends Float {
        toString() {
            return this.value.toFixed(7);
        }
    }
    Float32.abiName = "float32";
    Float32.byteWidth = 4;
    class Float64 extends Float {}
    Float64.abiName = "float64";
    Float64.byteWidth = 8;
    class Float128 {
        constructor(data) {
            if (data.array.length !== 16) {
                throw new Error("Invalid float128");
            }
            this.data = data;
        }
        static from(value) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            if (typeof value === "string" && value.startsWith("0x")) {
                value = value.slice(2);
            }
            return new this(Bytes.from(value));
        }
        static fromABI(decoder) {
            return new this(new Bytes(decoder.readArray(this.byteWidth)));
        }
        static random() {
            const bytes = secureRandom(16);
            const decoder = new ABIDecoder(bytes);
            return this.fromABI(decoder);
        }
        equals(other) {
            const self = this.constructor;
            return this.data.equals(self.from(other).data);
        }
        toABI(encoder) {
            encoder.writeArray(this.data.array);
        }
        toString() {
            return "0x" + this.data.hexString;
        }
        toJSON() {
            return this.toString();
        }
    }
    Float128.abiName = "float128";
    Float128.byteWidth = 16;
    class Name {
        constructor(value) {
            this.value = value;
        }
        get rawValue() {
            return this.value;
        }
        static from(value) {
            if (isInstanceOf(value, Name)) {
                return value;
            } else if (typeof value === "string") {
                return new Name(stringToName(value));
            } else if (isInstanceOf(value, UInt64)) {
                return new Name(value);
            } else {
                throw new Error("Invalid name");
            }
        }
        static fromABI(decoder) {
            return new Name(UInt64.fromABI(decoder));
        }
        static abiDefault() {
            return new this(UInt64.from(0));
        }
        equals(other) {
            return this.value.equals(Name.from(other).value);
        }
        toString() {
            return nameToString(this.value);
        }
        toABI(encoder) {
            this.value.toABI(encoder);
        }
        toJSON() {
            return this.toString();
        }
    }
    Name.abiName = "name";
    Name.pattern = /^[a-z1-5.]{0,13}$/;
    function stringToName(s) {
        function charToSymbol(c) {
            if (c >= "a".charCodeAt(0) && c <= "z".charCodeAt(0)) {
                return c - "a".charCodeAt(0) + 6;
            }
            if (c >= "1".charCodeAt(0) && c <= "5".charCodeAt(0)) {
                return c - "1".charCodeAt(0) + 1;
            }
            return 0;
        }
        const a = new Uint8Array(8);
        let bit = 63;
        for (let i = 0; i < s.length; ++i) {
            let c = charToSymbol(s.charCodeAt(i));
            if (bit < 5) {
                c = c << 1;
            }
            for (let j = 4; j >= 0; --j) {
                if (bit >= 0) {
                    a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
                    --bit;
                }
            }
        }
        return UInt64.from(a);
    }
    function nameToString(n) {
        const a = n.value.toArray("le", 8);
        let result = "";
        for (let bit = 63; bit >= 0; ) {
            let c = 0;
            for (let i = 0; i < 5; ++i) {
                if (bit >= 0) {
                    c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
                    --bit;
                }
            }
            if (c >= 6) {
                result += String.fromCharCode(c + "a".charCodeAt(0) - 6);
            } else if (c >= 1) {
                result += String.fromCharCode(c + "1".charCodeAt(0) - 1);
            } else {
                result += ".";
            }
        }
        while (result.endsWith(".")) {
            result = result.substr(0, result.length - 1);
        }
        return result;
    }
    class TimePointBase {
        static from(value) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            if (isInstanceOf(value, TimePointBase)) {
                return this.fromMilliseconds(value.toMilliseconds());
            }
            if (isInstanceOf(value, Date)) {
                return this.fromDate(value);
            }
            if (typeof value === "string") {
                return this.fromString(value);
            }
            return this.fromInteger(value);
        }
        static fromString(string) {
            const value = Date.parse(string + "Z");
            if (!Number.isFinite(value)) {
                throw new Error("Invalid date string");
            }
            return this.fromMilliseconds(value);
        }
        static fromDate(date) {
            return this.fromMilliseconds(date.getTime());
        }
        static abiDefault() {
            return this.from(0);
        }
        toABI(encoder) {
            const self = this;
            self.value.toABI(encoder);
        }
        equals(other) {
            const self = this.constructor;
            return this.toMilliseconds() === self.from(other).toMilliseconds();
        }
        toMilliseconds() {
            throw new Error("Not implemented");
        }
        toDate() {
            return new Date(this.toMilliseconds());
        }
        toJSON() {
            return this.toString();
        }
    }
    TimePointBase.abiName = "__time_point_base";
    class TimePoint extends TimePointBase {
        constructor(value) {
            super();
            this.value = value;
        }
        static fromMilliseconds(ms) {
            return new this(Int64.from(Math.round(ms * 1e3)));
        }
        static fromInteger(value) {
            return new this(Int64.from(value));
        }
        static fromABI(decoder) {
            return new this(Int64.fromABI(decoder));
        }
        toString() {
            return this.toDate().toISOString().slice(0, -1);
        }
        toMilliseconds() {
            return Number(this.value.dividing(1e3, "round"));
        }
    }
    TimePoint.abiName = "time_point";
    class TimePointSec extends TimePointBase {
        constructor(value) {
            super();
            this.value = value;
        }
        static fromMilliseconds(ms) {
            return new this(UInt32.from(Math.round(ms / 1e3)));
        }
        static fromInteger(value) {
            return new this(UInt32.from(value));
        }
        static fromABI(decoder) {
            return new this(UInt32.fromABI(decoder));
        }
        toString() {
            return this.toDate().toISOString().slice(0, -5);
        }
        toMilliseconds() {
            return Number(this.value.cast(UInt64).multiplying(1e3));
        }
    }
    TimePointSec.abiName = "time_point_sec";
    class BlockTimestamp extends TimePointBase {
        constructor(value) {
            super();
            this.value = value;
        }
        static fromMilliseconds(ms) {
            return new this(UInt32.from(Math.round((ms - 9466848e5) / 500)));
        }
        static fromInteger(value) {
            return new this(UInt32.from(value));
        }
        static fromABI(decoder) {
            return new this(UInt32.fromABI(decoder));
        }
        toString() {
            return this.toDate().toISOString().slice(0, -1);
        }
        toMilliseconds() {
            return Number(this.value.cast(UInt64).multiplying(500).adding(9466848e5));
        }
    }
    BlockTimestamp.abiName = "block_timestamp_type";
    class ABI {
        constructor(args) {
            this.version = args.version || ABI.version;
            this.types = args.types || [];
            this.variants = args.variants || [];
            this.structs = args.structs || [];
            this.actions = args.actions || [];
            this.tables = args.tables || [];
            this.ricardian_clauses = args.ricardian_clauses || [];
        }
        static from(value) {
            if (isInstanceOf(value, ABI)) {
                return value;
            }
            if (typeof value === "string") {
                return new ABI(JSON.parse(value));
            }
            return new ABI(value);
        }
        static fromABI(decoder) {
            const version = decoder.readString();
            const types = [];
            const numTypes = decoder.readVaruint32();
            for (let i = 0; i < numTypes; i++) {
                types.push({
                    new_type_name: decoder.readString(),
                    type: decoder.readString()
                });
            }
            const structs = [];
            const numStructs = decoder.readVaruint32();
            for (let i = 0; i < numStructs; i++) {
                const name = decoder.readString();
                const base = decoder.readString();
                const numFields = decoder.readVaruint32();
                const fields = [];
                for (let j = 0; j < numFields; j++) {
                    fields.push({
                        name: decoder.readString(),
                        type: decoder.readString()
                    });
                }
                structs.push({
                    base: base,
                    name: name,
                    fields: fields
                });
            }
            const actions = [];
            const numActions = decoder.readVaruint32();
            for (let i = 0; i < numActions; i++) {
                const name = Name.fromABI(decoder);
                const type = decoder.readString();
                const ricardian_contract = decoder.readString();
                actions.push({
                    name: name,
                    type: type,
                    ricardian_contract: ricardian_contract
                });
            }
            const tables = [];
            const numTables = decoder.readVaruint32();
            for (let i = 0; i < numTables; i++) {
                const name = Name.fromABI(decoder);
                const index_type = decoder.readString();
                const key_names = [];
                const numKeyNames = decoder.readVaruint32();
                for (let j = 0; j < numKeyNames; j++) {
                    key_names.push(decoder.readString());
                }
                const key_types = [];
                const numKeyTypes = decoder.readVaruint32();
                for (let j = 0; j < numKeyTypes; j++) {
                    key_types.push(decoder.readString());
                }
                const type = decoder.readString();
                tables.push({
                    name: name,
                    index_type: index_type,
                    key_names: key_names,
                    key_types: key_types,
                    type: type
                });
            }
            const ricardian_clauses = [];
            const numClauses = decoder.readVaruint32();
            for (let i = 0; i < numClauses; i++) {
                const id = decoder.readString();
                const body = decoder.readString();
                ricardian_clauses.push({
                    id: id,
                    body: body
                });
            }
            const numErrors = decoder.readVaruint32();
            for (let i = 0; i < numErrors; i++) {
                decoder.advance(8);
                decoder.advance(decoder.readVaruint32());
            }
            const numExtensions = decoder.readVaruint32();
            for (let i = 0; i < numExtensions; i++) {
                decoder.advance(2);
                decoder.advance(decoder.readVaruint32());
            }
            const variants = [];
            if (decoder.canRead()) {
                const numVariants = decoder.readVaruint32();
                for (let i = 0; i < numVariants; i++) {
                    const name = decoder.readString();
                    const types = [];
                    const numTypes = decoder.readVaruint32();
                    for (let j = 0; j < numTypes; j++) {
                        types.push(decoder.readString());
                    }
                    variants.push({
                        name: name,
                        types: types
                    });
                }
            }
            return new ABI({
                version: version,
                types: types,
                structs: structs,
                actions: actions,
                tables: tables,
                ricardian_clauses: ricardian_clauses,
                variants: variants
            });
        }
        toABI(encoder) {
            encoder.writeString(this.version);
            encoder.writeVaruint32(this.types.length);
            for (const type of this.types) {
                encoder.writeString(type.new_type_name);
                encoder.writeString(type.type);
            }
            encoder.writeVaruint32(this.structs.length);
            for (const struct of this.structs) {
                encoder.writeString(struct.name);
                encoder.writeString(struct.base);
                encoder.writeVaruint32(struct.fields.length);
                for (const field of struct.fields) {
                    encoder.writeString(field.name);
                    encoder.writeString(field.type);
                }
            }
            encoder.writeVaruint32(this.actions.length);
            for (const action of this.actions) {
                Name.from(action.name).toABI(encoder);
                encoder.writeString(action.type);
                encoder.writeString(action.ricardian_contract);
            }
            encoder.writeVaruint32(this.tables.length);
            for (const table of this.tables) {
                Name.from(table.name).toABI(encoder);
                encoder.writeString(table.index_type);
                encoder.writeVaruint32(table.key_names.length);
                for (const key of table.key_names) {
                    encoder.writeString(key);
                }
                encoder.writeVaruint32(table.key_types.length);
                for (const key of table.key_types) {
                    encoder.writeString(key);
                }
                encoder.writeString(table.type);
            }
            encoder.writeVaruint32(this.ricardian_clauses.length);
            for (const clause of this.ricardian_clauses) {
                encoder.writeString(clause.id);
                encoder.writeString(clause.body);
            }
            encoder.writeVaruint32(0);
            encoder.writeVaruint32(0);
            encoder.writeVaruint32(this.variants.length);
            for (const variant of this.variants) {
                encoder.writeString(variant.name);
                encoder.writeVaruint32(variant.types.length);
                for (const type of variant.types) {
                    encoder.writeString(type);
                }
            }
        }
        resolveType(name) {
            const types = {};
            return this.resolve({
                name: name,
                types: types
            }, {
                id: 0
            });
        }
        resolveAll() {
            const types = {};
            const ctx = {
                id: 0
            };
            return {
                types: this.types.map((t => this.resolve({
                    name: t.new_type_name,
                    types: types
                }, ctx))),
                variants: this.variants.map((t => this.resolve({
                    name: t.name,
                    types: types
                }, ctx))),
                structs: this.structs.map((t => this.resolve({
                    name: t.name,
                    types: types
                }, ctx)))
            };
        }
        resolve({name: name, types: types}, ctx) {
            const existing = types[name];
            if (existing) {
                return existing;
            }
            const type = new ABI.ResolvedType(name, ++ctx.id);
            types[type.typeName] = type;
            const alias = this.types.find((typeDef => typeDef.new_type_name == type.name));
            if (alias) {
                type.ref = this.resolve({
                    name: alias.type,
                    types: types
                }, ctx);
                return type;
            }
            const struct = this.getStruct(type.name);
            if (struct) {
                if (struct.base) {
                    type.base = this.resolve({
                        name: struct.base,
                        types: types
                    }, ctx);
                }
                type.fields = struct.fields.map((field => ({
                    name: field.name,
                    type: this.resolve({
                        name: field.type,
                        types: types
                    }, ctx)
                })));
                return type;
            }
            const variant = this.getVariant(type.name);
            if (variant) {
                type.variant = variant.types.map((name => this.resolve({
                    name: name,
                    types: types
                }, ctx)));
                return type;
            }
            return type;
        }
        getStruct(name) {
            return this.structs.find((struct => struct.name == name));
        }
        getVariant(name) {
            return this.variants.find((variant => variant.name == name));
        }
        getActionType(actionName) {
            const name = Name.from(actionName).toString();
            const action = this.actions.find((a => a.name.toString() === name));
            if (action) {
                return action.type;
            }
        }
        equals(other) {
            const o = ABI.from(other);
            if (this.version != o.version || this.types.length != o.types.length || this.structs.length != o.structs.length || this.actions.length != o.actions.length || this.tables.length != o.tables.length || this.ricardian_clauses.length != o.ricardian_clauses.length || this.variants.length != o.variants.length) {
                return false;
            }
            return abiEncode({
                object: this
            }).equals(abiEncode({
                object: o
            }));
        }
        toJSON() {
            return {
                version: this.version,
                types: this.types,
                structs: this.structs,
                actions: this.actions,
                tables: this.tables,
                ricardian_clauses: this.ricardian_clauses,
                error_messages: [],
                abi_extensions: [],
                variants: this.variants
            };
        }
    }
    ABI.abiName = "abi";
    ABI.version = "eosio::abi/1.1";
    (function(ABI) {
        class ResolvedType {
            constructor(fullName, id = 0) {
                let name = fullName;
                if (name.endsWith("$")) {
                    name = name.slice(0, -1);
                    this.isExtension = true;
                } else {
                    this.isExtension = false;
                }
                if (name.endsWith("?")) {
                    name = name.slice(0, -1);
                    this.isOptional = true;
                } else {
                    this.isOptional = false;
                }
                if (name.endsWith("[]")) {
                    name = name.slice(0, -2);
                    this.isArray = true;
                } else {
                    this.isArray = false;
                }
                this.id = id;
                this.name = name;
            }
            get typeName() {
                let rv = this.name;
                if (this.isArray) {
                    rv += "[]";
                }
                if (this.isOptional) {
                    rv += "?";
                }
                if (this.isExtension) {
                    rv += "$";
                }
                return rv;
            }
            get allFields() {
                let current = this;
                const rv = [];
                const seen = new Set;
                do {
                    if (!current.fields) {
                        return;
                    }
                    if (seen.has(current.name)) {
                        return;
                    }
                    for (let i = current.fields.length - 1; i >= 0; i--) {
                        rv.unshift(current.fields[i]);
                    }
                    seen.add(current.name);
                    current = current.base;
                } while (current !== undefined);
                return rv;
            }
        }
        ABI.ResolvedType = ResolvedType;
    })(ABI || (ABI = {}));
    class Asset {
        constructor(units, symbol) {
            this.units = units;
            this.symbol = symbol;
        }
        static from(value, symbol) {
            if (isInstanceOf(value, Asset)) {
                return value;
            }
            switch (typeof value) {
              case "number":
                if (!symbol) {
                    throw new Error("Symbol is required when creating Asset from number");
                }
                return this.fromFloat(value, symbol);

              case "string":
                return this.fromString(value);

              default:
                throw new Error("Invalid asset");
            }
        }
        static fromString(value) {
            const parts = (typeof value === "string" ? value : "").split(" ");
            if (parts.length !== 2) {
                throw new Error("Invalid asset string");
            }
            const amount = parts[0].replace(".", "");
            const precision = (parts[0].split(".")[1] || "").length;
            const symbol = Asset.Symbol.fromParts(parts[1], precision);
            return new Asset(Int64.from(amount), symbol);
        }
        static fromFloat(value, symbol) {
            const s = Asset.Symbol.from(symbol);
            return new Asset(s.convertFloat(value), s);
        }
        static fromUnits(value, symbol) {
            return new Asset(Int64.from(value), Asset.Symbol.from(symbol));
        }
        static fromABI(decoder) {
            const units = Int64.fromABI(decoder);
            const symbol = Asset.Symbol.fromABI(decoder);
            return new Asset(units, symbol);
        }
        static abiDefault() {
            return new this(Int64.from(0), Asset.Symbol.abiDefault());
        }
        equals(other) {
            const {symbol: symbol, units: units} = Asset.from(other);
            return this.symbol.value.equals(symbol.value) && this.units.equals(units);
        }
        get value() {
            return this.symbol.convertUnits(this.units);
        }
        set value(newValue) {
            this.units = this.symbol.convertFloat(newValue);
        }
        toABI(encoder) {
            this.units.toABI(encoder);
            this.symbol.toABI(encoder);
        }
        toString() {
            const digits = this.units.toString().split("");
            let negative = false;
            if (digits[0] === "-") {
                negative = true;
                digits.shift();
            }
            const p = this.symbol.precision;
            while (digits.length <= p) {
                digits.unshift("0");
            }
            if (p > 0) {
                digits.splice(digits.length - p, 0, ".");
            }
            let rv = digits.join("");
            if (negative) {
                rv = "-" + rv;
            }
            return rv + " " + this.symbol.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    Asset.abiName = "asset";
    (function(Asset) {
        class Symbol {
            constructor(value) {
                if (toSymbolPrecision(value) > Symbol.maxPrecision) {
                    throw new Error("Invalid asset symbol, precision too large");
                }
                if (!Symbol.symbolNamePattern.test(toSymbolName(value))) {
                    throw new Error("Invalid asset symbol, name must be uppercase A-Z");
                }
                this.value = value;
            }
            static from(value) {
                if (isInstanceOf(value, Symbol)) {
                    return value;
                }
                if (isInstanceOf(value, UInt64)) {
                    return new Symbol(value);
                }
                const parts = value.split(",");
                if (parts.length !== 2) {
                    throw new Error("Invalid symbol string");
                }
                const precision = Number.parseInt(parts[0]);
                return Symbol.fromParts(parts[1], precision);
            }
            static fromParts(name, precision) {
                return new Symbol(toRawSymbol(name, precision));
            }
            static fromABI(decoder) {
                return new Symbol(UInt64.fromABI(decoder));
            }
            static abiDefault() {
                return this.from("4,SYS");
            }
            equals(other) {
                return this.value.equals(Symbol.from(other).value);
            }
            get name() {
                return toSymbolName(this.value);
            }
            get precision() {
                return toSymbolPrecision(this.value);
            }
            get code() {
                return new SymbolCode(UInt64.from(this.value.value.clone().iushrn(8)));
            }
            toABI(encoder) {
                this.value.toABI(encoder);
            }
            convertUnits(units) {
                return units.value.toNumber() / Math.pow(10, this.precision);
            }
            convertFloat(float) {
                return Int64.from(float.toFixed(this.precision).replace(".", ""));
            }
            toString() {
                return `${this.precision},${this.name}`;
            }
            toJSON() {
                return this.toString();
            }
        }
        Symbol.abiName = "symbol";
        Symbol.symbolNamePattern = /^[A-Z]{1,7}$/;
        Symbol.maxPrecision = 18;
        Asset.Symbol = Symbol;
        class SymbolCode {
            constructor(value) {
                this.value = value;
            }
            static from(value) {
                if (isInstanceOf(value, SymbolCode)) {
                    return value;
                }
                if (typeof value === "string") {
                    value = UInt64.from(toRawSymbolCode(value));
                }
                return new this(UInt64.from(value));
            }
            static fromABI(decoder) {
                return new SymbolCode(UInt64.fromABI(decoder));
            }
            static abiDefault() {
                return this.from("SYS");
            }
            equals(other) {
                return this.value.equals(SymbolCode.from(other).value);
            }
            toABI(encoder) {
                this.value.toABI(encoder);
            }
            toString() {
                return charsToSymbolName(this.value.value.toArray("be"));
            }
            toJSON() {
                return this.toString();
            }
        }
        SymbolCode.abiName = "symbol_code";
        Asset.SymbolCode = SymbolCode;
    })(Asset || (Asset = {}));
    class ExtendedAsset {
        constructor(quantity, contract) {
            this.quantity = quantity;
            this.contract = contract;
        }
        static from(value) {
            if (isInstanceOf(value, ExtendedAsset)) {
                return value;
            }
            return new this(Asset.from(value.quantity), Name.from(value.contract));
        }
        static fromABI(decoder) {
            return new ExtendedAsset(Asset.fromABI(decoder), Name.fromABI(decoder));
        }
        equals(other) {
            return this.quantity.equals(other.quantity) && this.contract.equals(other.contract);
        }
        toABI(encoder) {
            this.quantity.toABI(encoder);
            this.contract.toABI(encoder);
        }
        toJSON() {
            return {
                quantity: this.quantity,
                contract: this.contract
            };
        }
    }
    ExtendedAsset.abiName = "extended_asset";
    function toSymbolPrecision(rawSymbol) {
        return rawSymbol.value.and(UInt64.from(255).value).toNumber();
    }
    function toSymbolName(rawSymbol) {
        const chars = rawSymbol.value.toArray("be").slice(0, -1);
        return charsToSymbolName(chars);
    }
    function charsToSymbolName(chars) {
        return chars.map((char => String.fromCharCode(char))).reverse().join("");
    }
    function toRawSymbol(name, precision) {
        const code = toRawSymbolCode(name);
        const bytes = new Uint8Array(code.length + 1);
        bytes[0] = precision;
        bytes.set(code, 1);
        return UInt64.from(bytes);
    }
    function toRawSymbolCode(name) {
        const length = Math.min(name.length, 7);
        const bytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
            bytes[i] = name.charCodeAt(i);
        }
        return bytes;
    }
    var Base58;
    (function(Base58) {
        let ErrorCode;
        (function(ErrorCode) {
            ErrorCode["E_CHECKSUM"] = "E_CHECKSUM";
            ErrorCode["E_INVALID"] = "E_INVALID";
        })(ErrorCode = Base58.ErrorCode || (Base58.ErrorCode = {}));
        class DecodingError extends Error {
            constructor(message, code, info = {}) {
                super(message);
                this.code = code;
                this.info = info;
            }
        }
        DecodingError.__className = "DecodingError";
        Base58.DecodingError = DecodingError;
        const chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        const charMap = new Int16Array(255).fill(-1);
        for (let i = 0; i < 58; ++i) {
            charMap[chars.charCodeAt(i)] = i;
        }
        function decode(s, size) {
            if (size == null) {
                return decodeVar(s);
            }
            const result = new Uint8Array(size);
            for (let i = 0; i < s.length; ++i) {
                let carry = charMap[s.charCodeAt(i)];
                if (carry < 0) {
                    throw new DecodingError("Invalid Base58 character encountered", ErrorCode.E_INVALID, {
                        char: s[i]
                    });
                }
                for (let j = 0; j < size; ++j) {
                    const x = result[j] * 58 + carry;
                    result[j] = x;
                    carry = x >> 8;
                }
                if (carry) {
                    throw new DecodingError("Base58 value is out of range", ErrorCode.E_INVALID);
                }
            }
            result.reverse();
            return new Bytes(result);
        }
        Base58.decode = decode;
        function decodeCheck(encoded, size) {
            const decoded = decode(encoded, size != null ? size + 4 : size);
            const data = decoded.array.subarray(0, -4);
            const expected = decoded.array.subarray(-4);
            const actual = dsha256Checksum(data);
            if (!arrayEquals(expected, actual)) {
                throw new DecodingError("Checksum mismatch", ErrorCode.E_CHECKSUM, {
                    actual: actual,
                    expected: expected,
                    data: data,
                    hash: "double_sha256"
                });
            }
            return new Bytes(data);
        }
        Base58.decodeCheck = decodeCheck;
        function decodeRipemd160Check(encoded, size, suffix) {
            const decoded = decode(encoded, size != null ? size + 4 : size);
            const data = decoded.array.subarray(0, -4);
            const expected = decoded.array.subarray(-4);
            const actual = ripemd160Checksum(data, suffix);
            if (!arrayEquals(expected, actual)) {
                throw new DecodingError("Checksum mismatch", ErrorCode.E_CHECKSUM, {
                    actual: actual,
                    expected: expected,
                    data: data,
                    hash: "ripemd160"
                });
            }
            return new Bytes(data);
        }
        Base58.decodeRipemd160Check = decodeRipemd160Check;
        function encode(data) {
            data = Bytes.from(data);
            const result = [];
            for (const byte of data.array) {
                let carry = byte;
                for (let j = 0; j < result.length; ++j) {
                    const x = (charMap[result[j]] << 8) + carry;
                    result[j] = chars.charCodeAt(x % 58);
                    carry = x / 58 | 0;
                }
                while (carry) {
                    result.push(chars.charCodeAt(carry % 58));
                    carry = carry / 58 | 0;
                }
            }
            for (const byte of data.array) {
                if (byte) {
                    break;
                } else {
                    result.push("1".charCodeAt(0));
                }
            }
            result.reverse();
            return String.fromCharCode(...result);
        }
        Base58.encode = encode;
        function encodeCheck(data) {
            data = Bytes.from(data);
            data = data.appending(dsha256Checksum(data.array));
            return encode(data);
        }
        Base58.encodeCheck = encodeCheck;
        function encodeRipemd160Check(data, suffix) {
            data = Bytes.from(data);
            data = data.appending(ripemd160Checksum(data.array, suffix));
            return encode(data);
        }
        Base58.encodeRipemd160Check = encodeRipemd160Check;
        function decodeVar(s) {
            const result = [];
            for (let i = 0; i < s.length; ++i) {
                let carry = charMap[s.charCodeAt(i)];
                if (carry < 0) {
                    throw new DecodingError("Invalid Base58 character encountered", ErrorCode.E_INVALID, {
                        char: s[i]
                    });
                }
                for (let j = 0; j < result.length; ++j) {
                    const x = result[j] * 58 + carry;
                    result[j] = x & 255;
                    carry = x >> 8;
                }
                if (carry) {
                    result.push(carry);
                }
            }
            for (const ch of s) {
                if (ch === "1") {
                    result.push(0);
                } else {
                    break;
                }
            }
            result.reverse();
            return Bytes.from(result);
        }
        function ripemd160Checksum(data, suffix) {
            const hash = hash$2.ripemd160().update(data);
            if (suffix) {
                hash.update(suffix);
            }
            return new Uint8Array(hash.digest().slice(0, 4));
        }
        function dsha256Checksum(data) {
            const round1 = hash$2.sha256().update(data).digest();
            const round2 = hash$2.sha256().update(round1).digest();
            return new Uint8Array(round2.slice(0, 4));
        }
    })(Base58 || (Base58 = {}));
    class PublicKey {
        constructor(type, data) {
            this.type = type;
            this.data = data;
        }
        static from(value) {
            if (isInstanceOf(value, PublicKey)) {
                return value;
            }
            if (typeof value === "object" && value.type && value.compressed) {
                return new PublicKey(KeyType.from(value.type), new Bytes(value.compressed));
            }
            if (typeof value !== "string") {
                throw new Error("Invalid public key");
            }
            if (value.startsWith("PUB_")) {
                const parts = value.split("_");
                if (parts.length !== 3) {
                    throw new Error("Invalid public key string");
                }
                const type = KeyType.from(parts[1]);
                const size = type === KeyType.K1 || type === KeyType.R1 ? 33 : undefined;
                const data = Base58.decodeRipemd160Check(parts[2], size, type);
                return new PublicKey(type, data);
            } else if (value.length >= 50) {
                const data = Base58.decodeRipemd160Check(value.slice(-50));
                return new PublicKey(KeyType.K1, data);
            } else {
                throw new Error("Invalid public key string");
            }
        }
        static fromABI(decoder) {
            const type = KeyType.from(decoder.readByte());
            if (type == KeyType.WA) {
                const startPos = decoder.getPosition();
                decoder.advance(33);
                decoder.advance(1);
                decoder.advance(decoder.readVaruint32());
                const len = decoder.getPosition() - startPos;
                decoder.setPosition(startPos);
                const data = Bytes.from(decoder.readArray(len));
                return new PublicKey(KeyType.WA, data);
            }
            return new PublicKey(type, new Bytes(decoder.readArray(33)));
        }
        equals(other) {
            const otherKey = PublicKey.from(other);
            return this.type === otherKey.type && this.data.equals(otherKey.data);
        }
        toLegacyString(prefix = "EOS") {
            if (this.type !== KeyType.K1) {
                throw new Error("Unable to create legacy formatted string for non-K1 key");
            }
            return `${prefix}${Base58.encodeRipemd160Check(this.data)}`;
        }
        toString() {
            return `PUB_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;
        }
        toABI(encoder) {
            encoder.writeByte(KeyType.indexFor(this.type));
            encoder.writeArray(this.data.array);
        }
        toJSON() {
            return this.toString();
        }
    }
    PublicKey.abiName = "public_key";
    const curves = {};
    function getCurve(type) {
        let rv = curves[type];
        if (!rv) {
            if (type === "K1") {
                rv = curves[type] = new elliptic.ec("secp256k1");
            } else if (type === "R1") {
                rv = curves[type] = new elliptic.ec("p256");
            } else {
                throw new Error(`Unknown curve type: ${type}`);
            }
        }
        return rv;
    }
    function recover(signature, message, type) {
        const curve = getCurve(type);
        const recid = signature[0] - 31;
        const r = signature.subarray(1, 33);
        const s = signature.subarray(33);
        const point = curve.recoverPubKey(message, {
            r: r,
            s: s
        }, recid);
        return new Uint8Array(point.encodeCompressed());
    }
    function verify(signature, message, pubkey, type) {
        const curve = getCurve(type);
        const r = signature.subarray(1, 33);
        const s = signature.subarray(33);
        return curve.verify(message, {
            r: r,
            s: s
        }, pubkey);
    }
    class Signature {
        constructor(type, data) {
            this.type = type;
            this.data = data;
        }
        static from(value) {
            if (isInstanceOf(value, Signature)) {
                return value;
            }
            if (typeof value === "object" && value.r && value.s) {
                const data = new Uint8Array(1 + 32 + 32);
                let recid = value.recid;
                const type = KeyType.from(value.type);
                if (value.type === KeyType.K1 || value.type === KeyType.R1) {
                    recid += 31;
                }
                data[0] = recid;
                data.set(value.r, 1);
                data.set(value.s, 33);
                return new Signature(type, new Bytes(data));
            }
            if (typeof value !== "string") {
                throw new Error("Invalid signature");
            }
            if (value.startsWith("SIG_")) {
                const parts = value.split("_");
                if (parts.length !== 3) {
                    throw new Error("Invalid signature string");
                }
                const type = KeyType.from(parts[1]);
                const size = type === KeyType.K1 || type === KeyType.R1 ? 65 : undefined;
                const data = Base58.decodeRipemd160Check(parts[2], size, type);
                return new Signature(type, data);
            } else {
                throw new Error("Invalid signature string");
            }
        }
        static fromABI(decoder) {
            const type = KeyType.from(decoder.readByte());
            if (type === KeyType.WA) {
                const startPos = decoder.getPosition();
                decoder.advance(65);
                decoder.advance(decoder.readVaruint32());
                decoder.advance(decoder.readVaruint32());
                const len = decoder.getPosition() - startPos;
                decoder.setPosition(startPos);
                const data = Bytes.from(decoder.readArray(len));
                return new Signature(KeyType.WA, data);
            }
            return new Signature(type, new Bytes(decoder.readArray(65)));
        }
        equals(other) {
            const otherSig = Signature.from(other);
            return this.type === otherSig.type && this.data.equals(otherSig.data);
        }
        recoverDigest(digest) {
            digest = Checksum256.from(digest);
            const compressed = recover(this.data.array, digest.array, this.type);
            return PublicKey.from({
                compressed: compressed,
                type: this.type
            });
        }
        recoverMessage(message) {
            return this.recoverDigest(Checksum256.hash(message));
        }
        verifyDigest(digest, publicKey) {
            digest = Checksum256.from(digest);
            return verify(this.data.array, digest.array, publicKey.data.array, this.type);
        }
        verifyMessage(message, publicKey) {
            return this.verifyDigest(Checksum256.hash(message), publicKey);
        }
        toString() {
            return `SIG_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;
        }
        toABI(encoder) {
            encoder.writeByte(KeyType.indexFor(this.type));
            encoder.writeArray(this.data.array);
        }
        toJSON() {
            return this.toString();
        }
    }
    Signature.abiName = "signature";
    function getPublic(privkey, type) {
        const curve = getCurve(type);
        const key = curve.keyFromPrivate(privkey);
        const point = key.getPublic();
        return new Uint8Array(point.encodeCompressed());
    }
    function sharedSecret(privkey, pubkey, type) {
        const curve = getCurve(type);
        const priv = curve.keyFromPrivate(privkey);
        const pub = curve.keyFromPublic(pubkey).getPublic();
        return priv.derive(pub).toArrayLike(Uint8Array, "be");
    }
    function sign$1(secret, message, type) {
        const curve = getCurve(type);
        const key = curve.keyFromPrivate(secret);
        let sig;
        let r;
        let s;
        if (type === "K1") {
            let attempt = 1;
            do {
                sig = key.sign(message, {
                    canonical: true,
                    pers: [ attempt++ ]
                });
                r = sig.r.toArrayLike(Uint8Array, "be", 32);
                s = sig.s.toArrayLike(Uint8Array, "be", 32);
            } while (!isCanonical(r, s));
        } else {
            sig = key.sign(message, {
                canonical: true
            });
            r = sig.r.toArrayLike(Uint8Array, "be", 32);
            s = sig.s.toArrayLike(Uint8Array, "be", 32);
        }
        return {
            type: type,
            r: r,
            s: s,
            recid: sig.recoveryParam || 0
        };
    }
    function isCanonical(r, s) {
        return !(r[0] & 128) && !(r[0] === 0 && !(r[1] & 128)) && !(s[0] & 128) && !(s[0] === 0 && !(s[1] & 128));
    }
    function generate(type) {
        const curve = getCurve(type);
        const privkey = curve.genKeyPair().getPrivate();
        return privkey.toArrayLike(Uint8Array, "be", 32);
    }
    class PrivateKey {
        constructor(type, data) {
            if ((type === KeyType.K1 || type === KeyType.R1) && data.length !== 32) {
                throw new Error("Invalid private key length");
            }
            this.type = type;
            this.data = data;
        }
        static from(value) {
            if (isInstanceOf(value, PrivateKey)) {
                return value;
            } else {
                return this.fromString(value);
            }
        }
        static fromString(string, ignoreChecksumError = false) {
            try {
                const {type: type, data: data} = decodeKey(string);
                return new this(type, data);
            } catch (error) {
                error.message = `Invalid private key (${error.message})`;
                if (ignoreChecksumError && isInstanceOf(error, Base58.DecodingError) && error.code === Base58.ErrorCode.E_CHECKSUM) {
                    const type = string.startsWith("PVT_R1") ? KeyType.R1 : KeyType.K1;
                    const data = new Bytes(error.info.data);
                    if (data.length === 33) {
                        data.dropFirst();
                    }
                    data.zeropad(32, true);
                    return new this(type, data);
                }
                throw error;
            }
        }
        static generate(type) {
            return new PrivateKey(KeyType.from(type), new Bytes(generate(type)));
        }
        signDigest(digest) {
            digest = Checksum256.from(digest);
            return Signature.from(sign$1(this.data.array, digest.array, this.type));
        }
        signMessage(message) {
            return this.signDigest(Checksum256.hash(message));
        }
        sharedSecret(publicKey) {
            const shared = sharedSecret(this.data.array, publicKey.data.array, this.type);
            return Checksum512.hash(shared);
        }
        toPublic() {
            const compressed = getPublic(this.data.array, this.type);
            return PublicKey.from({
                compressed: compressed,
                type: this.type
            });
        }
        toWif() {
            if (this.type !== KeyType.K1) {
                throw new Error("Unable to generate WIF for non-k1 key");
            }
            return Base58.encodeCheck(Bytes.from([ 128 ]).appending(this.data));
        }
        toString() {
            return `PVT_${this.type}_${Base58.encodeRipemd160Check(this.data, this.type)}`;
        }
        toJSON() {
            return this.toString();
        }
    }
    function decodeKey(value) {
        const type = typeof value;
        if (type !== "string") {
            throw new Error(`Expected string, got ${type}`);
        }
        if (value.startsWith("PVT_")) {
            const parts = value.split("_");
            if (parts.length !== 3) {
                throw new Error("Invalid PVT format");
            }
            const type = KeyType.from(parts[1]);
            let size;
            switch (type) {
              case KeyType.K1:
              case KeyType.R1:
                size = 32;
                break;
            }
            const data = Base58.decodeRipemd160Check(parts[2], size, type);
            return {
                type: type,
                data: data
            };
        } else {
            const type = KeyType.K1;
            const data = Base58.decodeCheck(value);
            if (data.array[0] !== 128) {
                throw new Error("Invalid WIF");
            }
            return {
                type: type,
                data: data.droppingFirst()
            };
        }
    }
    var PermissionLevel_1;
    let PermissionLevel = PermissionLevel_1 = class PermissionLevel extends Struct {
        static from(value) {
            if (typeof value === "string") {
                const parts = value.split("@");
                if (parts.length !== 2 && parts[0].length > 0 && parts[1].length > 0) {
                    throw new Error("Invalid permission level string, should be in the format <actor>@<permission>");
                }
                value = {
                    actor: parts[0],
                    permission: parts[1]
                };
            }
            return super.from(value);
        }
        equals(other) {
            const otherPerm = PermissionLevel_1.from(other);
            return this.actor.equals(otherPerm.actor) && this.permission.equals(otherPerm.permission);
        }
        toString() {
            return `${this.actor}@${this.permission}`;
        }
    };
    __decorate([ Struct.field("name") ], PermissionLevel.prototype, "actor", void 0);
    __decorate([ Struct.field("name") ], PermissionLevel.prototype, "permission", void 0);
    PermissionLevel = PermissionLevel_1 = __decorate([ Struct.type("permission_level") ], PermissionLevel);
    var Action_1;
    let Action = Action_1 = class Action extends Struct {
        static from(object, abi) {
            const data = object.data;
            if (!Bytes.isBytes(data)) {
                let type;
                if (abi) {
                    type = ABI.from(abi).getActionType(object.name);
                } else if (!data.constructor || data.constructor.abiName === undefined) {
                    throw new Error("Missing ABI definition when creating action with untyped action data");
                }
                object = {
                    ...object,
                    data: abiEncode({
                        object: data,
                        type: type,
                        abi: abi
                    })
                };
            }
            return super.from(object);
        }
        equals(other) {
            const otherAction = Action_1.from(other);
            return this.account.equals(otherAction.account) && this.name.equals(otherAction.name) && arrayEquatableEquals(this.authorization, otherAction.authorization) && this.data.equals(otherAction.data);
        }
        decodeData(typeOrAbi) {
            if (typeof typeOrAbi === "string" || typeOrAbi.abiName) {
                return abiDecode({
                    data: this.data,
                    type: typeOrAbi
                });
            } else {
                const abi = ABI.from(typeOrAbi);
                const type = abi.getActionType(this.name);
                if (!type) {
                    throw new Error(`Action ${this.name} does not exist in provided ABI`);
                }
                return abiDecode({
                    data: this.data,
                    type: type,
                    abi: abi
                });
            }
        }
    };
    __decorate([ Struct.field("name") ], Action.prototype, "account", void 0);
    __decorate([ Struct.field("name") ], Action.prototype, "name", void 0);
    __decorate([ Struct.field(PermissionLevel, {
        array: true
    }) ], Action.prototype, "authorization", void 0);
    __decorate([ Struct.field("bytes") ], Action.prototype, "data", void 0);
    Action = Action_1 = __decorate([ Struct.type("action") ], Action);
    var Transaction_1;
    let TransactionExtension = class TransactionExtension extends Struct {};
    __decorate([ Struct.field("uint16") ], TransactionExtension.prototype, "type", void 0);
    __decorate([ Struct.field("bytes") ], TransactionExtension.prototype, "data", void 0);
    TransactionExtension = __decorate([ Struct.type("transaction_extension") ], TransactionExtension);
    let TransactionHeader = class TransactionHeader extends Struct {
        static from(object) {
            return super.from({
                max_net_usage_words: 0,
                max_cpu_usage_ms: 0,
                delay_sec: 0,
                ...object
            });
        }
    };
    __decorate([ Struct.field("time_point_sec") ], TransactionHeader.prototype, "expiration", void 0);
    __decorate([ Struct.field("uint16") ], TransactionHeader.prototype, "ref_block_num", void 0);
    __decorate([ Struct.field("uint32") ], TransactionHeader.prototype, "ref_block_prefix", void 0);
    __decorate([ Struct.field("varuint32") ], TransactionHeader.prototype, "max_net_usage_words", void 0);
    __decorate([ Struct.field("uint8") ], TransactionHeader.prototype, "max_cpu_usage_ms", void 0);
    __decorate([ Struct.field("varuint32") ], TransactionHeader.prototype, "delay_sec", void 0);
    TransactionHeader = __decorate([ Struct.type("transaction_header") ], TransactionHeader);
    let Transaction = Transaction_1 = class Transaction extends TransactionHeader {
        static from(object, abis) {
            const abiFor = contract => {
                if (!abis) {
                    return;
                } else if (Array.isArray(abis)) {
                    return abis.filter((abi => Name.from(abi.contract).equals(contract))).map((({abi: abi}) => abi))[0];
                } else {
                    return abis;
                }
            };
            const resolveAction = action => Action.from(action, abiFor(action.account));
            const actions = (object.actions || []).map(resolveAction);
            const context_free_actions = (object.context_free_actions || []).map(resolveAction);
            const transaction = {
                transaction_extensions: [],
                ...object,
                context_free_actions: context_free_actions,
                actions: actions
            };
            return super.from(transaction);
        }
        equals(other) {
            const tx = Transaction_1.from(other);
            return this.id.equals(tx.id);
        }
        get id() {
            return Checksum256.hash(abiEncode({
                object: this
            }));
        }
        signingDigest(chainId) {
            const data = this.signingData(chainId);
            return Checksum256.hash(data);
        }
        signingData(chainId) {
            let data = Bytes.from(Checksum256.from(chainId).array);
            data = data.appending(abiEncode({
                object: this
            }));
            data = data.appending(new Uint8Array(32));
            return data;
        }
    };
    __decorate([ Struct.field(Action, {
        array: true
    }) ], Transaction.prototype, "context_free_actions", void 0);
    __decorate([ Struct.field(Action, {
        array: true
    }) ], Transaction.prototype, "actions", void 0);
    __decorate([ Struct.field(TransactionExtension, {
        array: true
    }) ], Transaction.prototype, "transaction_extensions", void 0);
    Transaction = Transaction_1 = __decorate([ Struct.type("transaction") ], Transaction);
    let SignedTransaction = class SignedTransaction extends Transaction {
        get transaction() {
            return Transaction.from({
                ...this,
                signatures: undefined,
                context_free_data: undefined
            });
        }
        get id() {
            return this.transaction.id;
        }
        static from(object) {
            return super.from({
                signatures: [],
                context_free_data: [],
                ...object
            });
        }
    };
    __decorate([ Struct.field("signature[]") ], SignedTransaction.prototype, "signatures", void 0);
    __decorate([ Struct.field("bytes[]") ], SignedTransaction.prototype, "context_free_data", void 0);
    SignedTransaction = __decorate([ Struct.type("signed_transaction") ], SignedTransaction);
    let PackedTransaction = class PackedTransaction extends Struct {
        static from(object) {
            return super.from({
                signatures: [],
                packed_context_free_data: "",
                compression: 0,
                ...object
            });
        }
        static fromSigned(signed) {
            const tx = Transaction.from(signed);
            return this.from({
                signatures: signed.signatures,
                packed_context_free_data: abiEncode({
                    object: signed.context_free_data,
                    type: "bytes[]"
                }),
                packed_trx: abiEncode({
                    object: tx
                })
            });
        }
        getTransaction() {
            if (Number(this.compression) !== 0) {
                throw new Error("Transaction compression not supported yet");
            }
            return abiDecode({
                data: this.packed_trx,
                type: Transaction
            });
        }
        getSignedTransaction() {
            const transaction = this.getTransaction();
            return SignedTransaction.from({
                ...transaction,
                signatures: this.signatures
            });
        }
    };
    __decorate([ Struct.field("signature[]") ], PackedTransaction.prototype, "signatures", void 0);
    __decorate([ Struct.field("uint8") ], PackedTransaction.prototype, "compression", void 0);
    __decorate([ Struct.field("bytes") ], PackedTransaction.prototype, "packed_context_free_data", void 0);
    __decorate([ Struct.field("bytes") ], PackedTransaction.prototype, "packed_trx", void 0);
    PackedTransaction = __decorate([ Struct.type("packed_transaction") ], PackedTransaction);
    let TransactionReceipt = class TransactionReceipt extends Struct {};
    __decorate([ Struct.field("string") ], TransactionReceipt.prototype, "status", void 0);
    __decorate([ Struct.field("uint32") ], TransactionReceipt.prototype, "cpu_usage_us", void 0);
    __decorate([ Struct.field("uint32") ], TransactionReceipt.prototype, "net_usage_words", void 0);
    TransactionReceipt = __decorate([ Struct.type("transaction_receipt") ], TransactionReceipt);
    var Authority_1;
    let Weight = class Weight extends UInt16 {};
    Weight = __decorate([ TypeAlias("weight_type") ], Weight);
    let KeyWeight = class KeyWeight extends Struct {};
    __decorate([ Struct.field(PublicKey) ], KeyWeight.prototype, "key", void 0);
    __decorate([ Struct.field(Weight) ], KeyWeight.prototype, "weight", void 0);
    KeyWeight = __decorate([ Struct.type("key_weight") ], KeyWeight);
    let PermissionLevelWeight = class PermissionLevelWeight extends Struct {};
    __decorate([ Struct.field(PermissionLevel) ], PermissionLevelWeight.prototype, "permission", void 0);
    __decorate([ Struct.field(Weight) ], PermissionLevelWeight.prototype, "weight", void 0);
    PermissionLevelWeight = __decorate([ Struct.type("permission_level_weight") ], PermissionLevelWeight);
    let WaitWeight = class WaitWeight extends Struct {};
    __decorate([ Struct.field(UInt32) ], WaitWeight.prototype, "wait_sec", void 0);
    __decorate([ Struct.field(Weight) ], WaitWeight.prototype, "weight", void 0);
    WaitWeight = __decorate([ Struct.type("wait_weight") ], WaitWeight);
    let Authority = Authority_1 = class Authority extends Struct {
        static from(value) {
            if (isInstanceOf(value, Authority_1)) {
                return value;
            }
            const rv = super.from({
                keys: [],
                accounts: [],
                waits: [],
                ...value
            });
            rv.sort();
            return rv;
        }
        get waitThreshold() {
            return this.waits.reduce(((val, wait) => val + wait.weight.toNumber()), 0);
        }
        get keyThreshold() {
            return this.threshold.toNumber() - this.waitThreshold;
        }
        keyWeight(publicKey) {
            const weight = this.keys.find((({key: key}) => key.equals(publicKey)));
            return weight ? weight.weight.toNumber() : 0;
        }
        hasPermission(publicKey, includePartial = false) {
            const threshold = includePartial ? 1 : this.keyThreshold;
            const weight = this.keyWeight(publicKey);
            return weight >= threshold;
        }
        sort() {
            this.keys.sort(((a, b) => String(a.key).localeCompare(String(b.key))));
            this.accounts.sort(((a, b) => String(a.permission).localeCompare(String(b.permission))));
            this.waits.sort(((a, b) => String(a.wait_sec).localeCompare(String(b.wait_sec))));
        }
    };
    __decorate([ Struct.field(UInt32) ], Authority.prototype, "threshold", void 0);
    __decorate([ Struct.field(KeyWeight, {
        array: true
    }) ], Authority.prototype, "keys", void 0);
    __decorate([ Struct.field(PermissionLevelWeight, {
        array: true
    }) ], Authority.prototype, "accounts", void 0);
    __decorate([ Struct.field(WaitWeight, {
        array: true
    }) ], Authority.prototype, "waits", void 0);
    Authority = Authority_1 = __decorate([ Struct.type("authority") ], Authority);
    var Serializer;
    (function(Serializer) {
        Serializer.encode = abiEncode;
        Serializer.decode = abiDecode;
        function synthesize(type) {
            return synthesizeABI(type).abi;
        }
        Serializer.synthesize = synthesize;
        function stringify(object) {
            return JSON.stringify(object);
        }
        Serializer.stringify = stringify;
        function objectify(object) {
            const walk = v => {
                switch (typeof v) {
                  case "boolean":
                  case "number":
                  case "string":
                    return v;

                  case "object":
                    {
                        if (v === null) {
                            return v;
                        }
                        if (typeof v.toJSON === "function") {
                            return walk(v.toJSON());
                        }
                        if (Array.isArray(v)) {
                            return v.map(walk);
                        }
                        const rv = {};
                        for (const key of Object.keys(v)) {
                            rv[key] = walk(v[key]);
                        }
                        return rv;
                    }
                }
            };
            return walk(object);
        }
        Serializer.objectify = objectify;
    })(Serializer || (Serializer = {}));
    class FetchProvider {
        constructor(url, options = {}) {
            url = url.trim();
            if (url.endsWith("/")) url = url.slice(0, -1);
            this.url = url;
            if (!options.fetch) {
                if (typeof window !== "undefined" && window.fetch) {
                    this.fetch = window.fetch.bind(window);
                } else if (typeof global !== "undefined" && global.fetch) {
                    this.fetch = global.fetch.bind(global);
                } else {
                    throw new Error("Missing fetch");
                }
            } else {
                this.fetch = options.fetch;
            }
        }
        async call(path, params) {
            const url = this.url + path;
            const response = await this.fetch(url, {
                method: "POST",
                body: params !== undefined ? JSON.stringify(params) : undefined
            });
            const text = await response.text();
            let json;
            try {
                json = JSON.parse(text);
            } catch {}
            const headers = {};
            for (const [key, value] of response.headers.entries()) {
                headers[key] = value;
            }
            return {
                headers: headers,
                status: response.status,
                json: json,
                text: text
            };
        }
    }
    let AccountPermission = class AccountPermission extends Struct {};
    __decorate([ Struct.field("name") ], AccountPermission.prototype, "perm_name", void 0);
    __decorate([ Struct.field("name") ], AccountPermission.prototype, "parent", void 0);
    __decorate([ Struct.field(Authority) ], AccountPermission.prototype, "required_auth", void 0);
    AccountPermission = __decorate([ Struct.type("account_permission") ], AccountPermission);
    let AccountResourceLimit = class AccountResourceLimit extends Struct {};
    __decorate([ Struct.field("int64") ], AccountResourceLimit.prototype, "used", void 0);
    __decorate([ Struct.field("int64") ], AccountResourceLimit.prototype, "available", void 0);
    __decorate([ Struct.field("int64") ], AccountResourceLimit.prototype, "max", void 0);
    AccountResourceLimit = __decorate([ Struct.type("account_resource_limit") ], AccountResourceLimit);
    let AccountTotalResources = class AccountTotalResources extends Struct {};
    __decorate([ Struct.field("name") ], AccountTotalResources.prototype, "owner", void 0);
    __decorate([ Struct.field("asset") ], AccountTotalResources.prototype, "net_weight", void 0);
    __decorate([ Struct.field("asset") ], AccountTotalResources.prototype, "cpu_weight", void 0);
    __decorate([ Struct.field("uint64") ], AccountTotalResources.prototype, "ram_bytes", void 0);
    AccountTotalResources = __decorate([ Struct.type("account_total_resources") ], AccountTotalResources);
    let AccountSelfDelegatedBandwidth = class AccountSelfDelegatedBandwidth extends Struct {};
    __decorate([ Struct.field("name") ], AccountSelfDelegatedBandwidth.prototype, "from", void 0);
    __decorate([ Struct.field("name") ], AccountSelfDelegatedBandwidth.prototype, "to", void 0);
    __decorate([ Struct.field("asset") ], AccountSelfDelegatedBandwidth.prototype, "net_weight", void 0);
    __decorate([ Struct.field("asset") ], AccountSelfDelegatedBandwidth.prototype, "cpu_weight", void 0);
    AccountSelfDelegatedBandwidth = __decorate([ Struct.type("account_self_delegated_bandwidth") ], AccountSelfDelegatedBandwidth);
    let AccountRefundRequest = class AccountRefundRequest extends Struct {};
    __decorate([ Struct.field("name") ], AccountRefundRequest.prototype, "owner", void 0);
    __decorate([ Struct.field("time_point") ], AccountRefundRequest.prototype, "request_time", void 0);
    __decorate([ Struct.field("asset") ], AccountRefundRequest.prototype, "net_amount", void 0);
    __decorate([ Struct.field("asset") ], AccountRefundRequest.prototype, "cpu_amount", void 0);
    AccountRefundRequest = __decorate([ Struct.type("account_refund_request") ], AccountRefundRequest);
    let AccountVoterInfo = class AccountVoterInfo extends Struct {};
    __decorate([ Struct.field("name") ], AccountVoterInfo.prototype, "owner", void 0);
    __decorate([ Struct.field("name") ], AccountVoterInfo.prototype, "proxy", void 0);
    __decorate([ Struct.field("name", {
        array: true
    }) ], AccountVoterInfo.prototype, "producers", void 0);
    __decorate([ Struct.field("int64", {
        optional: true
    }) ], AccountVoterInfo.prototype, "staked", void 0);
    __decorate([ Struct.field("bool") ], AccountVoterInfo.prototype, "is_proxy", void 0);
    __decorate([ Struct.field("uint32", {
        optional: true
    }) ], AccountVoterInfo.prototype, "flags1", void 0);
    __decorate([ Struct.field("uint32") ], AccountVoterInfo.prototype, "reserved2", void 0);
    __decorate([ Struct.field("string") ], AccountVoterInfo.prototype, "reserved3", void 0);
    AccountVoterInfo = __decorate([ Struct.type("account_voter_info") ], AccountVoterInfo);
    let AccountRexInfoMaturities = class AccountRexInfoMaturities extends Struct {};
    __decorate([ Struct.field("time_point", {
        optional: true
    }) ], AccountRexInfoMaturities.prototype, "key", void 0);
    __decorate([ Struct.field("int64", {
        optional: true
    }) ], AccountRexInfoMaturities.prototype, "value", void 0);
    __decorate([ Struct.field("time_point", {
        optional: true
    }) ], AccountRexInfoMaturities.prototype, "first", void 0);
    __decorate([ Struct.field("int64", {
        optional: true
    }) ], AccountRexInfoMaturities.prototype, "second", void 0);
    AccountRexInfoMaturities = __decorate([ Struct.type("account_rex_info_maturities") ], AccountRexInfoMaturities);
    let AccountRexInfo = class AccountRexInfo extends Struct {};
    __decorate([ Struct.field("uint32") ], AccountRexInfo.prototype, "version", void 0);
    __decorate([ Struct.field("name") ], AccountRexInfo.prototype, "owner", void 0);
    __decorate([ Struct.field("asset") ], AccountRexInfo.prototype, "vote_stake", void 0);
    __decorate([ Struct.field("asset") ], AccountRexInfo.prototype, "rex_balance", void 0);
    __decorate([ Struct.field("int64") ], AccountRexInfo.prototype, "matured_rex", void 0);
    __decorate([ Struct.field(AccountRexInfoMaturities, {
        array: true
    }) ], AccountRexInfo.prototype, "rex_maturities", void 0);
    AccountRexInfo = __decorate([ Struct.type("account_rex_info") ], AccountRexInfo);
    let AccountObject = class AccountObject extends Struct {
        getPermission(permission) {
            const name = Name.from(permission);
            const match = this.permissions.find((p => p.perm_name.equals(name)));
            if (!match) {
                throw new Error(`Unknown permission ${name} on account ${this.account_name}.`);
            }
            return match;
        }
    };
    __decorate([ Struct.field("name") ], AccountObject.prototype, "account_name", void 0);
    __decorate([ Struct.field("uint32") ], AccountObject.prototype, "head_block_num", void 0);
    __decorate([ Struct.field("time_point") ], AccountObject.prototype, "head_block_time", void 0);
    __decorate([ Struct.field("bool") ], AccountObject.prototype, "privileged", void 0);
    __decorate([ Struct.field("time_point") ], AccountObject.prototype, "last_code_update", void 0);
    __decorate([ Struct.field("time_point") ], AccountObject.prototype, "created", void 0);
    __decorate([ Struct.field("asset?") ], AccountObject.prototype, "core_liquid_balance", void 0);
    __decorate([ Struct.field("int64") ], AccountObject.prototype, "ram_quota", void 0);
    __decorate([ Struct.field("int64") ], AccountObject.prototype, "net_weight", void 0);
    __decorate([ Struct.field("int64") ], AccountObject.prototype, "cpu_weight", void 0);
    __decorate([ Struct.field(AccountResourceLimit) ], AccountObject.prototype, "net_limit", void 0);
    __decorate([ Struct.field(AccountResourceLimit) ], AccountObject.prototype, "cpu_limit", void 0);
    __decorate([ Struct.field("uint64") ], AccountObject.prototype, "ram_usage", void 0);
    __decorate([ Struct.field(AccountPermission, {
        array: true
    }) ], AccountObject.prototype, "permissions", void 0);
    __decorate([ Struct.field(AccountTotalResources, {
        optional: true
    }) ], AccountObject.prototype, "total_resources", void 0);
    __decorate([ Struct.field(AccountSelfDelegatedBandwidth, {
        optional: true
    }) ], AccountObject.prototype, "self_delegated_bandwidth", void 0);
    __decorate([ Struct.field(AccountRefundRequest, {
        optional: true
    }) ], AccountObject.prototype, "refund_request", void 0);
    __decorate([ Struct.field(AccountVoterInfo, {
        optional: true
    }) ], AccountObject.prototype, "voter_info", void 0);
    __decorate([ Struct.field(AccountRexInfo, {
        optional: true
    }) ], AccountObject.prototype, "rex_info", void 0);
    AccountObject = __decorate([ Struct.type("account_object") ], AccountObject);
    let NewProducersEntry = class NewProducersEntry extends Struct {};
    __decorate([ Struct.field("name") ], NewProducersEntry.prototype, "producer_name", void 0);
    __decorate([ Struct.field("public_key") ], NewProducersEntry.prototype, "block_signing_key", void 0);
    NewProducersEntry = __decorate([ Struct.type("new_producers_entry") ], NewProducersEntry);
    let NewProducers = class NewProducers extends Struct {};
    __decorate([ Struct.field("uint32") ], NewProducers.prototype, "version", void 0);
    __decorate([ Struct.field(NewProducersEntry, {
        array: true
    }) ], NewProducers.prototype, "producers", void 0);
    NewProducers = __decorate([ Struct.type("new_producers") ], NewProducers);
    let BlockExtension = class BlockExtension extends Struct {};
    __decorate([ Struct.field("uint16") ], BlockExtension.prototype, "type", void 0);
    __decorate([ Struct.field("bytes") ], BlockExtension.prototype, "data", void 0);
    BlockExtension = __decorate([ Struct.type("block_extension") ], BlockExtension);
    let HeaderExtension = class HeaderExtension extends Struct {};
    __decorate([ Struct.field("uint16") ], HeaderExtension.prototype, "type", void 0);
    __decorate([ Struct.field("bytes") ], HeaderExtension.prototype, "data", void 0);
    HeaderExtension = __decorate([ Struct.type("header_extension") ], HeaderExtension);
    class TrxVariant {
        constructor(id, extra) {
            this.id = id;
            this.extra = extra;
        }
        static from(data) {
            let id;
            let extra;
            if (typeof data === "string") {
                id = Checksum256.from(data);
                extra = {};
            } else {
                id = Checksum256.from(data.id);
                extra = data;
            }
            return new this(id, extra);
        }
        get transaction() {
            if (this.extra.packed_trx) {
                return Serializer.decode({
                    data: this.extra.packed_trx,
                    type: Transaction
                });
            }
        }
        get signatures() {
            if (this.extra.signatures) {
                return this.extra.signatures.map(Signature.from);
            }
        }
        equals(other) {
            return this.id.equals(other.id);
        }
        toJSON() {
            return this.id;
        }
    }
    TrxVariant.abiName = "trx_variant";
    let GetBlockResponseTransactionReceipt = class GetBlockResponseTransactionReceipt extends TransactionReceipt {
        get id() {
            return this.trx.id;
        }
    };
    __decorate([ Struct.field(TrxVariant) ], GetBlockResponseTransactionReceipt.prototype, "trx", void 0);
    GetBlockResponseTransactionReceipt = __decorate([ Struct.type("get_block_response_receipt") ], GetBlockResponseTransactionReceipt);
    let GetBlockResponse = class GetBlockResponse extends Struct {};
    __decorate([ Struct.field("time_point") ], GetBlockResponse.prototype, "timestamp", void 0);
    __decorate([ Struct.field("name") ], GetBlockResponse.prototype, "producer", void 0);
    __decorate([ Struct.field("uint16") ], GetBlockResponse.prototype, "confirmed", void 0);
    __decorate([ Struct.field("checksum256") ], GetBlockResponse.prototype, "previous", void 0);
    __decorate([ Struct.field("checksum256") ], GetBlockResponse.prototype, "transaction_mroot", void 0);
    __decorate([ Struct.field("checksum256") ], GetBlockResponse.prototype, "action_mroot", void 0);
    __decorate([ Struct.field("uint32") ], GetBlockResponse.prototype, "schedule_version", void 0);
    __decorate([ Struct.field(NewProducers, {
        optional: true
    }) ], GetBlockResponse.prototype, "new_producers", void 0);
    __decorate([ Struct.field("header_extension", {
        optional: true
    }) ], GetBlockResponse.prototype, "header_extensions", void 0);
    __decorate([ Struct.field("any", {
        optional: true
    }) ], GetBlockResponse.prototype, "new_protocol_features", void 0);
    __decorate([ Struct.field("signature") ], GetBlockResponse.prototype, "producer_signature", void 0);
    __decorate([ Struct.field(GetBlockResponseTransactionReceipt, {
        array: true
    }) ], GetBlockResponse.prototype, "transactions", void 0);
    __decorate([ Struct.field("block_extension", {
        optional: true
    }) ], GetBlockResponse.prototype, "block_extensions", void 0);
    __decorate([ Struct.field("checksum256") ], GetBlockResponse.prototype, "id", void 0);
    __decorate([ Struct.field("uint32") ], GetBlockResponse.prototype, "block_num", void 0);
    __decorate([ Struct.field("uint32") ], GetBlockResponse.prototype, "ref_block_prefix", void 0);
    GetBlockResponse = __decorate([ Struct.type("get_block_response") ], GetBlockResponse);
    let ActiveScheduleProducerAuthority = class ActiveScheduleProducerAuthority extends Struct {};
    __decorate([ Struct.field("name") ], ActiveScheduleProducerAuthority.prototype, "producer_name", void 0);
    __decorate([ Struct.field("any") ], ActiveScheduleProducerAuthority.prototype, "authority", void 0);
    ActiveScheduleProducerAuthority = __decorate([ Struct.type("active_schedule_producer_authority") ], ActiveScheduleProducerAuthority);
    let ActiveScheduleProducer = class ActiveScheduleProducer extends Struct {};
    __decorate([ Struct.field("name") ], ActiveScheduleProducer.prototype, "producer_name", void 0);
    __decorate([ Struct.field(ActiveScheduleProducerAuthority) ], ActiveScheduleProducer.prototype, "authority", void 0);
    ActiveScheduleProducer = __decorate([ Struct.type("active_schedule_producer") ], ActiveScheduleProducer);
    let ActiveSchedule = class ActiveSchedule extends Struct {};
    __decorate([ Struct.field("uint32") ], ActiveSchedule.prototype, "version", void 0);
    __decorate([ Struct.field(ActiveScheduleProducer, {
        array: true
    }) ], ActiveSchedule.prototype, "producers", void 0);
    ActiveSchedule = __decorate([ Struct.type("active_schedule") ], ActiveSchedule);
    let BlockStateHeader = class BlockStateHeader extends Struct {};
    __decorate([ Struct.field("time_point") ], BlockStateHeader.prototype, "timestamp", void 0);
    __decorate([ Struct.field("name") ], BlockStateHeader.prototype, "producer", void 0);
    __decorate([ Struct.field("uint16") ], BlockStateHeader.prototype, "confirmed", void 0);
    __decorate([ Struct.field("checksum256") ], BlockStateHeader.prototype, "previous", void 0);
    __decorate([ Struct.field("checksum256") ], BlockStateHeader.prototype, "transaction_mroot", void 0);
    __decorate([ Struct.field("checksum256") ], BlockStateHeader.prototype, "action_mroot", void 0);
    __decorate([ Struct.field("uint32") ], BlockStateHeader.prototype, "schedule_version", void 0);
    __decorate([ Struct.field(HeaderExtension, {
        array: true,
        optional: true
    }) ], BlockStateHeader.prototype, "header_extensions", void 0);
    __decorate([ Struct.field("signature") ], BlockStateHeader.prototype, "producer_signature", void 0);
    BlockStateHeader = __decorate([ Struct.type("block_state_header") ], BlockStateHeader);
    let GetBlockHeaderStateResponse = class GetBlockHeaderStateResponse extends Struct {};
    __decorate([ Struct.field("uint32") ], GetBlockHeaderStateResponse.prototype, "block_num", void 0);
    __decorate([ Struct.field("uint32") ], GetBlockHeaderStateResponse.prototype, "dpos_proposed_irreversible_blocknum", void 0);
    __decorate([ Struct.field("uint32") ], GetBlockHeaderStateResponse.prototype, "dpos_irreversible_blocknum", void 0);
    __decorate([ Struct.field("checksum256") ], GetBlockHeaderStateResponse.prototype, "id", void 0);
    __decorate([ Struct.field(BlockStateHeader) ], GetBlockHeaderStateResponse.prototype, "header", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "active_schedule", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "blockroot_merkle", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "producer_to_last_produced", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "producer_to_last_implied_irb", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "valid_block_signing_authority", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "confirm_count", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "pending_schedule", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "activated_protocol_features", void 0);
    __decorate([ Struct.field("any") ], GetBlockHeaderStateResponse.prototype, "additional_signatures", void 0);
    GetBlockHeaderStateResponse = __decorate([ Struct.type("get_block_header_state_response") ], GetBlockHeaderStateResponse);
    let GetInfoResponse = class GetInfoResponse extends Struct {
        getTransactionHeader(secondsAhead = 120) {
            const expiration = TimePointSec.fromMilliseconds(this.head_block_time.toMilliseconds() + secondsAhead * 1e3);
            const id = this.last_irreversible_block_id;
            const prefixArray = id.array.subarray(8, 12);
            const prefix = new Uint32Array(prefixArray.buffer, prefixArray.byteOffset, 1)[0];
            return TransactionHeader.from({
                expiration: expiration,
                ref_block_num: Number(this.last_irreversible_block_num) & 65535,
                ref_block_prefix: prefix
            });
        }
    };
    __decorate([ Struct.field("string") ], GetInfoResponse.prototype, "server_version", void 0);
    __decorate([ Struct.field("checksum256") ], GetInfoResponse.prototype, "chain_id", void 0);
    __decorate([ Struct.field("uint32") ], GetInfoResponse.prototype, "head_block_num", void 0);
    __decorate([ Struct.field("uint32") ], GetInfoResponse.prototype, "last_irreversible_block_num", void 0);
    __decorate([ Struct.field("checksum256") ], GetInfoResponse.prototype, "last_irreversible_block_id", void 0);
    __decorate([ Struct.field("checksum256") ], GetInfoResponse.prototype, "head_block_id", void 0);
    __decorate([ Struct.field("time_point") ], GetInfoResponse.prototype, "head_block_time", void 0);
    __decorate([ Struct.field("name") ], GetInfoResponse.prototype, "head_block_producer", void 0);
    __decorate([ Struct.field("uint64") ], GetInfoResponse.prototype, "virtual_block_cpu_limit", void 0);
    __decorate([ Struct.field("uint64") ], GetInfoResponse.prototype, "virtual_block_net_limit", void 0);
    __decorate([ Struct.field("uint64") ], GetInfoResponse.prototype, "block_cpu_limit", void 0);
    __decorate([ Struct.field("uint64") ], GetInfoResponse.prototype, "block_net_limit", void 0);
    __decorate([ Struct.field("string?") ], GetInfoResponse.prototype, "server_version_string", void 0);
    __decorate([ Struct.field("uint32?") ], GetInfoResponse.prototype, "fork_db_head_block_num", void 0);
    __decorate([ Struct.field("checksum256?") ], GetInfoResponse.prototype, "fork_db_head_block_id", void 0);
    GetInfoResponse = __decorate([ Struct.type("get_info_response") ], GetInfoResponse);
    let GetTableByScopeResponseRow = class GetTableByScopeResponseRow extends Struct {};
    __decorate([ Struct.field("name") ], GetTableByScopeResponseRow.prototype, "code", void 0);
    __decorate([ Struct.field("name") ], GetTableByScopeResponseRow.prototype, "scope", void 0);
    __decorate([ Struct.field("name") ], GetTableByScopeResponseRow.prototype, "table", void 0);
    __decorate([ Struct.field("name") ], GetTableByScopeResponseRow.prototype, "payer", void 0);
    __decorate([ Struct.field("uint32") ], GetTableByScopeResponseRow.prototype, "count", void 0);
    GetTableByScopeResponseRow = __decorate([ Struct.type("get_table_by_scope_response_row") ], GetTableByScopeResponseRow);
    let GetTableByScopeResponse = class GetTableByScopeResponse extends Struct {};
    __decorate([ Struct.field(GetTableByScopeResponseRow, {
        array: true
    }) ], GetTableByScopeResponse.prototype, "rows", void 0);
    __decorate([ Struct.field("string") ], GetTableByScopeResponse.prototype, "more", void 0);
    GetTableByScopeResponse = __decorate([ Struct.type("get_table_by_scope_response") ], GetTableByScopeResponse);
    let OrderedActionsResult = class OrderedActionsResult extends Struct {};
    __decorate([ Struct.field(UInt64) ], OrderedActionsResult.prototype, "global_action_seq", void 0);
    __decorate([ Struct.field(Int64) ], OrderedActionsResult.prototype, "account_action_seq", void 0);
    __decorate([ Struct.field(UInt32) ], OrderedActionsResult.prototype, "block_num", void 0);
    __decorate([ Struct.field(BlockTimestamp) ], OrderedActionsResult.prototype, "block_time", void 0);
    __decorate([ Struct.field("any") ], OrderedActionsResult.prototype, "action_trace", void 0);
    __decorate([ Struct.field("boolean?") ], OrderedActionsResult.prototype, "irrevirsible", void 0);
    OrderedActionsResult = __decorate([ Struct.type("ordered_action_result") ], OrderedActionsResult);
    let GetActionsResponse = class GetActionsResponse extends Struct {};
    __decorate([ Struct.field(OrderedActionsResult, {
        array: true
    }) ], GetActionsResponse.prototype, "actions", void 0);
    __decorate([ Struct.field(Int32) ], GetActionsResponse.prototype, "last_irreversible_block", void 0);
    __decorate([ Struct.field(Int32) ], GetActionsResponse.prototype, "head_block_num", void 0);
    __decorate([ Struct.field("boolean?") ], GetActionsResponse.prototype, "time_limit_exceeded_error", void 0);
    GetActionsResponse = __decorate([ Struct.type("get_actions_response") ], GetActionsResponse);
    let TransactionTrace = class TransactionTrace extends Struct {};
    TransactionTrace = __decorate([ Struct.type("transaction_trace") ], TransactionTrace);
    let Trx = class Trx extends Struct {};
    __decorate([ Struct.field("any") ], Trx.prototype, "actions", void 0);
    __decorate([ Struct.field("any") ], Trx.prototype, "context_free_actions", void 0);
    __decorate([ Struct.field("any") ], Trx.prototype, "context_free_data", void 0);
    __decorate([ Struct.field("number") ], Trx.prototype, "delay_sec", void 0);
    __decorate([ Struct.field("string") ], Trx.prototype, "expiration", void 0);
    __decorate([ Struct.field("number") ], Trx.prototype, "max_cpu_usage_ms", void 0);
    __decorate([ Struct.field("number") ], Trx.prototype, "max_net_usage_words", void 0);
    __decorate([ Struct.field("number") ], Trx.prototype, "ref_block_num", void 0);
    __decorate([ Struct.field("number") ], Trx.prototype, "ref_block_prefix", void 0);
    __decorate([ Struct.field("string", {
        array: true
    }) ], Trx.prototype, "signatures", void 0);
    Trx = __decorate([ Struct.type("trx") ], Trx);
    let TransactionInfo = class TransactionInfo extends Struct {};
    __decorate([ Struct.field(TransactionReceipt) ], TransactionInfo.prototype, "receipt", void 0);
    __decorate([ Struct.field("trx") ], TransactionInfo.prototype, "trx", void 0);
    TransactionInfo = __decorate([ Struct.type("transaction_info") ], TransactionInfo);
    let GetTransactionResponse = class GetTransactionResponse extends Struct {};
    __decorate([ Struct.field(Checksum256) ], GetTransactionResponse.prototype, "id", void 0);
    __decorate([ Struct.field(UInt32) ], GetTransactionResponse.prototype, "block_num", void 0);
    __decorate([ Struct.field(BlockTimestamp) ], GetTransactionResponse.prototype, "block_time", void 0);
    __decorate([ Struct.field(UInt32) ], GetTransactionResponse.prototype, "last_irreversible_block", void 0);
    __decorate([ Struct.field("any?") ], GetTransactionResponse.prototype, "traces", void 0);
    __decorate([ Struct.field("any") ], GetTransactionResponse.prototype, "trx", void 0);
    GetTransactionResponse = __decorate([ Struct.type("get_transaction_response") ], GetTransactionResponse);
    let GetKeyAccountsResponse = class GetKeyAccountsResponse extends Struct {};
    __decorate([ Struct.field("name", {
        array: true
    }) ], GetKeyAccountsResponse.prototype, "account_names", void 0);
    GetKeyAccountsResponse = __decorate([ Struct.type("get_key_accounts_response") ], GetKeyAccountsResponse);
    let GetControlledAccountsResponse = class GetControlledAccountsResponse extends Struct {};
    __decorate([ Struct.field("name", {
        array: true
    }) ], GetControlledAccountsResponse.prototype, "controlled_accounts", void 0);
    GetControlledAccountsResponse = __decorate([ Struct.type("get_controlled_accounts_response") ], GetControlledAccountsResponse);
    let GetTransactionStatusResponse = class GetTransactionStatusResponse extends Struct {};
    __decorate([ Struct.field("string") ], GetTransactionStatusResponse.prototype, "state", void 0);
    __decorate([ Struct.field("uint32") ], GetTransactionStatusResponse.prototype, "head_number", void 0);
    __decorate([ Struct.field("checksum256") ], GetTransactionStatusResponse.prototype, "head_id", void 0);
    __decorate([ Struct.field("time_point") ], GetTransactionStatusResponse.prototype, "head_timestamp", void 0);
    __decorate([ Struct.field("uint32") ], GetTransactionStatusResponse.prototype, "irreversible_number", void 0);
    __decorate([ Struct.field("checksum256") ], GetTransactionStatusResponse.prototype, "irreversible_id", void 0);
    __decorate([ Struct.field("time_point") ], GetTransactionStatusResponse.prototype, "irreversible_timestamp", void 0);
    __decorate([ Struct.field("checksum256") ], GetTransactionStatusResponse.prototype, "earliest_tracked_block_id", void 0);
    __decorate([ Struct.field("uint32") ], GetTransactionStatusResponse.prototype, "earliest_tracked_block_number", void 0);
    GetTransactionStatusResponse = __decorate([ Struct.type("get_transaction_status_response") ], GetTransactionStatusResponse);
    class ChainAPI {
        constructor(client) {
            this.client = client;
        }
        async get_abi(accountName) {
            return this.client.call({
                path: "/v1/chain/get_abi",
                params: {
                    account_name: Name.from(accountName)
                }
            });
        }
        async get_account(accountName) {
            return this.client.call({
                path: "/v1/chain/get_account",
                params: {
                    account_name: Name.from(accountName)
                },
                responseType: AccountObject
            });
        }
        async get_block(block_num_or_id) {
            return this.client.call({
                path: "/v1/chain/get_block",
                params: {
                    block_num_or_id: block_num_or_id
                },
                responseType: GetBlockResponse
            });
        }
        async get_block_header_state(block_num_or_id) {
            return this.client.call({
                path: "/v1/chain/get_block_header_state",
                params: {
                    block_num_or_id: block_num_or_id
                },
                responseType: GetBlockHeaderStateResponse
            });
        }
        async get_currency_balance(contract, accountName, symbol) {
            const params = {
                account: Name.from(accountName),
                code: Name.from(contract)
            };
            if (symbol) {
                params.symbol = symbol;
            }
            return this.client.call({
                path: "/v1/chain/get_currency_balance",
                params: params,
                responseType: "asset[]"
            });
        }
        async get_info() {
            return this.client.call({
                path: "/v1/chain/get_info",
                responseType: GetInfoResponse
            });
        }
        async compute_transaction(tx) {
            if (!isInstanceOf(tx, PackedTransaction)) {
                tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
            }
            return this.client.call({
                path: "/v1/chain/compute_transaction",
                params: {
                    transaction: tx
                }
            });
        }
        async push_transaction(tx) {
            if (!isInstanceOf(tx, PackedTransaction)) {
                tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
            }
            return this.client.call({
                path: "/v1/chain/push_transaction",
                params: tx
            });
        }
        async send_transaction(tx) {
            if (!isInstanceOf(tx, PackedTransaction)) {
                tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
            }
            return this.client.call({
                path: "/v1/chain/send_transaction",
                params: tx
            });
        }
        async send_transaction2(tx, options) {
            if (!isInstanceOf(tx, PackedTransaction)) {
                tx = PackedTransaction.fromSigned(SignedTransaction.from(tx));
            }
            return this.client.call({
                path: "/v1/chain/send_transaction2",
                params: {
                    return_failure_trace: true,
                    retry_trx: false,
                    retry_trx_num_blocks: 0,
                    transaction: tx,
                    ...options
                }
            });
        }
        async get_table_rows(params) {
            const type = params.type;
            let key_type = params.key_type;
            const someBound = params.lower_bound || params.upper_bound;
            if (!key_type && someBound) {
                if (isInstanceOf(someBound, UInt64)) {
                    key_type = "i64";
                } else if (isInstanceOf(someBound, UInt128)) {
                    key_type = "i128";
                } else if (isInstanceOf(someBound, Checksum256)) {
                    key_type = "sha256";
                } else if (isInstanceOf(someBound, Checksum160)) {
                    key_type = "ripemd160";
                }
            }
            if (!key_type) {
                key_type = "name";
            }
            let json = params.json;
            if (json === undefined) {
                json = type === undefined;
            }
            let upper_bound = params.upper_bound;
            if (upper_bound && typeof upper_bound !== "string") {
                upper_bound = String(upper_bound);
            }
            let lower_bound = params.lower_bound;
            if (lower_bound && typeof lower_bound !== "string") {
                lower_bound = String(lower_bound);
            }
            let scope = params.scope;
            if (typeof scope === "undefined") {
                scope = String(Name.from(params.code));
            } else if (typeof scope !== "string") {
                scope = String(scope);
            }
            let {rows: rows, more: more, next_key: next_key} = await this.client.call({
                path: "/v1/chain/get_table_rows",
                params: {
                    ...params,
                    code: Name.from(params.code),
                    table: Name.from(params.table),
                    limit: params.limit !== undefined ? UInt32.from(params.limit) : undefined,
                    scope: scope,
                    key_type: key_type,
                    json: json,
                    upper_bound: upper_bound,
                    lower_bound: lower_bound
                }
            });
            let ram_payers;
            if (params.show_payer) {
                ram_payers = [];
                rows = rows.map((({data: data, payer: payer}) => {
                    ram_payers.push(Name.from(payer));
                    return data;
                }));
            }
            if (type) {
                if (json) {
                    rows = rows.map((value => {
                        if (typeof value === "string" && Bytes.isBytes(value)) {
                            return Serializer.decode({
                                data: Bytes.from(value),
                                type: type
                            });
                        } else {
                            return Serializer.decode({
                                object: value,
                                type: type
                            });
                        }
                    }));
                } else {
                    rows = rows.map((hex => Bytes.from(hex))).map((data => Serializer.decode({
                        data: data,
                        type: type
                    })));
                }
            }
            if (next_key && next_key.length > 0) {
                let indexType;
                switch (key_type) {
                  case "i64":
                    indexType = UInt64;
                    break;

                  case "i128":
                    indexType = UInt128;
                    break;

                  case "name":
                    indexType = Name;
                    break;

                  case "float64":
                    indexType = Float64;
                    break;

                  case "float128":
                    indexType = Float128;
                    break;

                  case "sha256":
                    indexType = Checksum256;
                    break;

                  case "ripemd160":
                    indexType = Checksum160;
                    break;

                  default:
                    throw new Error(`Unsupported key type: ${key_type}`);
                }
                if (indexType === Name) {
                    next_key = Name.from(Serializer.decode({
                        object: next_key,
                        type: UInt64
                    }));
                } else {
                    next_key = Serializer.decode({
                        object: next_key,
                        type: indexType
                    });
                }
            } else {
                next_key = undefined;
            }
            return {
                rows: rows,
                more: more,
                next_key: next_key,
                ram_payers: ram_payers
            };
        }
        async get_table_by_scope(params) {
            return this.client.call({
                path: "/v1/chain/get_table_by_scope",
                params: params,
                responseType: GetTableByScopeResponse
            });
        }
        async get_transaction_status(id) {
            return this.client.call({
                path: "/v1/chain/get_transaction_status",
                params: {
                    id: Checksum256.from(id)
                },
                responseType: GetTransactionStatusResponse
            });
        }
    }
    class HistoryAPI {
        constructor(client) {
            this.client = client;
        }
        async get_actions(accountName, pos, offset) {
            return this.client.call({
                path: "/v1/history/get_actions",
                params: {
                    account_name: Name.from(accountName),
                    pos: Int32.from(pos),
                    offset: Int32.from(offset)
                },
                responseType: GetActionsResponse
            });
        }
        async get_transaction(id, options = {}) {
            return this.client.call({
                path: "/v1/history/get_transaction",
                params: {
                    id: Checksum256.from(id),
                    block_num_hint: options.blockNumHint && UInt32.from(options.blockNumHint),
                    traces: options.excludeTraces === true ? false : undefined
                },
                responseType: GetTransactionResponse
            });
        }
        async get_key_accounts(publicKey) {
            return this.client.call({
                path: "/v1/history/get_key_accounts",
                params: {
                    public_key: PublicKey.from(publicKey)
                },
                responseType: GetKeyAccountsResponse
            });
        }
        async get_controlled_accounts(controllingAccount) {
            return this.client.call({
                path: "/v1/history/get_controlled_accounts",
                params: {
                    controlling_account: Name.from(controllingAccount)
                },
                responseType: GetControlledAccountsResponse
            });
        }
    }
    class APIError extends Error {
        constructor(path, response) {
            let message;
            if (response.json && response.json.error) {
                message = `${APIError.formatError(response.json.error)} at ${path}`;
            } else {
                message = `HTTP ${response.status} at ${path}`;
            }
            super(message);
            this.path = path;
            this.response = response;
        }
        static formatError(error) {
            if (error.what === "unspecified" && error.details[0].file && error.details[0].file === "http_plugin.cpp" && error.details[0].message.slice(0, 11) === "unknown key") {
                return "Account not found";
            } else if (error.what === "unspecified" && error.details && error.details.length > 0) {
                return error.details[0].message;
            } else if (error.what && error.what.length > 0) {
                return error.what;
            } else {
                return "Unknown API error";
            }
        }
        get error() {
            const {json: json} = this.response;
            return json ? json.error : undefined;
        }
        get name() {
            const {error: error} = this;
            return error ? error.name : "unspecified";
        }
        get code() {
            const {error: error} = this;
            return error ? error.code : 0;
        }
        get details() {
            const {error: error} = this;
            return error ? error.details : [];
        }
    }
    APIError.__className = "APIError";
    class APIClient {
        constructor(options) {
            this.v1 = {
                chain: new ChainAPI(this),
                history: new HistoryAPI(this)
            };
            if (options.provider) {
                this.provider = options.provider;
            } else if (options.url) {
                this.provider = new FetchProvider(options.url, options);
            } else {
                throw new Error("Missing url or provider");
            }
        }
        async call(args) {
            const response = await this.provider.call(args.path, args.params);
            const {json: json} = response;
            if (Math.floor(response.status / 100) !== 2 || json && typeof json.error === "object") {
                throw new APIError(args.path, response);
            }
            if (args.responseType) {
                return abiDecode({
                    type: args.responseType,
                    object: response.json
                });
            }
            return response.json || response.text;
        }
    }
    APIClient.__className = "APIClient";
    const mockUrl = "https://jungle4.greymass.com";
    const mockChainId = "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d";
    const mockPrivateKey = "5Jtoxgny5tT7NiNFp1MLogviuPJ9NniWjnU4wKzaX4t7pL4kJ8s";
    const mockAccountName = "wharfkit1111";
    const mockPermissionName = "test";
    const mockPermissionLevel = `${mockAccountName}@${mockPermissionName}`;
    var lib$1 = {
        exports: {}
    };
    var publicApi = {};
    var URL = {
        exports: {}
    };
    var conversions = {};
    var lib = conversions;
    function sign(x) {
        return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
        if (x % 1 === .5 && (x & 1) === 0) {
            return Math.floor(x);
        } else {
            return Math.round(x);
        }
    }
    function createNumberConversion(bitLength, typeOpts) {
        if (!typeOpts.unsigned) {
            --bitLength;
        }
        const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
        const upperBound = Math.pow(2, bitLength) - 1;
        const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
        const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
        return function(V, opts) {
            if (!opts) opts = {};
            let x = +V;
            if (opts.enforceRange) {
                if (!Number.isFinite(x)) {
                    throw new TypeError("Argument is not a finite number");
                }
                x = sign(x) * Math.floor(Math.abs(x));
                if (x < lowerBound || x > upperBound) {
                    throw new TypeError("Argument is not in byte range");
                }
                return x;
            }
            if (!isNaN(x) && opts.clamp) {
                x = evenRound(x);
                if (x < lowerBound) x = lowerBound;
                if (x > upperBound) x = upperBound;
                return x;
            }
            if (!Number.isFinite(x) || x === 0) {
                return 0;
            }
            x = sign(x) * Math.floor(Math.abs(x));
            x = x % moduloVal;
            if (!typeOpts.unsigned && x >= moduloBound) {
                return x - moduloVal;
            } else if (typeOpts.unsigned) {
                if (x < 0) {
                    x += moduloVal;
                } else if (x === -0) {
                    return 0;
                }
            }
            return x;
        };
    }
    conversions["void"] = function() {
        return undefined;
    };
    conversions["boolean"] = function(val) {
        return !!val;
    };
    conversions["byte"] = createNumberConversion(8, {
        unsigned: false
    });
    conversions["octet"] = createNumberConversion(8, {
        unsigned: true
    });
    conversions["short"] = createNumberConversion(16, {
        unsigned: false
    });
    conversions["unsigned short"] = createNumberConversion(16, {
        unsigned: true
    });
    conversions["long"] = createNumberConversion(32, {
        unsigned: false
    });
    conversions["unsigned long"] = createNumberConversion(32, {
        unsigned: true
    });
    conversions["long long"] = createNumberConversion(32, {
        unsigned: false,
        moduloBitLength: 64
    });
    conversions["unsigned long long"] = createNumberConversion(32, {
        unsigned: true,
        moduloBitLength: 64
    });
    conversions["double"] = function(V) {
        const x = +V;
        if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite floating-point value");
        }
        return x;
    };
    conversions["unrestricted double"] = function(V) {
        const x = +V;
        if (isNaN(x)) {
            throw new TypeError("Argument is NaN");
        }
        return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
        if (!opts) opts = {};
        if (opts.treatNullAsEmptyString && V === null) {
            return "";
        }
        return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
        const x = String(V);
        let c = undefined;
        for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
            if (c > 255) {
                throw new TypeError("Argument is not a valid bytestring");
            }
        }
        return x;
    };
    conversions["USVString"] = function(V) {
        const S = String(V);
        const n = S.length;
        const U = [];
        for (let i = 0; i < n; ++i) {
            const c = S.charCodeAt(i);
            if (c < 55296 || c > 57343) {
                U.push(String.fromCodePoint(c));
            } else if (56320 <= c && c <= 57343) {
                U.push(String.fromCodePoint(65533));
            } else {
                if (i === n - 1) {
                    U.push(String.fromCodePoint(65533));
                } else {
                    const d = S.charCodeAt(i + 1);
                    if (56320 <= d && d <= 57343) {
                        const a = c & 1023;
                        const b = d & 1023;
                        U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                        ++i;
                    } else {
                        U.push(String.fromCodePoint(65533));
                    }
                }
            }
        }
        return U.join("");
    };
    conversions["Date"] = function(V, opts) {
        if (!(V instanceof Date)) {
            throw new TypeError("Argument is not a Date object");
        }
        if (isNaN(V)) {
            return undefined;
        }
        return V;
    };
    conversions["RegExp"] = function(V, opts) {
        if (!(V instanceof RegExp)) {
            V = new RegExp(V);
        }
        return V;
    };
    var utils$2 = {
        exports: {}
    };
    (function(module) {
        module.exports.mixin = function mixin(target, source) {
            const keys = Object.getOwnPropertyNames(source);
            for (let i = 0; i < keys.length; ++i) {
                Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
            }
        };
        module.exports.wrapperSymbol = Symbol("wrapper");
        module.exports.implSymbol = Symbol("impl");
        module.exports.wrapperForImpl = function(impl) {
            return impl[module.exports.wrapperSymbol];
        };
        module.exports.implForWrapper = function(wrapper) {
            return wrapper[module.exports.implSymbol];
        };
    })(utils$2);
    var URLImpl = {};
    var urlStateMachine = {
        exports: {}
    };
    const maxInt = 2147483647;
    const base = 36;
    const tMin = 1;
    const tMax = 26;
    const skew = 38;
    const damp = 700;
    const initialBias = 72;
    const initialN = 128;
    const delimiter = "-";
    const regexPunycode = /^xn--/;
    const regexNonASCII = /[^\0-\x7E]/;
    const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    const errors = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
    };
    const baseMinusTMin = base - tMin;
    const floor = Math.floor;
    const stringFromCharCode = String.fromCharCode;
    function error(type) {
        throw new RangeError(errors[type]);
    }
    function map(array, fn) {
        const result = [];
        let length = array.length;
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }
    function mapDomain(string, fn) {
        const parts = string.split("@");
        let result = "";
        if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        const labels = string.split(".");
        const encoded = map(labels, fn).join(".");
        return result + encoded;
    }
    function ucs2decode(string) {
        const output = [];
        let counter = 0;
        const length = string.length;
        while (counter < length) {
            const value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
                const extra = string.charCodeAt(counter++);
                if ((extra & 64512) == 56320) {
                    output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                } else {
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }
    const ucs2encode = array => String.fromCodePoint(...array);
    const basicToDigit = function(codePoint) {
        if (codePoint - 48 < 10) {
            return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
            return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
            return codePoint - 97;
        }
        return base;
    };
    const digitToBasic = function(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    const adapt = function(delta, numPoints, firstTime) {
        let k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (;delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    const decode$1 = function(input) {
        const output = [];
        const inputLength = input.length;
        let i = 0;
        let n = initialN;
        let bias = initialBias;
        let basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }
        for (let j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
                error("not-basic");
            }
            output.push(input.charCodeAt(j));
        }
        for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            let oldi = i;
            for (let w = 1, k = base; ;k += base) {
                if (index >= inputLength) {
                    error("invalid-input");
                }
                const digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error("overflow");
                }
                i += digit * w;
                const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) {
                    break;
                }
                const baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error("overflow");
                }
                w *= baseMinusT;
            }
            const out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n) {
                error("overflow");
            }
            n += floor(i / out);
            i %= out;
            output.splice(i++, 0, n);
        }
        return String.fromCodePoint(...output);
    };
    const encode$1 = function(input) {
        const output = [];
        input = ucs2decode(input);
        let inputLength = input.length;
        let n = initialN;
        let delta = 0;
        let bias = initialBias;
        for (const currentValue of input) {
            if (currentValue < 128) {
                output.push(stringFromCharCode(currentValue));
            }
        }
        let basicLength = output.length;
        let handledCPCount = basicLength;
        if (basicLength) {
            output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
            let m = maxInt;
            for (const currentValue of input) {
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }
            const handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error("overflow");
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (const currentValue of input) {
                if (currentValue < n && ++delta > maxInt) {
                    error("overflow");
                }
                if (currentValue == n) {
                    let q = delta;
                    for (let k = base; ;k += base) {
                        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                            break;
                        }
                        const qMinusT = q - t;
                        const baseMinusT = base - t;
                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join("");
    };
    const toUnicode = function(input) {
        return mapDomain(input, (function(string) {
            return regexPunycode.test(string) ? decode$1(string.slice(4).toLowerCase()) : string;
        }));
    };
    const toASCII = function(input) {
        return mapDomain(input, (function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode$1(string) : string;
        }));
    };
    const punycode$1 = {
        version: "2.1.0",
        ucs2: {
            decode: ucs2decode,
            encode: ucs2encode
        },
        decode: decode$1,
        encode: encode$1,
        toASCII: toASCII,
        toUnicode: toUnicode
    };
    var punycode_1 = punycode$1;
    var tr46 = {};
    var require$1 = [ [ [ 0, 44 ], "disallowed_STD3_valid" ], [ [ 45, 46 ], "valid" ], [ [ 47, 47 ], "disallowed_STD3_valid" ], [ [ 48, 57 ], "valid" ], [ [ 58, 64 ], "disallowed_STD3_valid" ], [ [ 65, 65 ], "mapped", [ 97 ] ], [ [ 66, 66 ], "mapped", [ 98 ] ], [ [ 67, 67 ], "mapped", [ 99 ] ], [ [ 68, 68 ], "mapped", [ 100 ] ], [ [ 69, 69 ], "mapped", [ 101 ] ], [ [ 70, 70 ], "mapped", [ 102 ] ], [ [ 71, 71 ], "mapped", [ 103 ] ], [ [ 72, 72 ], "mapped", [ 104 ] ], [ [ 73, 73 ], "mapped", [ 105 ] ], [ [ 74, 74 ], "mapped", [ 106 ] ], [ [ 75, 75 ], "mapped", [ 107 ] ], [ [ 76, 76 ], "mapped", [ 108 ] ], [ [ 77, 77 ], "mapped", [ 109 ] ], [ [ 78, 78 ], "mapped", [ 110 ] ], [ [ 79, 79 ], "mapped", [ 111 ] ], [ [ 80, 80 ], "mapped", [ 112 ] ], [ [ 81, 81 ], "mapped", [ 113 ] ], [ [ 82, 82 ], "mapped", [ 114 ] ], [ [ 83, 83 ], "mapped", [ 115 ] ], [ [ 84, 84 ], "mapped", [ 116 ] ], [ [ 85, 85 ], "mapped", [ 117 ] ], [ [ 86, 86 ], "mapped", [ 118 ] ], [ [ 87, 87 ], "mapped", [ 119 ] ], [ [ 88, 88 ], "mapped", [ 120 ] ], [ [ 89, 89 ], "mapped", [ 121 ] ], [ [ 90, 90 ], "mapped", [ 122 ] ], [ [ 91, 96 ], "disallowed_STD3_valid" ], [ [ 97, 122 ], "valid" ], [ [ 123, 127 ], "disallowed_STD3_valid" ], [ [ 128, 159 ], "disallowed" ], [ [ 160, 160 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 161, 167 ], "valid", [], "NV8" ], [ [ 168, 168 ], "disallowed_STD3_mapped", [ 32, 776 ] ], [ [ 169, 169 ], "valid", [], "NV8" ], [ [ 170, 170 ], "mapped", [ 97 ] ], [ [ 171, 172 ], "valid", [], "NV8" ], [ [ 173, 173 ], "ignored" ], [ [ 174, 174 ], "valid", [], "NV8" ], [ [ 175, 175 ], "disallowed_STD3_mapped", [ 32, 772 ] ], [ [ 176, 177 ], "valid", [], "NV8" ], [ [ 178, 178 ], "mapped", [ 50 ] ], [ [ 179, 179 ], "mapped", [ 51 ] ], [ [ 180, 180 ], "disallowed_STD3_mapped", [ 32, 769 ] ], [ [ 181, 181 ], "mapped", [ 956 ] ], [ [ 182, 182 ], "valid", [], "NV8" ], [ [ 183, 183 ], "valid" ], [ [ 184, 184 ], "disallowed_STD3_mapped", [ 32, 807 ] ], [ [ 185, 185 ], "mapped", [ 49 ] ], [ [ 186, 186 ], "mapped", [ 111 ] ], [ [ 187, 187 ], "valid", [], "NV8" ], [ [ 188, 188 ], "mapped", [ 49, 8260, 52 ] ], [ [ 189, 189 ], "mapped", [ 49, 8260, 50 ] ], [ [ 190, 190 ], "mapped", [ 51, 8260, 52 ] ], [ [ 191, 191 ], "valid", [], "NV8" ], [ [ 192, 192 ], "mapped", [ 224 ] ], [ [ 193, 193 ], "mapped", [ 225 ] ], [ [ 194, 194 ], "mapped", [ 226 ] ], [ [ 195, 195 ], "mapped", [ 227 ] ], [ [ 196, 196 ], "mapped", [ 228 ] ], [ [ 197, 197 ], "mapped", [ 229 ] ], [ [ 198, 198 ], "mapped", [ 230 ] ], [ [ 199, 199 ], "mapped", [ 231 ] ], [ [ 200, 200 ], "mapped", [ 232 ] ], [ [ 201, 201 ], "mapped", [ 233 ] ], [ [ 202, 202 ], "mapped", [ 234 ] ], [ [ 203, 203 ], "mapped", [ 235 ] ], [ [ 204, 204 ], "mapped", [ 236 ] ], [ [ 205, 205 ], "mapped", [ 237 ] ], [ [ 206, 206 ], "mapped", [ 238 ] ], [ [ 207, 207 ], "mapped", [ 239 ] ], [ [ 208, 208 ], "mapped", [ 240 ] ], [ [ 209, 209 ], "mapped", [ 241 ] ], [ [ 210, 210 ], "mapped", [ 242 ] ], [ [ 211, 211 ], "mapped", [ 243 ] ], [ [ 212, 212 ], "mapped", [ 244 ] ], [ [ 213, 213 ], "mapped", [ 245 ] ], [ [ 214, 214 ], "mapped", [ 246 ] ], [ [ 215, 215 ], "valid", [], "NV8" ], [ [ 216, 216 ], "mapped", [ 248 ] ], [ [ 217, 217 ], "mapped", [ 249 ] ], [ [ 218, 218 ], "mapped", [ 250 ] ], [ [ 219, 219 ], "mapped", [ 251 ] ], [ [ 220, 220 ], "mapped", [ 252 ] ], [ [ 221, 221 ], "mapped", [ 253 ] ], [ [ 222, 222 ], "mapped", [ 254 ] ], [ [ 223, 223 ], "deviation", [ 115, 115 ] ], [ [ 224, 246 ], "valid" ], [ [ 247, 247 ], "valid", [], "NV8" ], [ [ 248, 255 ], "valid" ], [ [ 256, 256 ], "mapped", [ 257 ] ], [ [ 257, 257 ], "valid" ], [ [ 258, 258 ], "mapped", [ 259 ] ], [ [ 259, 259 ], "valid" ], [ [ 260, 260 ], "mapped", [ 261 ] ], [ [ 261, 261 ], "valid" ], [ [ 262, 262 ], "mapped", [ 263 ] ], [ [ 263, 263 ], "valid" ], [ [ 264, 264 ], "mapped", [ 265 ] ], [ [ 265, 265 ], "valid" ], [ [ 266, 266 ], "mapped", [ 267 ] ], [ [ 267, 267 ], "valid" ], [ [ 268, 268 ], "mapped", [ 269 ] ], [ [ 269, 269 ], "valid" ], [ [ 270, 270 ], "mapped", [ 271 ] ], [ [ 271, 271 ], "valid" ], [ [ 272, 272 ], "mapped", [ 273 ] ], [ [ 273, 273 ], "valid" ], [ [ 274, 274 ], "mapped", [ 275 ] ], [ [ 275, 275 ], "valid" ], [ [ 276, 276 ], "mapped", [ 277 ] ], [ [ 277, 277 ], "valid" ], [ [ 278, 278 ], "mapped", [ 279 ] ], [ [ 279, 279 ], "valid" ], [ [ 280, 280 ], "mapped", [ 281 ] ], [ [ 281, 281 ], "valid" ], [ [ 282, 282 ], "mapped", [ 283 ] ], [ [ 283, 283 ], "valid" ], [ [ 284, 284 ], "mapped", [ 285 ] ], [ [ 285, 285 ], "valid" ], [ [ 286, 286 ], "mapped", [ 287 ] ], [ [ 287, 287 ], "valid" ], [ [ 288, 288 ], "mapped", [ 289 ] ], [ [ 289, 289 ], "valid" ], [ [ 290, 290 ], "mapped", [ 291 ] ], [ [ 291, 291 ], "valid" ], [ [ 292, 292 ], "mapped", [ 293 ] ], [ [ 293, 293 ], "valid" ], [ [ 294, 294 ], "mapped", [ 295 ] ], [ [ 295, 295 ], "valid" ], [ [ 296, 296 ], "mapped", [ 297 ] ], [ [ 297, 297 ], "valid" ], [ [ 298, 298 ], "mapped", [ 299 ] ], [ [ 299, 299 ], "valid" ], [ [ 300, 300 ], "mapped", [ 301 ] ], [ [ 301, 301 ], "valid" ], [ [ 302, 302 ], "mapped", [ 303 ] ], [ [ 303, 303 ], "valid" ], [ [ 304, 304 ], "mapped", [ 105, 775 ] ], [ [ 305, 305 ], "valid" ], [ [ 306, 307 ], "mapped", [ 105, 106 ] ], [ [ 308, 308 ], "mapped", [ 309 ] ], [ [ 309, 309 ], "valid" ], [ [ 310, 310 ], "mapped", [ 311 ] ], [ [ 311, 312 ], "valid" ], [ [ 313, 313 ], "mapped", [ 314 ] ], [ [ 314, 314 ], "valid" ], [ [ 315, 315 ], "mapped", [ 316 ] ], [ [ 316, 316 ], "valid" ], [ [ 317, 317 ], "mapped", [ 318 ] ], [ [ 318, 318 ], "valid" ], [ [ 319, 320 ], "mapped", [ 108, 183 ] ], [ [ 321, 321 ], "mapped", [ 322 ] ], [ [ 322, 322 ], "valid" ], [ [ 323, 323 ], "mapped", [ 324 ] ], [ [ 324, 324 ], "valid" ], [ [ 325, 325 ], "mapped", [ 326 ] ], [ [ 326, 326 ], "valid" ], [ [ 327, 327 ], "mapped", [ 328 ] ], [ [ 328, 328 ], "valid" ], [ [ 329, 329 ], "mapped", [ 700, 110 ] ], [ [ 330, 330 ], "mapped", [ 331 ] ], [ [ 331, 331 ], "valid" ], [ [ 332, 332 ], "mapped", [ 333 ] ], [ [ 333, 333 ], "valid" ], [ [ 334, 334 ], "mapped", [ 335 ] ], [ [ 335, 335 ], "valid" ], [ [ 336, 336 ], "mapped", [ 337 ] ], [ [ 337, 337 ], "valid" ], [ [ 338, 338 ], "mapped", [ 339 ] ], [ [ 339, 339 ], "valid" ], [ [ 340, 340 ], "mapped", [ 341 ] ], [ [ 341, 341 ], "valid" ], [ [ 342, 342 ], "mapped", [ 343 ] ], [ [ 343, 343 ], "valid" ], [ [ 344, 344 ], "mapped", [ 345 ] ], [ [ 345, 345 ], "valid" ], [ [ 346, 346 ], "mapped", [ 347 ] ], [ [ 347, 347 ], "valid" ], [ [ 348, 348 ], "mapped", [ 349 ] ], [ [ 349, 349 ], "valid" ], [ [ 350, 350 ], "mapped", [ 351 ] ], [ [ 351, 351 ], "valid" ], [ [ 352, 352 ], "mapped", [ 353 ] ], [ [ 353, 353 ], "valid" ], [ [ 354, 354 ], "mapped", [ 355 ] ], [ [ 355, 355 ], "valid" ], [ [ 356, 356 ], "mapped", [ 357 ] ], [ [ 357, 357 ], "valid" ], [ [ 358, 358 ], "mapped", [ 359 ] ], [ [ 359, 359 ], "valid" ], [ [ 360, 360 ], "mapped", [ 361 ] ], [ [ 361, 361 ], "valid" ], [ [ 362, 362 ], "mapped", [ 363 ] ], [ [ 363, 363 ], "valid" ], [ [ 364, 364 ], "mapped", [ 365 ] ], [ [ 365, 365 ], "valid" ], [ [ 366, 366 ], "mapped", [ 367 ] ], [ [ 367, 367 ], "valid" ], [ [ 368, 368 ], "mapped", [ 369 ] ], [ [ 369, 369 ], "valid" ], [ [ 370, 370 ], "mapped", [ 371 ] ], [ [ 371, 371 ], "valid" ], [ [ 372, 372 ], "mapped", [ 373 ] ], [ [ 373, 373 ], "valid" ], [ [ 374, 374 ], "mapped", [ 375 ] ], [ [ 375, 375 ], "valid" ], [ [ 376, 376 ], "mapped", [ 255 ] ], [ [ 377, 377 ], "mapped", [ 378 ] ], [ [ 378, 378 ], "valid" ], [ [ 379, 379 ], "mapped", [ 380 ] ], [ [ 380, 380 ], "valid" ], [ [ 381, 381 ], "mapped", [ 382 ] ], [ [ 382, 382 ], "valid" ], [ [ 383, 383 ], "mapped", [ 115 ] ], [ [ 384, 384 ], "valid" ], [ [ 385, 385 ], "mapped", [ 595 ] ], [ [ 386, 386 ], "mapped", [ 387 ] ], [ [ 387, 387 ], "valid" ], [ [ 388, 388 ], "mapped", [ 389 ] ], [ [ 389, 389 ], "valid" ], [ [ 390, 390 ], "mapped", [ 596 ] ], [ [ 391, 391 ], "mapped", [ 392 ] ], [ [ 392, 392 ], "valid" ], [ [ 393, 393 ], "mapped", [ 598 ] ], [ [ 394, 394 ], "mapped", [ 599 ] ], [ [ 395, 395 ], "mapped", [ 396 ] ], [ [ 396, 397 ], "valid" ], [ [ 398, 398 ], "mapped", [ 477 ] ], [ [ 399, 399 ], "mapped", [ 601 ] ], [ [ 400, 400 ], "mapped", [ 603 ] ], [ [ 401, 401 ], "mapped", [ 402 ] ], [ [ 402, 402 ], "valid" ], [ [ 403, 403 ], "mapped", [ 608 ] ], [ [ 404, 404 ], "mapped", [ 611 ] ], [ [ 405, 405 ], "valid" ], [ [ 406, 406 ], "mapped", [ 617 ] ], [ [ 407, 407 ], "mapped", [ 616 ] ], [ [ 408, 408 ], "mapped", [ 409 ] ], [ [ 409, 411 ], "valid" ], [ [ 412, 412 ], "mapped", [ 623 ] ], [ [ 413, 413 ], "mapped", [ 626 ] ], [ [ 414, 414 ], "valid" ], [ [ 415, 415 ], "mapped", [ 629 ] ], [ [ 416, 416 ], "mapped", [ 417 ] ], [ [ 417, 417 ], "valid" ], [ [ 418, 418 ], "mapped", [ 419 ] ], [ [ 419, 419 ], "valid" ], [ [ 420, 420 ], "mapped", [ 421 ] ], [ [ 421, 421 ], "valid" ], [ [ 422, 422 ], "mapped", [ 640 ] ], [ [ 423, 423 ], "mapped", [ 424 ] ], [ [ 424, 424 ], "valid" ], [ [ 425, 425 ], "mapped", [ 643 ] ], [ [ 426, 427 ], "valid" ], [ [ 428, 428 ], "mapped", [ 429 ] ], [ [ 429, 429 ], "valid" ], [ [ 430, 430 ], "mapped", [ 648 ] ], [ [ 431, 431 ], "mapped", [ 432 ] ], [ [ 432, 432 ], "valid" ], [ [ 433, 433 ], "mapped", [ 650 ] ], [ [ 434, 434 ], "mapped", [ 651 ] ], [ [ 435, 435 ], "mapped", [ 436 ] ], [ [ 436, 436 ], "valid" ], [ [ 437, 437 ], "mapped", [ 438 ] ], [ [ 438, 438 ], "valid" ], [ [ 439, 439 ], "mapped", [ 658 ] ], [ [ 440, 440 ], "mapped", [ 441 ] ], [ [ 441, 443 ], "valid" ], [ [ 444, 444 ], "mapped", [ 445 ] ], [ [ 445, 451 ], "valid" ], [ [ 452, 454 ], "mapped", [ 100, 382 ] ], [ [ 455, 457 ], "mapped", [ 108, 106 ] ], [ [ 458, 460 ], "mapped", [ 110, 106 ] ], [ [ 461, 461 ], "mapped", [ 462 ] ], [ [ 462, 462 ], "valid" ], [ [ 463, 463 ], "mapped", [ 464 ] ], [ [ 464, 464 ], "valid" ], [ [ 465, 465 ], "mapped", [ 466 ] ], [ [ 466, 466 ], "valid" ], [ [ 467, 467 ], "mapped", [ 468 ] ], [ [ 468, 468 ], "valid" ], [ [ 469, 469 ], "mapped", [ 470 ] ], [ [ 470, 470 ], "valid" ], [ [ 471, 471 ], "mapped", [ 472 ] ], [ [ 472, 472 ], "valid" ], [ [ 473, 473 ], "mapped", [ 474 ] ], [ [ 474, 474 ], "valid" ], [ [ 475, 475 ], "mapped", [ 476 ] ], [ [ 476, 477 ], "valid" ], [ [ 478, 478 ], "mapped", [ 479 ] ], [ [ 479, 479 ], "valid" ], [ [ 480, 480 ], "mapped", [ 481 ] ], [ [ 481, 481 ], "valid" ], [ [ 482, 482 ], "mapped", [ 483 ] ], [ [ 483, 483 ], "valid" ], [ [ 484, 484 ], "mapped", [ 485 ] ], [ [ 485, 485 ], "valid" ], [ [ 486, 486 ], "mapped", [ 487 ] ], [ [ 487, 487 ], "valid" ], [ [ 488, 488 ], "mapped", [ 489 ] ], [ [ 489, 489 ], "valid" ], [ [ 490, 490 ], "mapped", [ 491 ] ], [ [ 491, 491 ], "valid" ], [ [ 492, 492 ], "mapped", [ 493 ] ], [ [ 493, 493 ], "valid" ], [ [ 494, 494 ], "mapped", [ 495 ] ], [ [ 495, 496 ], "valid" ], [ [ 497, 499 ], "mapped", [ 100, 122 ] ], [ [ 500, 500 ], "mapped", [ 501 ] ], [ [ 501, 501 ], "valid" ], [ [ 502, 502 ], "mapped", [ 405 ] ], [ [ 503, 503 ], "mapped", [ 447 ] ], [ [ 504, 504 ], "mapped", [ 505 ] ], [ [ 505, 505 ], "valid" ], [ [ 506, 506 ], "mapped", [ 507 ] ], [ [ 507, 507 ], "valid" ], [ [ 508, 508 ], "mapped", [ 509 ] ], [ [ 509, 509 ], "valid" ], [ [ 510, 510 ], "mapped", [ 511 ] ], [ [ 511, 511 ], "valid" ], [ [ 512, 512 ], "mapped", [ 513 ] ], [ [ 513, 513 ], "valid" ], [ [ 514, 514 ], "mapped", [ 515 ] ], [ [ 515, 515 ], "valid" ], [ [ 516, 516 ], "mapped", [ 517 ] ], [ [ 517, 517 ], "valid" ], [ [ 518, 518 ], "mapped", [ 519 ] ], [ [ 519, 519 ], "valid" ], [ [ 520, 520 ], "mapped", [ 521 ] ], [ [ 521, 521 ], "valid" ], [ [ 522, 522 ], "mapped", [ 523 ] ], [ [ 523, 523 ], "valid" ], [ [ 524, 524 ], "mapped", [ 525 ] ], [ [ 525, 525 ], "valid" ], [ [ 526, 526 ], "mapped", [ 527 ] ], [ [ 527, 527 ], "valid" ], [ [ 528, 528 ], "mapped", [ 529 ] ], [ [ 529, 529 ], "valid" ], [ [ 530, 530 ], "mapped", [ 531 ] ], [ [ 531, 531 ], "valid" ], [ [ 532, 532 ], "mapped", [ 533 ] ], [ [ 533, 533 ], "valid" ], [ [ 534, 534 ], "mapped", [ 535 ] ], [ [ 535, 535 ], "valid" ], [ [ 536, 536 ], "mapped", [ 537 ] ], [ [ 537, 537 ], "valid" ], [ [ 538, 538 ], "mapped", [ 539 ] ], [ [ 539, 539 ], "valid" ], [ [ 540, 540 ], "mapped", [ 541 ] ], [ [ 541, 541 ], "valid" ], [ [ 542, 542 ], "mapped", [ 543 ] ], [ [ 543, 543 ], "valid" ], [ [ 544, 544 ], "mapped", [ 414 ] ], [ [ 545, 545 ], "valid" ], [ [ 546, 546 ], "mapped", [ 547 ] ], [ [ 547, 547 ], "valid" ], [ [ 548, 548 ], "mapped", [ 549 ] ], [ [ 549, 549 ], "valid" ], [ [ 550, 550 ], "mapped", [ 551 ] ], [ [ 551, 551 ], "valid" ], [ [ 552, 552 ], "mapped", [ 553 ] ], [ [ 553, 553 ], "valid" ], [ [ 554, 554 ], "mapped", [ 555 ] ], [ [ 555, 555 ], "valid" ], [ [ 556, 556 ], "mapped", [ 557 ] ], [ [ 557, 557 ], "valid" ], [ [ 558, 558 ], "mapped", [ 559 ] ], [ [ 559, 559 ], "valid" ], [ [ 560, 560 ], "mapped", [ 561 ] ], [ [ 561, 561 ], "valid" ], [ [ 562, 562 ], "mapped", [ 563 ] ], [ [ 563, 563 ], "valid" ], [ [ 564, 566 ], "valid" ], [ [ 567, 569 ], "valid" ], [ [ 570, 570 ], "mapped", [ 11365 ] ], [ [ 571, 571 ], "mapped", [ 572 ] ], [ [ 572, 572 ], "valid" ], [ [ 573, 573 ], "mapped", [ 410 ] ], [ [ 574, 574 ], "mapped", [ 11366 ] ], [ [ 575, 576 ], "valid" ], [ [ 577, 577 ], "mapped", [ 578 ] ], [ [ 578, 578 ], "valid" ], [ [ 579, 579 ], "mapped", [ 384 ] ], [ [ 580, 580 ], "mapped", [ 649 ] ], [ [ 581, 581 ], "mapped", [ 652 ] ], [ [ 582, 582 ], "mapped", [ 583 ] ], [ [ 583, 583 ], "valid" ], [ [ 584, 584 ], "mapped", [ 585 ] ], [ [ 585, 585 ], "valid" ], [ [ 586, 586 ], "mapped", [ 587 ] ], [ [ 587, 587 ], "valid" ], [ [ 588, 588 ], "mapped", [ 589 ] ], [ [ 589, 589 ], "valid" ], [ [ 590, 590 ], "mapped", [ 591 ] ], [ [ 591, 591 ], "valid" ], [ [ 592, 680 ], "valid" ], [ [ 681, 685 ], "valid" ], [ [ 686, 687 ], "valid" ], [ [ 688, 688 ], "mapped", [ 104 ] ], [ [ 689, 689 ], "mapped", [ 614 ] ], [ [ 690, 690 ], "mapped", [ 106 ] ], [ [ 691, 691 ], "mapped", [ 114 ] ], [ [ 692, 692 ], "mapped", [ 633 ] ], [ [ 693, 693 ], "mapped", [ 635 ] ], [ [ 694, 694 ], "mapped", [ 641 ] ], [ [ 695, 695 ], "mapped", [ 119 ] ], [ [ 696, 696 ], "mapped", [ 121 ] ], [ [ 697, 705 ], "valid" ], [ [ 706, 709 ], "valid", [], "NV8" ], [ [ 710, 721 ], "valid" ], [ [ 722, 727 ], "valid", [], "NV8" ], [ [ 728, 728 ], "disallowed_STD3_mapped", [ 32, 774 ] ], [ [ 729, 729 ], "disallowed_STD3_mapped", [ 32, 775 ] ], [ [ 730, 730 ], "disallowed_STD3_mapped", [ 32, 778 ] ], [ [ 731, 731 ], "disallowed_STD3_mapped", [ 32, 808 ] ], [ [ 732, 732 ], "disallowed_STD3_mapped", [ 32, 771 ] ], [ [ 733, 733 ], "disallowed_STD3_mapped", [ 32, 779 ] ], [ [ 734, 734 ], "valid", [], "NV8" ], [ [ 735, 735 ], "valid", [], "NV8" ], [ [ 736, 736 ], "mapped", [ 611 ] ], [ [ 737, 737 ], "mapped", [ 108 ] ], [ [ 738, 738 ], "mapped", [ 115 ] ], [ [ 739, 739 ], "mapped", [ 120 ] ], [ [ 740, 740 ], "mapped", [ 661 ] ], [ [ 741, 745 ], "valid", [], "NV8" ], [ [ 746, 747 ], "valid", [], "NV8" ], [ [ 748, 748 ], "valid" ], [ [ 749, 749 ], "valid", [], "NV8" ], [ [ 750, 750 ], "valid" ], [ [ 751, 767 ], "valid", [], "NV8" ], [ [ 768, 831 ], "valid" ], [ [ 832, 832 ], "mapped", [ 768 ] ], [ [ 833, 833 ], "mapped", [ 769 ] ], [ [ 834, 834 ], "valid" ], [ [ 835, 835 ], "mapped", [ 787 ] ], [ [ 836, 836 ], "mapped", [ 776, 769 ] ], [ [ 837, 837 ], "mapped", [ 953 ] ], [ [ 838, 846 ], "valid" ], [ [ 847, 847 ], "ignored" ], [ [ 848, 855 ], "valid" ], [ [ 856, 860 ], "valid" ], [ [ 861, 863 ], "valid" ], [ [ 864, 865 ], "valid" ], [ [ 866, 866 ], "valid" ], [ [ 867, 879 ], "valid" ], [ [ 880, 880 ], "mapped", [ 881 ] ], [ [ 881, 881 ], "valid" ], [ [ 882, 882 ], "mapped", [ 883 ] ], [ [ 883, 883 ], "valid" ], [ [ 884, 884 ], "mapped", [ 697 ] ], [ [ 885, 885 ], "valid" ], [ [ 886, 886 ], "mapped", [ 887 ] ], [ [ 887, 887 ], "valid" ], [ [ 888, 889 ], "disallowed" ], [ [ 890, 890 ], "disallowed_STD3_mapped", [ 32, 953 ] ], [ [ 891, 893 ], "valid" ], [ [ 894, 894 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 895, 895 ], "mapped", [ 1011 ] ], [ [ 896, 899 ], "disallowed" ], [ [ 900, 900 ], "disallowed_STD3_mapped", [ 32, 769 ] ], [ [ 901, 901 ], "disallowed_STD3_mapped", [ 32, 776, 769 ] ], [ [ 902, 902 ], "mapped", [ 940 ] ], [ [ 903, 903 ], "mapped", [ 183 ] ], [ [ 904, 904 ], "mapped", [ 941 ] ], [ [ 905, 905 ], "mapped", [ 942 ] ], [ [ 906, 906 ], "mapped", [ 943 ] ], [ [ 907, 907 ], "disallowed" ], [ [ 908, 908 ], "mapped", [ 972 ] ], [ [ 909, 909 ], "disallowed" ], [ [ 910, 910 ], "mapped", [ 973 ] ], [ [ 911, 911 ], "mapped", [ 974 ] ], [ [ 912, 912 ], "valid" ], [ [ 913, 913 ], "mapped", [ 945 ] ], [ [ 914, 914 ], "mapped", [ 946 ] ], [ [ 915, 915 ], "mapped", [ 947 ] ], [ [ 916, 916 ], "mapped", [ 948 ] ], [ [ 917, 917 ], "mapped", [ 949 ] ], [ [ 918, 918 ], "mapped", [ 950 ] ], [ [ 919, 919 ], "mapped", [ 951 ] ], [ [ 920, 920 ], "mapped", [ 952 ] ], [ [ 921, 921 ], "mapped", [ 953 ] ], [ [ 922, 922 ], "mapped", [ 954 ] ], [ [ 923, 923 ], "mapped", [ 955 ] ], [ [ 924, 924 ], "mapped", [ 956 ] ], [ [ 925, 925 ], "mapped", [ 957 ] ], [ [ 926, 926 ], "mapped", [ 958 ] ], [ [ 927, 927 ], "mapped", [ 959 ] ], [ [ 928, 928 ], "mapped", [ 960 ] ], [ [ 929, 929 ], "mapped", [ 961 ] ], [ [ 930, 930 ], "disallowed" ], [ [ 931, 931 ], "mapped", [ 963 ] ], [ [ 932, 932 ], "mapped", [ 964 ] ], [ [ 933, 933 ], "mapped", [ 965 ] ], [ [ 934, 934 ], "mapped", [ 966 ] ], [ [ 935, 935 ], "mapped", [ 967 ] ], [ [ 936, 936 ], "mapped", [ 968 ] ], [ [ 937, 937 ], "mapped", [ 969 ] ], [ [ 938, 938 ], "mapped", [ 970 ] ], [ [ 939, 939 ], "mapped", [ 971 ] ], [ [ 940, 961 ], "valid" ], [ [ 962, 962 ], "deviation", [ 963 ] ], [ [ 963, 974 ], "valid" ], [ [ 975, 975 ], "mapped", [ 983 ] ], [ [ 976, 976 ], "mapped", [ 946 ] ], [ [ 977, 977 ], "mapped", [ 952 ] ], [ [ 978, 978 ], "mapped", [ 965 ] ], [ [ 979, 979 ], "mapped", [ 973 ] ], [ [ 980, 980 ], "mapped", [ 971 ] ], [ [ 981, 981 ], "mapped", [ 966 ] ], [ [ 982, 982 ], "mapped", [ 960 ] ], [ [ 983, 983 ], "valid" ], [ [ 984, 984 ], "mapped", [ 985 ] ], [ [ 985, 985 ], "valid" ], [ [ 986, 986 ], "mapped", [ 987 ] ], [ [ 987, 987 ], "valid" ], [ [ 988, 988 ], "mapped", [ 989 ] ], [ [ 989, 989 ], "valid" ], [ [ 990, 990 ], "mapped", [ 991 ] ], [ [ 991, 991 ], "valid" ], [ [ 992, 992 ], "mapped", [ 993 ] ], [ [ 993, 993 ], "valid" ], [ [ 994, 994 ], "mapped", [ 995 ] ], [ [ 995, 995 ], "valid" ], [ [ 996, 996 ], "mapped", [ 997 ] ], [ [ 997, 997 ], "valid" ], [ [ 998, 998 ], "mapped", [ 999 ] ], [ [ 999, 999 ], "valid" ], [ [ 1e3, 1e3 ], "mapped", [ 1001 ] ], [ [ 1001, 1001 ], "valid" ], [ [ 1002, 1002 ], "mapped", [ 1003 ] ], [ [ 1003, 1003 ], "valid" ], [ [ 1004, 1004 ], "mapped", [ 1005 ] ], [ [ 1005, 1005 ], "valid" ], [ [ 1006, 1006 ], "mapped", [ 1007 ] ], [ [ 1007, 1007 ], "valid" ], [ [ 1008, 1008 ], "mapped", [ 954 ] ], [ [ 1009, 1009 ], "mapped", [ 961 ] ], [ [ 1010, 1010 ], "mapped", [ 963 ] ], [ [ 1011, 1011 ], "valid" ], [ [ 1012, 1012 ], "mapped", [ 952 ] ], [ [ 1013, 1013 ], "mapped", [ 949 ] ], [ [ 1014, 1014 ], "valid", [], "NV8" ], [ [ 1015, 1015 ], "mapped", [ 1016 ] ], [ [ 1016, 1016 ], "valid" ], [ [ 1017, 1017 ], "mapped", [ 963 ] ], [ [ 1018, 1018 ], "mapped", [ 1019 ] ], [ [ 1019, 1019 ], "valid" ], [ [ 1020, 1020 ], "valid" ], [ [ 1021, 1021 ], "mapped", [ 891 ] ], [ [ 1022, 1022 ], "mapped", [ 892 ] ], [ [ 1023, 1023 ], "mapped", [ 893 ] ], [ [ 1024, 1024 ], "mapped", [ 1104 ] ], [ [ 1025, 1025 ], "mapped", [ 1105 ] ], [ [ 1026, 1026 ], "mapped", [ 1106 ] ], [ [ 1027, 1027 ], "mapped", [ 1107 ] ], [ [ 1028, 1028 ], "mapped", [ 1108 ] ], [ [ 1029, 1029 ], "mapped", [ 1109 ] ], [ [ 1030, 1030 ], "mapped", [ 1110 ] ], [ [ 1031, 1031 ], "mapped", [ 1111 ] ], [ [ 1032, 1032 ], "mapped", [ 1112 ] ], [ [ 1033, 1033 ], "mapped", [ 1113 ] ], [ [ 1034, 1034 ], "mapped", [ 1114 ] ], [ [ 1035, 1035 ], "mapped", [ 1115 ] ], [ [ 1036, 1036 ], "mapped", [ 1116 ] ], [ [ 1037, 1037 ], "mapped", [ 1117 ] ], [ [ 1038, 1038 ], "mapped", [ 1118 ] ], [ [ 1039, 1039 ], "mapped", [ 1119 ] ], [ [ 1040, 1040 ], "mapped", [ 1072 ] ], [ [ 1041, 1041 ], "mapped", [ 1073 ] ], [ [ 1042, 1042 ], "mapped", [ 1074 ] ], [ [ 1043, 1043 ], "mapped", [ 1075 ] ], [ [ 1044, 1044 ], "mapped", [ 1076 ] ], [ [ 1045, 1045 ], "mapped", [ 1077 ] ], [ [ 1046, 1046 ], "mapped", [ 1078 ] ], [ [ 1047, 1047 ], "mapped", [ 1079 ] ], [ [ 1048, 1048 ], "mapped", [ 1080 ] ], [ [ 1049, 1049 ], "mapped", [ 1081 ] ], [ [ 1050, 1050 ], "mapped", [ 1082 ] ], [ [ 1051, 1051 ], "mapped", [ 1083 ] ], [ [ 1052, 1052 ], "mapped", [ 1084 ] ], [ [ 1053, 1053 ], "mapped", [ 1085 ] ], [ [ 1054, 1054 ], "mapped", [ 1086 ] ], [ [ 1055, 1055 ], "mapped", [ 1087 ] ], [ [ 1056, 1056 ], "mapped", [ 1088 ] ], [ [ 1057, 1057 ], "mapped", [ 1089 ] ], [ [ 1058, 1058 ], "mapped", [ 1090 ] ], [ [ 1059, 1059 ], "mapped", [ 1091 ] ], [ [ 1060, 1060 ], "mapped", [ 1092 ] ], [ [ 1061, 1061 ], "mapped", [ 1093 ] ], [ [ 1062, 1062 ], "mapped", [ 1094 ] ], [ [ 1063, 1063 ], "mapped", [ 1095 ] ], [ [ 1064, 1064 ], "mapped", [ 1096 ] ], [ [ 1065, 1065 ], "mapped", [ 1097 ] ], [ [ 1066, 1066 ], "mapped", [ 1098 ] ], [ [ 1067, 1067 ], "mapped", [ 1099 ] ], [ [ 1068, 1068 ], "mapped", [ 1100 ] ], [ [ 1069, 1069 ], "mapped", [ 1101 ] ], [ [ 1070, 1070 ], "mapped", [ 1102 ] ], [ [ 1071, 1071 ], "mapped", [ 1103 ] ], [ [ 1072, 1103 ], "valid" ], [ [ 1104, 1104 ], "valid" ], [ [ 1105, 1116 ], "valid" ], [ [ 1117, 1117 ], "valid" ], [ [ 1118, 1119 ], "valid" ], [ [ 1120, 1120 ], "mapped", [ 1121 ] ], [ [ 1121, 1121 ], "valid" ], [ [ 1122, 1122 ], "mapped", [ 1123 ] ], [ [ 1123, 1123 ], "valid" ], [ [ 1124, 1124 ], "mapped", [ 1125 ] ], [ [ 1125, 1125 ], "valid" ], [ [ 1126, 1126 ], "mapped", [ 1127 ] ], [ [ 1127, 1127 ], "valid" ], [ [ 1128, 1128 ], "mapped", [ 1129 ] ], [ [ 1129, 1129 ], "valid" ], [ [ 1130, 1130 ], "mapped", [ 1131 ] ], [ [ 1131, 1131 ], "valid" ], [ [ 1132, 1132 ], "mapped", [ 1133 ] ], [ [ 1133, 1133 ], "valid" ], [ [ 1134, 1134 ], "mapped", [ 1135 ] ], [ [ 1135, 1135 ], "valid" ], [ [ 1136, 1136 ], "mapped", [ 1137 ] ], [ [ 1137, 1137 ], "valid" ], [ [ 1138, 1138 ], "mapped", [ 1139 ] ], [ [ 1139, 1139 ], "valid" ], [ [ 1140, 1140 ], "mapped", [ 1141 ] ], [ [ 1141, 1141 ], "valid" ], [ [ 1142, 1142 ], "mapped", [ 1143 ] ], [ [ 1143, 1143 ], "valid" ], [ [ 1144, 1144 ], "mapped", [ 1145 ] ], [ [ 1145, 1145 ], "valid" ], [ [ 1146, 1146 ], "mapped", [ 1147 ] ], [ [ 1147, 1147 ], "valid" ], [ [ 1148, 1148 ], "mapped", [ 1149 ] ], [ [ 1149, 1149 ], "valid" ], [ [ 1150, 1150 ], "mapped", [ 1151 ] ], [ [ 1151, 1151 ], "valid" ], [ [ 1152, 1152 ], "mapped", [ 1153 ] ], [ [ 1153, 1153 ], "valid" ], [ [ 1154, 1154 ], "valid", [], "NV8" ], [ [ 1155, 1158 ], "valid" ], [ [ 1159, 1159 ], "valid" ], [ [ 1160, 1161 ], "valid", [], "NV8" ], [ [ 1162, 1162 ], "mapped", [ 1163 ] ], [ [ 1163, 1163 ], "valid" ], [ [ 1164, 1164 ], "mapped", [ 1165 ] ], [ [ 1165, 1165 ], "valid" ], [ [ 1166, 1166 ], "mapped", [ 1167 ] ], [ [ 1167, 1167 ], "valid" ], [ [ 1168, 1168 ], "mapped", [ 1169 ] ], [ [ 1169, 1169 ], "valid" ], [ [ 1170, 1170 ], "mapped", [ 1171 ] ], [ [ 1171, 1171 ], "valid" ], [ [ 1172, 1172 ], "mapped", [ 1173 ] ], [ [ 1173, 1173 ], "valid" ], [ [ 1174, 1174 ], "mapped", [ 1175 ] ], [ [ 1175, 1175 ], "valid" ], [ [ 1176, 1176 ], "mapped", [ 1177 ] ], [ [ 1177, 1177 ], "valid" ], [ [ 1178, 1178 ], "mapped", [ 1179 ] ], [ [ 1179, 1179 ], "valid" ], [ [ 1180, 1180 ], "mapped", [ 1181 ] ], [ [ 1181, 1181 ], "valid" ], [ [ 1182, 1182 ], "mapped", [ 1183 ] ], [ [ 1183, 1183 ], "valid" ], [ [ 1184, 1184 ], "mapped", [ 1185 ] ], [ [ 1185, 1185 ], "valid" ], [ [ 1186, 1186 ], "mapped", [ 1187 ] ], [ [ 1187, 1187 ], "valid" ], [ [ 1188, 1188 ], "mapped", [ 1189 ] ], [ [ 1189, 1189 ], "valid" ], [ [ 1190, 1190 ], "mapped", [ 1191 ] ], [ [ 1191, 1191 ], "valid" ], [ [ 1192, 1192 ], "mapped", [ 1193 ] ], [ [ 1193, 1193 ], "valid" ], [ [ 1194, 1194 ], "mapped", [ 1195 ] ], [ [ 1195, 1195 ], "valid" ], [ [ 1196, 1196 ], "mapped", [ 1197 ] ], [ [ 1197, 1197 ], "valid" ], [ [ 1198, 1198 ], "mapped", [ 1199 ] ], [ [ 1199, 1199 ], "valid" ], [ [ 1200, 1200 ], "mapped", [ 1201 ] ], [ [ 1201, 1201 ], "valid" ], [ [ 1202, 1202 ], "mapped", [ 1203 ] ], [ [ 1203, 1203 ], "valid" ], [ [ 1204, 1204 ], "mapped", [ 1205 ] ], [ [ 1205, 1205 ], "valid" ], [ [ 1206, 1206 ], "mapped", [ 1207 ] ], [ [ 1207, 1207 ], "valid" ], [ [ 1208, 1208 ], "mapped", [ 1209 ] ], [ [ 1209, 1209 ], "valid" ], [ [ 1210, 1210 ], "mapped", [ 1211 ] ], [ [ 1211, 1211 ], "valid" ], [ [ 1212, 1212 ], "mapped", [ 1213 ] ], [ [ 1213, 1213 ], "valid" ], [ [ 1214, 1214 ], "mapped", [ 1215 ] ], [ [ 1215, 1215 ], "valid" ], [ [ 1216, 1216 ], "disallowed" ], [ [ 1217, 1217 ], "mapped", [ 1218 ] ], [ [ 1218, 1218 ], "valid" ], [ [ 1219, 1219 ], "mapped", [ 1220 ] ], [ [ 1220, 1220 ], "valid" ], [ [ 1221, 1221 ], "mapped", [ 1222 ] ], [ [ 1222, 1222 ], "valid" ], [ [ 1223, 1223 ], "mapped", [ 1224 ] ], [ [ 1224, 1224 ], "valid" ], [ [ 1225, 1225 ], "mapped", [ 1226 ] ], [ [ 1226, 1226 ], "valid" ], [ [ 1227, 1227 ], "mapped", [ 1228 ] ], [ [ 1228, 1228 ], "valid" ], [ [ 1229, 1229 ], "mapped", [ 1230 ] ], [ [ 1230, 1230 ], "valid" ], [ [ 1231, 1231 ], "valid" ], [ [ 1232, 1232 ], "mapped", [ 1233 ] ], [ [ 1233, 1233 ], "valid" ], [ [ 1234, 1234 ], "mapped", [ 1235 ] ], [ [ 1235, 1235 ], "valid" ], [ [ 1236, 1236 ], "mapped", [ 1237 ] ], [ [ 1237, 1237 ], "valid" ], [ [ 1238, 1238 ], "mapped", [ 1239 ] ], [ [ 1239, 1239 ], "valid" ], [ [ 1240, 1240 ], "mapped", [ 1241 ] ], [ [ 1241, 1241 ], "valid" ], [ [ 1242, 1242 ], "mapped", [ 1243 ] ], [ [ 1243, 1243 ], "valid" ], [ [ 1244, 1244 ], "mapped", [ 1245 ] ], [ [ 1245, 1245 ], "valid" ], [ [ 1246, 1246 ], "mapped", [ 1247 ] ], [ [ 1247, 1247 ], "valid" ], [ [ 1248, 1248 ], "mapped", [ 1249 ] ], [ [ 1249, 1249 ], "valid" ], [ [ 1250, 1250 ], "mapped", [ 1251 ] ], [ [ 1251, 1251 ], "valid" ], [ [ 1252, 1252 ], "mapped", [ 1253 ] ], [ [ 1253, 1253 ], "valid" ], [ [ 1254, 1254 ], "mapped", [ 1255 ] ], [ [ 1255, 1255 ], "valid" ], [ [ 1256, 1256 ], "mapped", [ 1257 ] ], [ [ 1257, 1257 ], "valid" ], [ [ 1258, 1258 ], "mapped", [ 1259 ] ], [ [ 1259, 1259 ], "valid" ], [ [ 1260, 1260 ], "mapped", [ 1261 ] ], [ [ 1261, 1261 ], "valid" ], [ [ 1262, 1262 ], "mapped", [ 1263 ] ], [ [ 1263, 1263 ], "valid" ], [ [ 1264, 1264 ], "mapped", [ 1265 ] ], [ [ 1265, 1265 ], "valid" ], [ [ 1266, 1266 ], "mapped", [ 1267 ] ], [ [ 1267, 1267 ], "valid" ], [ [ 1268, 1268 ], "mapped", [ 1269 ] ], [ [ 1269, 1269 ], "valid" ], [ [ 1270, 1270 ], "mapped", [ 1271 ] ], [ [ 1271, 1271 ], "valid" ], [ [ 1272, 1272 ], "mapped", [ 1273 ] ], [ [ 1273, 1273 ], "valid" ], [ [ 1274, 1274 ], "mapped", [ 1275 ] ], [ [ 1275, 1275 ], "valid" ], [ [ 1276, 1276 ], "mapped", [ 1277 ] ], [ [ 1277, 1277 ], "valid" ], [ [ 1278, 1278 ], "mapped", [ 1279 ] ], [ [ 1279, 1279 ], "valid" ], [ [ 1280, 1280 ], "mapped", [ 1281 ] ], [ [ 1281, 1281 ], "valid" ], [ [ 1282, 1282 ], "mapped", [ 1283 ] ], [ [ 1283, 1283 ], "valid" ], [ [ 1284, 1284 ], "mapped", [ 1285 ] ], [ [ 1285, 1285 ], "valid" ], [ [ 1286, 1286 ], "mapped", [ 1287 ] ], [ [ 1287, 1287 ], "valid" ], [ [ 1288, 1288 ], "mapped", [ 1289 ] ], [ [ 1289, 1289 ], "valid" ], [ [ 1290, 1290 ], "mapped", [ 1291 ] ], [ [ 1291, 1291 ], "valid" ], [ [ 1292, 1292 ], "mapped", [ 1293 ] ], [ [ 1293, 1293 ], "valid" ], [ [ 1294, 1294 ], "mapped", [ 1295 ] ], [ [ 1295, 1295 ], "valid" ], [ [ 1296, 1296 ], "mapped", [ 1297 ] ], [ [ 1297, 1297 ], "valid" ], [ [ 1298, 1298 ], "mapped", [ 1299 ] ], [ [ 1299, 1299 ], "valid" ], [ [ 1300, 1300 ], "mapped", [ 1301 ] ], [ [ 1301, 1301 ], "valid" ], [ [ 1302, 1302 ], "mapped", [ 1303 ] ], [ [ 1303, 1303 ], "valid" ], [ [ 1304, 1304 ], "mapped", [ 1305 ] ], [ [ 1305, 1305 ], "valid" ], [ [ 1306, 1306 ], "mapped", [ 1307 ] ], [ [ 1307, 1307 ], "valid" ], [ [ 1308, 1308 ], "mapped", [ 1309 ] ], [ [ 1309, 1309 ], "valid" ], [ [ 1310, 1310 ], "mapped", [ 1311 ] ], [ [ 1311, 1311 ], "valid" ], [ [ 1312, 1312 ], "mapped", [ 1313 ] ], [ [ 1313, 1313 ], "valid" ], [ [ 1314, 1314 ], "mapped", [ 1315 ] ], [ [ 1315, 1315 ], "valid" ], [ [ 1316, 1316 ], "mapped", [ 1317 ] ], [ [ 1317, 1317 ], "valid" ], [ [ 1318, 1318 ], "mapped", [ 1319 ] ], [ [ 1319, 1319 ], "valid" ], [ [ 1320, 1320 ], "mapped", [ 1321 ] ], [ [ 1321, 1321 ], "valid" ], [ [ 1322, 1322 ], "mapped", [ 1323 ] ], [ [ 1323, 1323 ], "valid" ], [ [ 1324, 1324 ], "mapped", [ 1325 ] ], [ [ 1325, 1325 ], "valid" ], [ [ 1326, 1326 ], "mapped", [ 1327 ] ], [ [ 1327, 1327 ], "valid" ], [ [ 1328, 1328 ], "disallowed" ], [ [ 1329, 1329 ], "mapped", [ 1377 ] ], [ [ 1330, 1330 ], "mapped", [ 1378 ] ], [ [ 1331, 1331 ], "mapped", [ 1379 ] ], [ [ 1332, 1332 ], "mapped", [ 1380 ] ], [ [ 1333, 1333 ], "mapped", [ 1381 ] ], [ [ 1334, 1334 ], "mapped", [ 1382 ] ], [ [ 1335, 1335 ], "mapped", [ 1383 ] ], [ [ 1336, 1336 ], "mapped", [ 1384 ] ], [ [ 1337, 1337 ], "mapped", [ 1385 ] ], [ [ 1338, 1338 ], "mapped", [ 1386 ] ], [ [ 1339, 1339 ], "mapped", [ 1387 ] ], [ [ 1340, 1340 ], "mapped", [ 1388 ] ], [ [ 1341, 1341 ], "mapped", [ 1389 ] ], [ [ 1342, 1342 ], "mapped", [ 1390 ] ], [ [ 1343, 1343 ], "mapped", [ 1391 ] ], [ [ 1344, 1344 ], "mapped", [ 1392 ] ], [ [ 1345, 1345 ], "mapped", [ 1393 ] ], [ [ 1346, 1346 ], "mapped", [ 1394 ] ], [ [ 1347, 1347 ], "mapped", [ 1395 ] ], [ [ 1348, 1348 ], "mapped", [ 1396 ] ], [ [ 1349, 1349 ], "mapped", [ 1397 ] ], [ [ 1350, 1350 ], "mapped", [ 1398 ] ], [ [ 1351, 1351 ], "mapped", [ 1399 ] ], [ [ 1352, 1352 ], "mapped", [ 1400 ] ], [ [ 1353, 1353 ], "mapped", [ 1401 ] ], [ [ 1354, 1354 ], "mapped", [ 1402 ] ], [ [ 1355, 1355 ], "mapped", [ 1403 ] ], [ [ 1356, 1356 ], "mapped", [ 1404 ] ], [ [ 1357, 1357 ], "mapped", [ 1405 ] ], [ [ 1358, 1358 ], "mapped", [ 1406 ] ], [ [ 1359, 1359 ], "mapped", [ 1407 ] ], [ [ 1360, 1360 ], "mapped", [ 1408 ] ], [ [ 1361, 1361 ], "mapped", [ 1409 ] ], [ [ 1362, 1362 ], "mapped", [ 1410 ] ], [ [ 1363, 1363 ], "mapped", [ 1411 ] ], [ [ 1364, 1364 ], "mapped", [ 1412 ] ], [ [ 1365, 1365 ], "mapped", [ 1413 ] ], [ [ 1366, 1366 ], "mapped", [ 1414 ] ], [ [ 1367, 1368 ], "disallowed" ], [ [ 1369, 1369 ], "valid" ], [ [ 1370, 1375 ], "valid", [], "NV8" ], [ [ 1376, 1376 ], "disallowed" ], [ [ 1377, 1414 ], "valid" ], [ [ 1415, 1415 ], "mapped", [ 1381, 1410 ] ], [ [ 1416, 1416 ], "disallowed" ], [ [ 1417, 1417 ], "valid", [], "NV8" ], [ [ 1418, 1418 ], "valid", [], "NV8" ], [ [ 1419, 1420 ], "disallowed" ], [ [ 1421, 1422 ], "valid", [], "NV8" ], [ [ 1423, 1423 ], "valid", [], "NV8" ], [ [ 1424, 1424 ], "disallowed" ], [ [ 1425, 1441 ], "valid" ], [ [ 1442, 1442 ], "valid" ], [ [ 1443, 1455 ], "valid" ], [ [ 1456, 1465 ], "valid" ], [ [ 1466, 1466 ], "valid" ], [ [ 1467, 1469 ], "valid" ], [ [ 1470, 1470 ], "valid", [], "NV8" ], [ [ 1471, 1471 ], "valid" ], [ [ 1472, 1472 ], "valid", [], "NV8" ], [ [ 1473, 1474 ], "valid" ], [ [ 1475, 1475 ], "valid", [], "NV8" ], [ [ 1476, 1476 ], "valid" ], [ [ 1477, 1477 ], "valid" ], [ [ 1478, 1478 ], "valid", [], "NV8" ], [ [ 1479, 1479 ], "valid" ], [ [ 1480, 1487 ], "disallowed" ], [ [ 1488, 1514 ], "valid" ], [ [ 1515, 1519 ], "disallowed" ], [ [ 1520, 1524 ], "valid" ], [ [ 1525, 1535 ], "disallowed" ], [ [ 1536, 1539 ], "disallowed" ], [ [ 1540, 1540 ], "disallowed" ], [ [ 1541, 1541 ], "disallowed" ], [ [ 1542, 1546 ], "valid", [], "NV8" ], [ [ 1547, 1547 ], "valid", [], "NV8" ], [ [ 1548, 1548 ], "valid", [], "NV8" ], [ [ 1549, 1551 ], "valid", [], "NV8" ], [ [ 1552, 1557 ], "valid" ], [ [ 1558, 1562 ], "valid" ], [ [ 1563, 1563 ], "valid", [], "NV8" ], [ [ 1564, 1564 ], "disallowed" ], [ [ 1565, 1565 ], "disallowed" ], [ [ 1566, 1566 ], "valid", [], "NV8" ], [ [ 1567, 1567 ], "valid", [], "NV8" ], [ [ 1568, 1568 ], "valid" ], [ [ 1569, 1594 ], "valid" ], [ [ 1595, 1599 ], "valid" ], [ [ 1600, 1600 ], "valid", [], "NV8" ], [ [ 1601, 1618 ], "valid" ], [ [ 1619, 1621 ], "valid" ], [ [ 1622, 1624 ], "valid" ], [ [ 1625, 1630 ], "valid" ], [ [ 1631, 1631 ], "valid" ], [ [ 1632, 1641 ], "valid" ], [ [ 1642, 1645 ], "valid", [], "NV8" ], [ [ 1646, 1647 ], "valid" ], [ [ 1648, 1652 ], "valid" ], [ [ 1653, 1653 ], "mapped", [ 1575, 1652 ] ], [ [ 1654, 1654 ], "mapped", [ 1608, 1652 ] ], [ [ 1655, 1655 ], "mapped", [ 1735, 1652 ] ], [ [ 1656, 1656 ], "mapped", [ 1610, 1652 ] ], [ [ 1657, 1719 ], "valid" ], [ [ 1720, 1721 ], "valid" ], [ [ 1722, 1726 ], "valid" ], [ [ 1727, 1727 ], "valid" ], [ [ 1728, 1742 ], "valid" ], [ [ 1743, 1743 ], "valid" ], [ [ 1744, 1747 ], "valid" ], [ [ 1748, 1748 ], "valid", [], "NV8" ], [ [ 1749, 1756 ], "valid" ], [ [ 1757, 1757 ], "disallowed" ], [ [ 1758, 1758 ], "valid", [], "NV8" ], [ [ 1759, 1768 ], "valid" ], [ [ 1769, 1769 ], "valid", [], "NV8" ], [ [ 1770, 1773 ], "valid" ], [ [ 1774, 1775 ], "valid" ], [ [ 1776, 1785 ], "valid" ], [ [ 1786, 1790 ], "valid" ], [ [ 1791, 1791 ], "valid" ], [ [ 1792, 1805 ], "valid", [], "NV8" ], [ [ 1806, 1806 ], "disallowed" ], [ [ 1807, 1807 ], "disallowed" ], [ [ 1808, 1836 ], "valid" ], [ [ 1837, 1839 ], "valid" ], [ [ 1840, 1866 ], "valid" ], [ [ 1867, 1868 ], "disallowed" ], [ [ 1869, 1871 ], "valid" ], [ [ 1872, 1901 ], "valid" ], [ [ 1902, 1919 ], "valid" ], [ [ 1920, 1968 ], "valid" ], [ [ 1969, 1969 ], "valid" ], [ [ 1970, 1983 ], "disallowed" ], [ [ 1984, 2037 ], "valid" ], [ [ 2038, 2042 ], "valid", [], "NV8" ], [ [ 2043, 2047 ], "disallowed" ], [ [ 2048, 2093 ], "valid" ], [ [ 2094, 2095 ], "disallowed" ], [ [ 2096, 2110 ], "valid", [], "NV8" ], [ [ 2111, 2111 ], "disallowed" ], [ [ 2112, 2139 ], "valid" ], [ [ 2140, 2141 ], "disallowed" ], [ [ 2142, 2142 ], "valid", [], "NV8" ], [ [ 2143, 2207 ], "disallowed" ], [ [ 2208, 2208 ], "valid" ], [ [ 2209, 2209 ], "valid" ], [ [ 2210, 2220 ], "valid" ], [ [ 2221, 2226 ], "valid" ], [ [ 2227, 2228 ], "valid" ], [ [ 2229, 2274 ], "disallowed" ], [ [ 2275, 2275 ], "valid" ], [ [ 2276, 2302 ], "valid" ], [ [ 2303, 2303 ], "valid" ], [ [ 2304, 2304 ], "valid" ], [ [ 2305, 2307 ], "valid" ], [ [ 2308, 2308 ], "valid" ], [ [ 2309, 2361 ], "valid" ], [ [ 2362, 2363 ], "valid" ], [ [ 2364, 2381 ], "valid" ], [ [ 2382, 2382 ], "valid" ], [ [ 2383, 2383 ], "valid" ], [ [ 2384, 2388 ], "valid" ], [ [ 2389, 2389 ], "valid" ], [ [ 2390, 2391 ], "valid" ], [ [ 2392, 2392 ], "mapped", [ 2325, 2364 ] ], [ [ 2393, 2393 ], "mapped", [ 2326, 2364 ] ], [ [ 2394, 2394 ], "mapped", [ 2327, 2364 ] ], [ [ 2395, 2395 ], "mapped", [ 2332, 2364 ] ], [ [ 2396, 2396 ], "mapped", [ 2337, 2364 ] ], [ [ 2397, 2397 ], "mapped", [ 2338, 2364 ] ], [ [ 2398, 2398 ], "mapped", [ 2347, 2364 ] ], [ [ 2399, 2399 ], "mapped", [ 2351, 2364 ] ], [ [ 2400, 2403 ], "valid" ], [ [ 2404, 2405 ], "valid", [], "NV8" ], [ [ 2406, 2415 ], "valid" ], [ [ 2416, 2416 ], "valid", [], "NV8" ], [ [ 2417, 2418 ], "valid" ], [ [ 2419, 2423 ], "valid" ], [ [ 2424, 2424 ], "valid" ], [ [ 2425, 2426 ], "valid" ], [ [ 2427, 2428 ], "valid" ], [ [ 2429, 2429 ], "valid" ], [ [ 2430, 2431 ], "valid" ], [ [ 2432, 2432 ], "valid" ], [ [ 2433, 2435 ], "valid" ], [ [ 2436, 2436 ], "disallowed" ], [ [ 2437, 2444 ], "valid" ], [ [ 2445, 2446 ], "disallowed" ], [ [ 2447, 2448 ], "valid" ], [ [ 2449, 2450 ], "disallowed" ], [ [ 2451, 2472 ], "valid" ], [ [ 2473, 2473 ], "disallowed" ], [ [ 2474, 2480 ], "valid" ], [ [ 2481, 2481 ], "disallowed" ], [ [ 2482, 2482 ], "valid" ], [ [ 2483, 2485 ], "disallowed" ], [ [ 2486, 2489 ], "valid" ], [ [ 2490, 2491 ], "disallowed" ], [ [ 2492, 2492 ], "valid" ], [ [ 2493, 2493 ], "valid" ], [ [ 2494, 2500 ], "valid" ], [ [ 2501, 2502 ], "disallowed" ], [ [ 2503, 2504 ], "valid" ], [ [ 2505, 2506 ], "disallowed" ], [ [ 2507, 2509 ], "valid" ], [ [ 2510, 2510 ], "valid" ], [ [ 2511, 2518 ], "disallowed" ], [ [ 2519, 2519 ], "valid" ], [ [ 2520, 2523 ], "disallowed" ], [ [ 2524, 2524 ], "mapped", [ 2465, 2492 ] ], [ [ 2525, 2525 ], "mapped", [ 2466, 2492 ] ], [ [ 2526, 2526 ], "disallowed" ], [ [ 2527, 2527 ], "mapped", [ 2479, 2492 ] ], [ [ 2528, 2531 ], "valid" ], [ [ 2532, 2533 ], "disallowed" ], [ [ 2534, 2545 ], "valid" ], [ [ 2546, 2554 ], "valid", [], "NV8" ], [ [ 2555, 2555 ], "valid", [], "NV8" ], [ [ 2556, 2560 ], "disallowed" ], [ [ 2561, 2561 ], "valid" ], [ [ 2562, 2562 ], "valid" ], [ [ 2563, 2563 ], "valid" ], [ [ 2564, 2564 ], "disallowed" ], [ [ 2565, 2570 ], "valid" ], [ [ 2571, 2574 ], "disallowed" ], [ [ 2575, 2576 ], "valid" ], [ [ 2577, 2578 ], "disallowed" ], [ [ 2579, 2600 ], "valid" ], [ [ 2601, 2601 ], "disallowed" ], [ [ 2602, 2608 ], "valid" ], [ [ 2609, 2609 ], "disallowed" ], [ [ 2610, 2610 ], "valid" ], [ [ 2611, 2611 ], "mapped", [ 2610, 2620 ] ], [ [ 2612, 2612 ], "disallowed" ], [ [ 2613, 2613 ], "valid" ], [ [ 2614, 2614 ], "mapped", [ 2616, 2620 ] ], [ [ 2615, 2615 ], "disallowed" ], [ [ 2616, 2617 ], "valid" ], [ [ 2618, 2619 ], "disallowed" ], [ [ 2620, 2620 ], "valid" ], [ [ 2621, 2621 ], "disallowed" ], [ [ 2622, 2626 ], "valid" ], [ [ 2627, 2630 ], "disallowed" ], [ [ 2631, 2632 ], "valid" ], [ [ 2633, 2634 ], "disallowed" ], [ [ 2635, 2637 ], "valid" ], [ [ 2638, 2640 ], "disallowed" ], [ [ 2641, 2641 ], "valid" ], [ [ 2642, 2648 ], "disallowed" ], [ [ 2649, 2649 ], "mapped", [ 2582, 2620 ] ], [ [ 2650, 2650 ], "mapped", [ 2583, 2620 ] ], [ [ 2651, 2651 ], "mapped", [ 2588, 2620 ] ], [ [ 2652, 2652 ], "valid" ], [ [ 2653, 2653 ], "disallowed" ], [ [ 2654, 2654 ], "mapped", [ 2603, 2620 ] ], [ [ 2655, 2661 ], "disallowed" ], [ [ 2662, 2676 ], "valid" ], [ [ 2677, 2677 ], "valid" ], [ [ 2678, 2688 ], "disallowed" ], [ [ 2689, 2691 ], "valid" ], [ [ 2692, 2692 ], "disallowed" ], [ [ 2693, 2699 ], "valid" ], [ [ 2700, 2700 ], "valid" ], [ [ 2701, 2701 ], "valid" ], [ [ 2702, 2702 ], "disallowed" ], [ [ 2703, 2705 ], "valid" ], [ [ 2706, 2706 ], "disallowed" ], [ [ 2707, 2728 ], "valid" ], [ [ 2729, 2729 ], "disallowed" ], [ [ 2730, 2736 ], "valid" ], [ [ 2737, 2737 ], "disallowed" ], [ [ 2738, 2739 ], "valid" ], [ [ 2740, 2740 ], "disallowed" ], [ [ 2741, 2745 ], "valid" ], [ [ 2746, 2747 ], "disallowed" ], [ [ 2748, 2757 ], "valid" ], [ [ 2758, 2758 ], "disallowed" ], [ [ 2759, 2761 ], "valid" ], [ [ 2762, 2762 ], "disallowed" ], [ [ 2763, 2765 ], "valid" ], [ [ 2766, 2767 ], "disallowed" ], [ [ 2768, 2768 ], "valid" ], [ [ 2769, 2783 ], "disallowed" ], [ [ 2784, 2784 ], "valid" ], [ [ 2785, 2787 ], "valid" ], [ [ 2788, 2789 ], "disallowed" ], [ [ 2790, 2799 ], "valid" ], [ [ 2800, 2800 ], "valid", [], "NV8" ], [ [ 2801, 2801 ], "valid", [], "NV8" ], [ [ 2802, 2808 ], "disallowed" ], [ [ 2809, 2809 ], "valid" ], [ [ 2810, 2816 ], "disallowed" ], [ [ 2817, 2819 ], "valid" ], [ [ 2820, 2820 ], "disallowed" ], [ [ 2821, 2828 ], "valid" ], [ [ 2829, 2830 ], "disallowed" ], [ [ 2831, 2832 ], "valid" ], [ [ 2833, 2834 ], "disallowed" ], [ [ 2835, 2856 ], "valid" ], [ [ 2857, 2857 ], "disallowed" ], [ [ 2858, 2864 ], "valid" ], [ [ 2865, 2865 ], "disallowed" ], [ [ 2866, 2867 ], "valid" ], [ [ 2868, 2868 ], "disallowed" ], [ [ 2869, 2869 ], "valid" ], [ [ 2870, 2873 ], "valid" ], [ [ 2874, 2875 ], "disallowed" ], [ [ 2876, 2883 ], "valid" ], [ [ 2884, 2884 ], "valid" ], [ [ 2885, 2886 ], "disallowed" ], [ [ 2887, 2888 ], "valid" ], [ [ 2889, 2890 ], "disallowed" ], [ [ 2891, 2893 ], "valid" ], [ [ 2894, 2901 ], "disallowed" ], [ [ 2902, 2903 ], "valid" ], [ [ 2904, 2907 ], "disallowed" ], [ [ 2908, 2908 ], "mapped", [ 2849, 2876 ] ], [ [ 2909, 2909 ], "mapped", [ 2850, 2876 ] ], [ [ 2910, 2910 ], "disallowed" ], [ [ 2911, 2913 ], "valid" ], [ [ 2914, 2915 ], "valid" ], [ [ 2916, 2917 ], "disallowed" ], [ [ 2918, 2927 ], "valid" ], [ [ 2928, 2928 ], "valid", [], "NV8" ], [ [ 2929, 2929 ], "valid" ], [ [ 2930, 2935 ], "valid", [], "NV8" ], [ [ 2936, 2945 ], "disallowed" ], [ [ 2946, 2947 ], "valid" ], [ [ 2948, 2948 ], "disallowed" ], [ [ 2949, 2954 ], "valid" ], [ [ 2955, 2957 ], "disallowed" ], [ [ 2958, 2960 ], "valid" ], [ [ 2961, 2961 ], "disallowed" ], [ [ 2962, 2965 ], "valid" ], [ [ 2966, 2968 ], "disallowed" ], [ [ 2969, 2970 ], "valid" ], [ [ 2971, 2971 ], "disallowed" ], [ [ 2972, 2972 ], "valid" ], [ [ 2973, 2973 ], "disallowed" ], [ [ 2974, 2975 ], "valid" ], [ [ 2976, 2978 ], "disallowed" ], [ [ 2979, 2980 ], "valid" ], [ [ 2981, 2983 ], "disallowed" ], [ [ 2984, 2986 ], "valid" ], [ [ 2987, 2989 ], "disallowed" ], [ [ 2990, 2997 ], "valid" ], [ [ 2998, 2998 ], "valid" ], [ [ 2999, 3001 ], "valid" ], [ [ 3002, 3005 ], "disallowed" ], [ [ 3006, 3010 ], "valid" ], [ [ 3011, 3013 ], "disallowed" ], [ [ 3014, 3016 ], "valid" ], [ [ 3017, 3017 ], "disallowed" ], [ [ 3018, 3021 ], "valid" ], [ [ 3022, 3023 ], "disallowed" ], [ [ 3024, 3024 ], "valid" ], [ [ 3025, 3030 ], "disallowed" ], [ [ 3031, 3031 ], "valid" ], [ [ 3032, 3045 ], "disallowed" ], [ [ 3046, 3046 ], "valid" ], [ [ 3047, 3055 ], "valid" ], [ [ 3056, 3058 ], "valid", [], "NV8" ], [ [ 3059, 3066 ], "valid", [], "NV8" ], [ [ 3067, 3071 ], "disallowed" ], [ [ 3072, 3072 ], "valid" ], [ [ 3073, 3075 ], "valid" ], [ [ 3076, 3076 ], "disallowed" ], [ [ 3077, 3084 ], "valid" ], [ [ 3085, 3085 ], "disallowed" ], [ [ 3086, 3088 ], "valid" ], [ [ 3089, 3089 ], "disallowed" ], [ [ 3090, 3112 ], "valid" ], [ [ 3113, 3113 ], "disallowed" ], [ [ 3114, 3123 ], "valid" ], [ [ 3124, 3124 ], "valid" ], [ [ 3125, 3129 ], "valid" ], [ [ 3130, 3132 ], "disallowed" ], [ [ 3133, 3133 ], "valid" ], [ [ 3134, 3140 ], "valid" ], [ [ 3141, 3141 ], "disallowed" ], [ [ 3142, 3144 ], "valid" ], [ [ 3145, 3145 ], "disallowed" ], [ [ 3146, 3149 ], "valid" ], [ [ 3150, 3156 ], "disallowed" ], [ [ 3157, 3158 ], "valid" ], [ [ 3159, 3159 ], "disallowed" ], [ [ 3160, 3161 ], "valid" ], [ [ 3162, 3162 ], "valid" ], [ [ 3163, 3167 ], "disallowed" ], [ [ 3168, 3169 ], "valid" ], [ [ 3170, 3171 ], "valid" ], [ [ 3172, 3173 ], "disallowed" ], [ [ 3174, 3183 ], "valid" ], [ [ 3184, 3191 ], "disallowed" ], [ [ 3192, 3199 ], "valid", [], "NV8" ], [ [ 3200, 3200 ], "disallowed" ], [ [ 3201, 3201 ], "valid" ], [ [ 3202, 3203 ], "valid" ], [ [ 3204, 3204 ], "disallowed" ], [ [ 3205, 3212 ], "valid" ], [ [ 3213, 3213 ], "disallowed" ], [ [ 3214, 3216 ], "valid" ], [ [ 3217, 3217 ], "disallowed" ], [ [ 3218, 3240 ], "valid" ], [ [ 3241, 3241 ], "disallowed" ], [ [ 3242, 3251 ], "valid" ], [ [ 3252, 3252 ], "disallowed" ], [ [ 3253, 3257 ], "valid" ], [ [ 3258, 3259 ], "disallowed" ], [ [ 3260, 3261 ], "valid" ], [ [ 3262, 3268 ], "valid" ], [ [ 3269, 3269 ], "disallowed" ], [ [ 3270, 3272 ], "valid" ], [ [ 3273, 3273 ], "disallowed" ], [ [ 3274, 3277 ], "valid" ], [ [ 3278, 3284 ], "disallowed" ], [ [ 3285, 3286 ], "valid" ], [ [ 3287, 3293 ], "disallowed" ], [ [ 3294, 3294 ], "valid" ], [ [ 3295, 3295 ], "disallowed" ], [ [ 3296, 3297 ], "valid" ], [ [ 3298, 3299 ], "valid" ], [ [ 3300, 3301 ], "disallowed" ], [ [ 3302, 3311 ], "valid" ], [ [ 3312, 3312 ], "disallowed" ], [ [ 3313, 3314 ], "valid" ], [ [ 3315, 3328 ], "disallowed" ], [ [ 3329, 3329 ], "valid" ], [ [ 3330, 3331 ], "valid" ], [ [ 3332, 3332 ], "disallowed" ], [ [ 3333, 3340 ], "valid" ], [ [ 3341, 3341 ], "disallowed" ], [ [ 3342, 3344 ], "valid" ], [ [ 3345, 3345 ], "disallowed" ], [ [ 3346, 3368 ], "valid" ], [ [ 3369, 3369 ], "valid" ], [ [ 3370, 3385 ], "valid" ], [ [ 3386, 3386 ], "valid" ], [ [ 3387, 3388 ], "disallowed" ], [ [ 3389, 3389 ], "valid" ], [ [ 3390, 3395 ], "valid" ], [ [ 3396, 3396 ], "valid" ], [ [ 3397, 3397 ], "disallowed" ], [ [ 3398, 3400 ], "valid" ], [ [ 3401, 3401 ], "disallowed" ], [ [ 3402, 3405 ], "valid" ], [ [ 3406, 3406 ], "valid" ], [ [ 3407, 3414 ], "disallowed" ], [ [ 3415, 3415 ], "valid" ], [ [ 3416, 3422 ], "disallowed" ], [ [ 3423, 3423 ], "valid" ], [ [ 3424, 3425 ], "valid" ], [ [ 3426, 3427 ], "valid" ], [ [ 3428, 3429 ], "disallowed" ], [ [ 3430, 3439 ], "valid" ], [ [ 3440, 3445 ], "valid", [], "NV8" ], [ [ 3446, 3448 ], "disallowed" ], [ [ 3449, 3449 ], "valid", [], "NV8" ], [ [ 3450, 3455 ], "valid" ], [ [ 3456, 3457 ], "disallowed" ], [ [ 3458, 3459 ], "valid" ], [ [ 3460, 3460 ], "disallowed" ], [ [ 3461, 3478 ], "valid" ], [ [ 3479, 3481 ], "disallowed" ], [ [ 3482, 3505 ], "valid" ], [ [ 3506, 3506 ], "disallowed" ], [ [ 3507, 3515 ], "valid" ], [ [ 3516, 3516 ], "disallowed" ], [ [ 3517, 3517 ], "valid" ], [ [ 3518, 3519 ], "disallowed" ], [ [ 3520, 3526 ], "valid" ], [ [ 3527, 3529 ], "disallowed" ], [ [ 3530, 3530 ], "valid" ], [ [ 3531, 3534 ], "disallowed" ], [ [ 3535, 3540 ], "valid" ], [ [ 3541, 3541 ], "disallowed" ], [ [ 3542, 3542 ], "valid" ], [ [ 3543, 3543 ], "disallowed" ], [ [ 3544, 3551 ], "valid" ], [ [ 3552, 3557 ], "disallowed" ], [ [ 3558, 3567 ], "valid" ], [ [ 3568, 3569 ], "disallowed" ], [ [ 3570, 3571 ], "valid" ], [ [ 3572, 3572 ], "valid", [], "NV8" ], [ [ 3573, 3584 ], "disallowed" ], [ [ 3585, 3634 ], "valid" ], [ [ 3635, 3635 ], "mapped", [ 3661, 3634 ] ], [ [ 3636, 3642 ], "valid" ], [ [ 3643, 3646 ], "disallowed" ], [ [ 3647, 3647 ], "valid", [], "NV8" ], [ [ 3648, 3662 ], "valid" ], [ [ 3663, 3663 ], "valid", [], "NV8" ], [ [ 3664, 3673 ], "valid" ], [ [ 3674, 3675 ], "valid", [], "NV8" ], [ [ 3676, 3712 ], "disallowed" ], [ [ 3713, 3714 ], "valid" ], [ [ 3715, 3715 ], "disallowed" ], [ [ 3716, 3716 ], "valid" ], [ [ 3717, 3718 ], "disallowed" ], [ [ 3719, 3720 ], "valid" ], [ [ 3721, 3721 ], "disallowed" ], [ [ 3722, 3722 ], "valid" ], [ [ 3723, 3724 ], "disallowed" ], [ [ 3725, 3725 ], "valid" ], [ [ 3726, 3731 ], "disallowed" ], [ [ 3732, 3735 ], "valid" ], [ [ 3736, 3736 ], "disallowed" ], [ [ 3737, 3743 ], "valid" ], [ [ 3744, 3744 ], "disallowed" ], [ [ 3745, 3747 ], "valid" ], [ [ 3748, 3748 ], "disallowed" ], [ [ 3749, 3749 ], "valid" ], [ [ 3750, 3750 ], "disallowed" ], [ [ 3751, 3751 ], "valid" ], [ [ 3752, 3753 ], "disallowed" ], [ [ 3754, 3755 ], "valid" ], [ [ 3756, 3756 ], "disallowed" ], [ [ 3757, 3762 ], "valid" ], [ [ 3763, 3763 ], "mapped", [ 3789, 3762 ] ], [ [ 3764, 3769 ], "valid" ], [ [ 3770, 3770 ], "disallowed" ], [ [ 3771, 3773 ], "valid" ], [ [ 3774, 3775 ], "disallowed" ], [ [ 3776, 3780 ], "valid" ], [ [ 3781, 3781 ], "disallowed" ], [ [ 3782, 3782 ], "valid" ], [ [ 3783, 3783 ], "disallowed" ], [ [ 3784, 3789 ], "valid" ], [ [ 3790, 3791 ], "disallowed" ], [ [ 3792, 3801 ], "valid" ], [ [ 3802, 3803 ], "disallowed" ], [ [ 3804, 3804 ], "mapped", [ 3755, 3737 ] ], [ [ 3805, 3805 ], "mapped", [ 3755, 3745 ] ], [ [ 3806, 3807 ], "valid" ], [ [ 3808, 3839 ], "disallowed" ], [ [ 3840, 3840 ], "valid" ], [ [ 3841, 3850 ], "valid", [], "NV8" ], [ [ 3851, 3851 ], "valid" ], [ [ 3852, 3852 ], "mapped", [ 3851 ] ], [ [ 3853, 3863 ], "valid", [], "NV8" ], [ [ 3864, 3865 ], "valid" ], [ [ 3866, 3871 ], "valid", [], "NV8" ], [ [ 3872, 3881 ], "valid" ], [ [ 3882, 3892 ], "valid", [], "NV8" ], [ [ 3893, 3893 ], "valid" ], [ [ 3894, 3894 ], "valid", [], "NV8" ], [ [ 3895, 3895 ], "valid" ], [ [ 3896, 3896 ], "valid", [], "NV8" ], [ [ 3897, 3897 ], "valid" ], [ [ 3898, 3901 ], "valid", [], "NV8" ], [ [ 3902, 3906 ], "valid" ], [ [ 3907, 3907 ], "mapped", [ 3906, 4023 ] ], [ [ 3908, 3911 ], "valid" ], [ [ 3912, 3912 ], "disallowed" ], [ [ 3913, 3916 ], "valid" ], [ [ 3917, 3917 ], "mapped", [ 3916, 4023 ] ], [ [ 3918, 3921 ], "valid" ], [ [ 3922, 3922 ], "mapped", [ 3921, 4023 ] ], [ [ 3923, 3926 ], "valid" ], [ [ 3927, 3927 ], "mapped", [ 3926, 4023 ] ], [ [ 3928, 3931 ], "valid" ], [ [ 3932, 3932 ], "mapped", [ 3931, 4023 ] ], [ [ 3933, 3944 ], "valid" ], [ [ 3945, 3945 ], "mapped", [ 3904, 4021 ] ], [ [ 3946, 3946 ], "valid" ], [ [ 3947, 3948 ], "valid" ], [ [ 3949, 3952 ], "disallowed" ], [ [ 3953, 3954 ], "valid" ], [ [ 3955, 3955 ], "mapped", [ 3953, 3954 ] ], [ [ 3956, 3956 ], "valid" ], [ [ 3957, 3957 ], "mapped", [ 3953, 3956 ] ], [ [ 3958, 3958 ], "mapped", [ 4018, 3968 ] ], [ [ 3959, 3959 ], "mapped", [ 4018, 3953, 3968 ] ], [ [ 3960, 3960 ], "mapped", [ 4019, 3968 ] ], [ [ 3961, 3961 ], "mapped", [ 4019, 3953, 3968 ] ], [ [ 3962, 3968 ], "valid" ], [ [ 3969, 3969 ], "mapped", [ 3953, 3968 ] ], [ [ 3970, 3972 ], "valid" ], [ [ 3973, 3973 ], "valid", [], "NV8" ], [ [ 3974, 3979 ], "valid" ], [ [ 3980, 3983 ], "valid" ], [ [ 3984, 3986 ], "valid" ], [ [ 3987, 3987 ], "mapped", [ 3986, 4023 ] ], [ [ 3988, 3989 ], "valid" ], [ [ 3990, 3990 ], "valid" ], [ [ 3991, 3991 ], "valid" ], [ [ 3992, 3992 ], "disallowed" ], [ [ 3993, 3996 ], "valid" ], [ [ 3997, 3997 ], "mapped", [ 3996, 4023 ] ], [ [ 3998, 4001 ], "valid" ], [ [ 4002, 4002 ], "mapped", [ 4001, 4023 ] ], [ [ 4003, 4006 ], "valid" ], [ [ 4007, 4007 ], "mapped", [ 4006, 4023 ] ], [ [ 4008, 4011 ], "valid" ], [ [ 4012, 4012 ], "mapped", [ 4011, 4023 ] ], [ [ 4013, 4013 ], "valid" ], [ [ 4014, 4016 ], "valid" ], [ [ 4017, 4023 ], "valid" ], [ [ 4024, 4024 ], "valid" ], [ [ 4025, 4025 ], "mapped", [ 3984, 4021 ] ], [ [ 4026, 4028 ], "valid" ], [ [ 4029, 4029 ], "disallowed" ], [ [ 4030, 4037 ], "valid", [], "NV8" ], [ [ 4038, 4038 ], "valid" ], [ [ 4039, 4044 ], "valid", [], "NV8" ], [ [ 4045, 4045 ], "disallowed" ], [ [ 4046, 4046 ], "valid", [], "NV8" ], [ [ 4047, 4047 ], "valid", [], "NV8" ], [ [ 4048, 4049 ], "valid", [], "NV8" ], [ [ 4050, 4052 ], "valid", [], "NV8" ], [ [ 4053, 4056 ], "valid", [], "NV8" ], [ [ 4057, 4058 ], "valid", [], "NV8" ], [ [ 4059, 4095 ], "disallowed" ], [ [ 4096, 4129 ], "valid" ], [ [ 4130, 4130 ], "valid" ], [ [ 4131, 4135 ], "valid" ], [ [ 4136, 4136 ], "valid" ], [ [ 4137, 4138 ], "valid" ], [ [ 4139, 4139 ], "valid" ], [ [ 4140, 4146 ], "valid" ], [ [ 4147, 4149 ], "valid" ], [ [ 4150, 4153 ], "valid" ], [ [ 4154, 4159 ], "valid" ], [ [ 4160, 4169 ], "valid" ], [ [ 4170, 4175 ], "valid", [], "NV8" ], [ [ 4176, 4185 ], "valid" ], [ [ 4186, 4249 ], "valid" ], [ [ 4250, 4253 ], "valid" ], [ [ 4254, 4255 ], "valid", [], "NV8" ], [ [ 4256, 4293 ], "disallowed" ], [ [ 4294, 4294 ], "disallowed" ], [ [ 4295, 4295 ], "mapped", [ 11559 ] ], [ [ 4296, 4300 ], "disallowed" ], [ [ 4301, 4301 ], "mapped", [ 11565 ] ], [ [ 4302, 4303 ], "disallowed" ], [ [ 4304, 4342 ], "valid" ], [ [ 4343, 4344 ], "valid" ], [ [ 4345, 4346 ], "valid" ], [ [ 4347, 4347 ], "valid", [], "NV8" ], [ [ 4348, 4348 ], "mapped", [ 4316 ] ], [ [ 4349, 4351 ], "valid" ], [ [ 4352, 4441 ], "valid", [], "NV8" ], [ [ 4442, 4446 ], "valid", [], "NV8" ], [ [ 4447, 4448 ], "disallowed" ], [ [ 4449, 4514 ], "valid", [], "NV8" ], [ [ 4515, 4519 ], "valid", [], "NV8" ], [ [ 4520, 4601 ], "valid", [], "NV8" ], [ [ 4602, 4607 ], "valid", [], "NV8" ], [ [ 4608, 4614 ], "valid" ], [ [ 4615, 4615 ], "valid" ], [ [ 4616, 4678 ], "valid" ], [ [ 4679, 4679 ], "valid" ], [ [ 4680, 4680 ], "valid" ], [ [ 4681, 4681 ], "disallowed" ], [ [ 4682, 4685 ], "valid" ], [ [ 4686, 4687 ], "disallowed" ], [ [ 4688, 4694 ], "valid" ], [ [ 4695, 4695 ], "disallowed" ], [ [ 4696, 4696 ], "valid" ], [ [ 4697, 4697 ], "disallowed" ], [ [ 4698, 4701 ], "valid" ], [ [ 4702, 4703 ], "disallowed" ], [ [ 4704, 4742 ], "valid" ], [ [ 4743, 4743 ], "valid" ], [ [ 4744, 4744 ], "valid" ], [ [ 4745, 4745 ], "disallowed" ], [ [ 4746, 4749 ], "valid" ], [ [ 4750, 4751 ], "disallowed" ], [ [ 4752, 4782 ], "valid" ], [ [ 4783, 4783 ], "valid" ], [ [ 4784, 4784 ], "valid" ], [ [ 4785, 4785 ], "disallowed" ], [ [ 4786, 4789 ], "valid" ], [ [ 4790, 4791 ], "disallowed" ], [ [ 4792, 4798 ], "valid" ], [ [ 4799, 4799 ], "disallowed" ], [ [ 4800, 4800 ], "valid" ], [ [ 4801, 4801 ], "disallowed" ], [ [ 4802, 4805 ], "valid" ], [ [ 4806, 4807 ], "disallowed" ], [ [ 4808, 4814 ], "valid" ], [ [ 4815, 4815 ], "valid" ], [ [ 4816, 4822 ], "valid" ], [ [ 4823, 4823 ], "disallowed" ], [ [ 4824, 4846 ], "valid" ], [ [ 4847, 4847 ], "valid" ], [ [ 4848, 4878 ], "valid" ], [ [ 4879, 4879 ], "valid" ], [ [ 4880, 4880 ], "valid" ], [ [ 4881, 4881 ], "disallowed" ], [ [ 4882, 4885 ], "valid" ], [ [ 4886, 4887 ], "disallowed" ], [ [ 4888, 4894 ], "valid" ], [ [ 4895, 4895 ], "valid" ], [ [ 4896, 4934 ], "valid" ], [ [ 4935, 4935 ], "valid" ], [ [ 4936, 4954 ], "valid" ], [ [ 4955, 4956 ], "disallowed" ], [ [ 4957, 4958 ], "valid" ], [ [ 4959, 4959 ], "valid" ], [ [ 4960, 4960 ], "valid", [], "NV8" ], [ [ 4961, 4988 ], "valid", [], "NV8" ], [ [ 4989, 4991 ], "disallowed" ], [ [ 4992, 5007 ], "valid" ], [ [ 5008, 5017 ], "valid", [], "NV8" ], [ [ 5018, 5023 ], "disallowed" ], [ [ 5024, 5108 ], "valid" ], [ [ 5109, 5109 ], "valid" ], [ [ 5110, 5111 ], "disallowed" ], [ [ 5112, 5112 ], "mapped", [ 5104 ] ], [ [ 5113, 5113 ], "mapped", [ 5105 ] ], [ [ 5114, 5114 ], "mapped", [ 5106 ] ], [ [ 5115, 5115 ], "mapped", [ 5107 ] ], [ [ 5116, 5116 ], "mapped", [ 5108 ] ], [ [ 5117, 5117 ], "mapped", [ 5109 ] ], [ [ 5118, 5119 ], "disallowed" ], [ [ 5120, 5120 ], "valid", [], "NV8" ], [ [ 5121, 5740 ], "valid" ], [ [ 5741, 5742 ], "valid", [], "NV8" ], [ [ 5743, 5750 ], "valid" ], [ [ 5751, 5759 ], "valid" ], [ [ 5760, 5760 ], "disallowed" ], [ [ 5761, 5786 ], "valid" ], [ [ 5787, 5788 ], "valid", [], "NV8" ], [ [ 5789, 5791 ], "disallowed" ], [ [ 5792, 5866 ], "valid" ], [ [ 5867, 5872 ], "valid", [], "NV8" ], [ [ 5873, 5880 ], "valid" ], [ [ 5881, 5887 ], "disallowed" ], [ [ 5888, 5900 ], "valid" ], [ [ 5901, 5901 ], "disallowed" ], [ [ 5902, 5908 ], "valid" ], [ [ 5909, 5919 ], "disallowed" ], [ [ 5920, 5940 ], "valid" ], [ [ 5941, 5942 ], "valid", [], "NV8" ], [ [ 5943, 5951 ], "disallowed" ], [ [ 5952, 5971 ], "valid" ], [ [ 5972, 5983 ], "disallowed" ], [ [ 5984, 5996 ], "valid" ], [ [ 5997, 5997 ], "disallowed" ], [ [ 5998, 6e3 ], "valid" ], [ [ 6001, 6001 ], "disallowed" ], [ [ 6002, 6003 ], "valid" ], [ [ 6004, 6015 ], "disallowed" ], [ [ 6016, 6067 ], "valid" ], [ [ 6068, 6069 ], "disallowed" ], [ [ 6070, 6099 ], "valid" ], [ [ 6100, 6102 ], "valid", [], "NV8" ], [ [ 6103, 6103 ], "valid" ], [ [ 6104, 6107 ], "valid", [], "NV8" ], [ [ 6108, 6108 ], "valid" ], [ [ 6109, 6109 ], "valid" ], [ [ 6110, 6111 ], "disallowed" ], [ [ 6112, 6121 ], "valid" ], [ [ 6122, 6127 ], "disallowed" ], [ [ 6128, 6137 ], "valid", [], "NV8" ], [ [ 6138, 6143 ], "disallowed" ], [ [ 6144, 6149 ], "valid", [], "NV8" ], [ [ 6150, 6150 ], "disallowed" ], [ [ 6151, 6154 ], "valid", [], "NV8" ], [ [ 6155, 6157 ], "ignored" ], [ [ 6158, 6158 ], "disallowed" ], [ [ 6159, 6159 ], "disallowed" ], [ [ 6160, 6169 ], "valid" ], [ [ 6170, 6175 ], "disallowed" ], [ [ 6176, 6263 ], "valid" ], [ [ 6264, 6271 ], "disallowed" ], [ [ 6272, 6313 ], "valid" ], [ [ 6314, 6314 ], "valid" ], [ [ 6315, 6319 ], "disallowed" ], [ [ 6320, 6389 ], "valid" ], [ [ 6390, 6399 ], "disallowed" ], [ [ 6400, 6428 ], "valid" ], [ [ 6429, 6430 ], "valid" ], [ [ 6431, 6431 ], "disallowed" ], [ [ 6432, 6443 ], "valid" ], [ [ 6444, 6447 ], "disallowed" ], [ [ 6448, 6459 ], "valid" ], [ [ 6460, 6463 ], "disallowed" ], [ [ 6464, 6464 ], "valid", [], "NV8" ], [ [ 6465, 6467 ], "disallowed" ], [ [ 6468, 6469 ], "valid", [], "NV8" ], [ [ 6470, 6509 ], "valid" ], [ [ 6510, 6511 ], "disallowed" ], [ [ 6512, 6516 ], "valid" ], [ [ 6517, 6527 ], "disallowed" ], [ [ 6528, 6569 ], "valid" ], [ [ 6570, 6571 ], "valid" ], [ [ 6572, 6575 ], "disallowed" ], [ [ 6576, 6601 ], "valid" ], [ [ 6602, 6607 ], "disallowed" ], [ [ 6608, 6617 ], "valid" ], [ [ 6618, 6618 ], "valid", [], "XV8" ], [ [ 6619, 6621 ], "disallowed" ], [ [ 6622, 6623 ], "valid", [], "NV8" ], [ [ 6624, 6655 ], "valid", [], "NV8" ], [ [ 6656, 6683 ], "valid" ], [ [ 6684, 6685 ], "disallowed" ], [ [ 6686, 6687 ], "valid", [], "NV8" ], [ [ 6688, 6750 ], "valid" ], [ [ 6751, 6751 ], "disallowed" ], [ [ 6752, 6780 ], "valid" ], [ [ 6781, 6782 ], "disallowed" ], [ [ 6783, 6793 ], "valid" ], [ [ 6794, 6799 ], "disallowed" ], [ [ 6800, 6809 ], "valid" ], [ [ 6810, 6815 ], "disallowed" ], [ [ 6816, 6822 ], "valid", [], "NV8" ], [ [ 6823, 6823 ], "valid" ], [ [ 6824, 6829 ], "valid", [], "NV8" ], [ [ 6830, 6831 ], "disallowed" ], [ [ 6832, 6845 ], "valid" ], [ [ 6846, 6846 ], "valid", [], "NV8" ], [ [ 6847, 6911 ], "disallowed" ], [ [ 6912, 6987 ], "valid" ], [ [ 6988, 6991 ], "disallowed" ], [ [ 6992, 7001 ], "valid" ], [ [ 7002, 7018 ], "valid", [], "NV8" ], [ [ 7019, 7027 ], "valid" ], [ [ 7028, 7036 ], "valid", [], "NV8" ], [ [ 7037, 7039 ], "disallowed" ], [ [ 7040, 7082 ], "valid" ], [ [ 7083, 7085 ], "valid" ], [ [ 7086, 7097 ], "valid" ], [ [ 7098, 7103 ], "valid" ], [ [ 7104, 7155 ], "valid" ], [ [ 7156, 7163 ], "disallowed" ], [ [ 7164, 7167 ], "valid", [], "NV8" ], [ [ 7168, 7223 ], "valid" ], [ [ 7224, 7226 ], "disallowed" ], [ [ 7227, 7231 ], "valid", [], "NV8" ], [ [ 7232, 7241 ], "valid" ], [ [ 7242, 7244 ], "disallowed" ], [ [ 7245, 7293 ], "valid" ], [ [ 7294, 7295 ], "valid", [], "NV8" ], [ [ 7296, 7359 ], "disallowed" ], [ [ 7360, 7367 ], "valid", [], "NV8" ], [ [ 7368, 7375 ], "disallowed" ], [ [ 7376, 7378 ], "valid" ], [ [ 7379, 7379 ], "valid", [], "NV8" ], [ [ 7380, 7410 ], "valid" ], [ [ 7411, 7414 ], "valid" ], [ [ 7415, 7415 ], "disallowed" ], [ [ 7416, 7417 ], "valid" ], [ [ 7418, 7423 ], "disallowed" ], [ [ 7424, 7467 ], "valid" ], [ [ 7468, 7468 ], "mapped", [ 97 ] ], [ [ 7469, 7469 ], "mapped", [ 230 ] ], [ [ 7470, 7470 ], "mapped", [ 98 ] ], [ [ 7471, 7471 ], "valid" ], [ [ 7472, 7472 ], "mapped", [ 100 ] ], [ [ 7473, 7473 ], "mapped", [ 101 ] ], [ [ 7474, 7474 ], "mapped", [ 477 ] ], [ [ 7475, 7475 ], "mapped", [ 103 ] ], [ [ 7476, 7476 ], "mapped", [ 104 ] ], [ [ 7477, 7477 ], "mapped", [ 105 ] ], [ [ 7478, 7478 ], "mapped", [ 106 ] ], [ [ 7479, 7479 ], "mapped", [ 107 ] ], [ [ 7480, 7480 ], "mapped", [ 108 ] ], [ [ 7481, 7481 ], "mapped", [ 109 ] ], [ [ 7482, 7482 ], "mapped", [ 110 ] ], [ [ 7483, 7483 ], "valid" ], [ [ 7484, 7484 ], "mapped", [ 111 ] ], [ [ 7485, 7485 ], "mapped", [ 547 ] ], [ [ 7486, 7486 ], "mapped", [ 112 ] ], [ [ 7487, 7487 ], "mapped", [ 114 ] ], [ [ 7488, 7488 ], "mapped", [ 116 ] ], [ [ 7489, 7489 ], "mapped", [ 117 ] ], [ [ 7490, 7490 ], "mapped", [ 119 ] ], [ [ 7491, 7491 ], "mapped", [ 97 ] ], [ [ 7492, 7492 ], "mapped", [ 592 ] ], [ [ 7493, 7493 ], "mapped", [ 593 ] ], [ [ 7494, 7494 ], "mapped", [ 7426 ] ], [ [ 7495, 7495 ], "mapped", [ 98 ] ], [ [ 7496, 7496 ], "mapped", [ 100 ] ], [ [ 7497, 7497 ], "mapped", [ 101 ] ], [ [ 7498, 7498 ], "mapped", [ 601 ] ], [ [ 7499, 7499 ], "mapped", [ 603 ] ], [ [ 7500, 7500 ], "mapped", [ 604 ] ], [ [ 7501, 7501 ], "mapped", [ 103 ] ], [ [ 7502, 7502 ], "valid" ], [ [ 7503, 7503 ], "mapped", [ 107 ] ], [ [ 7504, 7504 ], "mapped", [ 109 ] ], [ [ 7505, 7505 ], "mapped", [ 331 ] ], [ [ 7506, 7506 ], "mapped", [ 111 ] ], [ [ 7507, 7507 ], "mapped", [ 596 ] ], [ [ 7508, 7508 ], "mapped", [ 7446 ] ], [ [ 7509, 7509 ], "mapped", [ 7447 ] ], [ [ 7510, 7510 ], "mapped", [ 112 ] ], [ [ 7511, 7511 ], "mapped", [ 116 ] ], [ [ 7512, 7512 ], "mapped", [ 117 ] ], [ [ 7513, 7513 ], "mapped", [ 7453 ] ], [ [ 7514, 7514 ], "mapped", [ 623 ] ], [ [ 7515, 7515 ], "mapped", [ 118 ] ], [ [ 7516, 7516 ], "mapped", [ 7461 ] ], [ [ 7517, 7517 ], "mapped", [ 946 ] ], [ [ 7518, 7518 ], "mapped", [ 947 ] ], [ [ 7519, 7519 ], "mapped", [ 948 ] ], [ [ 7520, 7520 ], "mapped", [ 966 ] ], [ [ 7521, 7521 ], "mapped", [ 967 ] ], [ [ 7522, 7522 ], "mapped", [ 105 ] ], [ [ 7523, 7523 ], "mapped", [ 114 ] ], [ [ 7524, 7524 ], "mapped", [ 117 ] ], [ [ 7525, 7525 ], "mapped", [ 118 ] ], [ [ 7526, 7526 ], "mapped", [ 946 ] ], [ [ 7527, 7527 ], "mapped", [ 947 ] ], [ [ 7528, 7528 ], "mapped", [ 961 ] ], [ [ 7529, 7529 ], "mapped", [ 966 ] ], [ [ 7530, 7530 ], "mapped", [ 967 ] ], [ [ 7531, 7531 ], "valid" ], [ [ 7532, 7543 ], "valid" ], [ [ 7544, 7544 ], "mapped", [ 1085 ] ], [ [ 7545, 7578 ], "valid" ], [ [ 7579, 7579 ], "mapped", [ 594 ] ], [ [ 7580, 7580 ], "mapped", [ 99 ] ], [ [ 7581, 7581 ], "mapped", [ 597 ] ], [ [ 7582, 7582 ], "mapped", [ 240 ] ], [ [ 7583, 7583 ], "mapped", [ 604 ] ], [ [ 7584, 7584 ], "mapped", [ 102 ] ], [ [ 7585, 7585 ], "mapped", [ 607 ] ], [ [ 7586, 7586 ], "mapped", [ 609 ] ], [ [ 7587, 7587 ], "mapped", [ 613 ] ], [ [ 7588, 7588 ], "mapped", [ 616 ] ], [ [ 7589, 7589 ], "mapped", [ 617 ] ], [ [ 7590, 7590 ], "mapped", [ 618 ] ], [ [ 7591, 7591 ], "mapped", [ 7547 ] ], [ [ 7592, 7592 ], "mapped", [ 669 ] ], [ [ 7593, 7593 ], "mapped", [ 621 ] ], [ [ 7594, 7594 ], "mapped", [ 7557 ] ], [ [ 7595, 7595 ], "mapped", [ 671 ] ], [ [ 7596, 7596 ], "mapped", [ 625 ] ], [ [ 7597, 7597 ], "mapped", [ 624 ] ], [ [ 7598, 7598 ], "mapped", [ 626 ] ], [ [ 7599, 7599 ], "mapped", [ 627 ] ], [ [ 7600, 7600 ], "mapped", [ 628 ] ], [ [ 7601, 7601 ], "mapped", [ 629 ] ], [ [ 7602, 7602 ], "mapped", [ 632 ] ], [ [ 7603, 7603 ], "mapped", [ 642 ] ], [ [ 7604, 7604 ], "mapped", [ 643 ] ], [ [ 7605, 7605 ], "mapped", [ 427 ] ], [ [ 7606, 7606 ], "mapped", [ 649 ] ], [ [ 7607, 7607 ], "mapped", [ 650 ] ], [ [ 7608, 7608 ], "mapped", [ 7452 ] ], [ [ 7609, 7609 ], "mapped", [ 651 ] ], [ [ 7610, 7610 ], "mapped", [ 652 ] ], [ [ 7611, 7611 ], "mapped", [ 122 ] ], [ [ 7612, 7612 ], "mapped", [ 656 ] ], [ [ 7613, 7613 ], "mapped", [ 657 ] ], [ [ 7614, 7614 ], "mapped", [ 658 ] ], [ [ 7615, 7615 ], "mapped", [ 952 ] ], [ [ 7616, 7619 ], "valid" ], [ [ 7620, 7626 ], "valid" ], [ [ 7627, 7654 ], "valid" ], [ [ 7655, 7669 ], "valid" ], [ [ 7670, 7675 ], "disallowed" ], [ [ 7676, 7676 ], "valid" ], [ [ 7677, 7677 ], "valid" ], [ [ 7678, 7679 ], "valid" ], [ [ 7680, 7680 ], "mapped", [ 7681 ] ], [ [ 7681, 7681 ], "valid" ], [ [ 7682, 7682 ], "mapped", [ 7683 ] ], [ [ 7683, 7683 ], "valid" ], [ [ 7684, 7684 ], "mapped", [ 7685 ] ], [ [ 7685, 7685 ], "valid" ], [ [ 7686, 7686 ], "mapped", [ 7687 ] ], [ [ 7687, 7687 ], "valid" ], [ [ 7688, 7688 ], "mapped", [ 7689 ] ], [ [ 7689, 7689 ], "valid" ], [ [ 7690, 7690 ], "mapped", [ 7691 ] ], [ [ 7691, 7691 ], "valid" ], [ [ 7692, 7692 ], "mapped", [ 7693 ] ], [ [ 7693, 7693 ], "valid" ], [ [ 7694, 7694 ], "mapped", [ 7695 ] ], [ [ 7695, 7695 ], "valid" ], [ [ 7696, 7696 ], "mapped", [ 7697 ] ], [ [ 7697, 7697 ], "valid" ], [ [ 7698, 7698 ], "mapped", [ 7699 ] ], [ [ 7699, 7699 ], "valid" ], [ [ 7700, 7700 ], "mapped", [ 7701 ] ], [ [ 7701, 7701 ], "valid" ], [ [ 7702, 7702 ], "mapped", [ 7703 ] ], [ [ 7703, 7703 ], "valid" ], [ [ 7704, 7704 ], "mapped", [ 7705 ] ], [ [ 7705, 7705 ], "valid" ], [ [ 7706, 7706 ], "mapped", [ 7707 ] ], [ [ 7707, 7707 ], "valid" ], [ [ 7708, 7708 ], "mapped", [ 7709 ] ], [ [ 7709, 7709 ], "valid" ], [ [ 7710, 7710 ], "mapped", [ 7711 ] ], [ [ 7711, 7711 ], "valid" ], [ [ 7712, 7712 ], "mapped", [ 7713 ] ], [ [ 7713, 7713 ], "valid" ], [ [ 7714, 7714 ], "mapped", [ 7715 ] ], [ [ 7715, 7715 ], "valid" ], [ [ 7716, 7716 ], "mapped", [ 7717 ] ], [ [ 7717, 7717 ], "valid" ], [ [ 7718, 7718 ], "mapped", [ 7719 ] ], [ [ 7719, 7719 ], "valid" ], [ [ 7720, 7720 ], "mapped", [ 7721 ] ], [ [ 7721, 7721 ], "valid" ], [ [ 7722, 7722 ], "mapped", [ 7723 ] ], [ [ 7723, 7723 ], "valid" ], [ [ 7724, 7724 ], "mapped", [ 7725 ] ], [ [ 7725, 7725 ], "valid" ], [ [ 7726, 7726 ], "mapped", [ 7727 ] ], [ [ 7727, 7727 ], "valid" ], [ [ 7728, 7728 ], "mapped", [ 7729 ] ], [ [ 7729, 7729 ], "valid" ], [ [ 7730, 7730 ], "mapped", [ 7731 ] ], [ [ 7731, 7731 ], "valid" ], [ [ 7732, 7732 ], "mapped", [ 7733 ] ], [ [ 7733, 7733 ], "valid" ], [ [ 7734, 7734 ], "mapped", [ 7735 ] ], [ [ 7735, 7735 ], "valid" ], [ [ 7736, 7736 ], "mapped", [ 7737 ] ], [ [ 7737, 7737 ], "valid" ], [ [ 7738, 7738 ], "mapped", [ 7739 ] ], [ [ 7739, 7739 ], "valid" ], [ [ 7740, 7740 ], "mapped", [ 7741 ] ], [ [ 7741, 7741 ], "valid" ], [ [ 7742, 7742 ], "mapped", [ 7743 ] ], [ [ 7743, 7743 ], "valid" ], [ [ 7744, 7744 ], "mapped", [ 7745 ] ], [ [ 7745, 7745 ], "valid" ], [ [ 7746, 7746 ], "mapped", [ 7747 ] ], [ [ 7747, 7747 ], "valid" ], [ [ 7748, 7748 ], "mapped", [ 7749 ] ], [ [ 7749, 7749 ], "valid" ], [ [ 7750, 7750 ], "mapped", [ 7751 ] ], [ [ 7751, 7751 ], "valid" ], [ [ 7752, 7752 ], "mapped", [ 7753 ] ], [ [ 7753, 7753 ], "valid" ], [ [ 7754, 7754 ], "mapped", [ 7755 ] ], [ [ 7755, 7755 ], "valid" ], [ [ 7756, 7756 ], "mapped", [ 7757 ] ], [ [ 7757, 7757 ], "valid" ], [ [ 7758, 7758 ], "mapped", [ 7759 ] ], [ [ 7759, 7759 ], "valid" ], [ [ 7760, 7760 ], "mapped", [ 7761 ] ], [ [ 7761, 7761 ], "valid" ], [ [ 7762, 7762 ], "mapped", [ 7763 ] ], [ [ 7763, 7763 ], "valid" ], [ [ 7764, 7764 ], "mapped", [ 7765 ] ], [ [ 7765, 7765 ], "valid" ], [ [ 7766, 7766 ], "mapped", [ 7767 ] ], [ [ 7767, 7767 ], "valid" ], [ [ 7768, 7768 ], "mapped", [ 7769 ] ], [ [ 7769, 7769 ], "valid" ], [ [ 7770, 7770 ], "mapped", [ 7771 ] ], [ [ 7771, 7771 ], "valid" ], [ [ 7772, 7772 ], "mapped", [ 7773 ] ], [ [ 7773, 7773 ], "valid" ], [ [ 7774, 7774 ], "mapped", [ 7775 ] ], [ [ 7775, 7775 ], "valid" ], [ [ 7776, 7776 ], "mapped", [ 7777 ] ], [ [ 7777, 7777 ], "valid" ], [ [ 7778, 7778 ], "mapped", [ 7779 ] ], [ [ 7779, 7779 ], "valid" ], [ [ 7780, 7780 ], "mapped", [ 7781 ] ], [ [ 7781, 7781 ], "valid" ], [ [ 7782, 7782 ], "mapped", [ 7783 ] ], [ [ 7783, 7783 ], "valid" ], [ [ 7784, 7784 ], "mapped", [ 7785 ] ], [ [ 7785, 7785 ], "valid" ], [ [ 7786, 7786 ], "mapped", [ 7787 ] ], [ [ 7787, 7787 ], "valid" ], [ [ 7788, 7788 ], "mapped", [ 7789 ] ], [ [ 7789, 7789 ], "valid" ], [ [ 7790, 7790 ], "mapped", [ 7791 ] ], [ [ 7791, 7791 ], "valid" ], [ [ 7792, 7792 ], "mapped", [ 7793 ] ], [ [ 7793, 7793 ], "valid" ], [ [ 7794, 7794 ], "mapped", [ 7795 ] ], [ [ 7795, 7795 ], "valid" ], [ [ 7796, 7796 ], "mapped", [ 7797 ] ], [ [ 7797, 7797 ], "valid" ], [ [ 7798, 7798 ], "mapped", [ 7799 ] ], [ [ 7799, 7799 ], "valid" ], [ [ 7800, 7800 ], "mapped", [ 7801 ] ], [ [ 7801, 7801 ], "valid" ], [ [ 7802, 7802 ], "mapped", [ 7803 ] ], [ [ 7803, 7803 ], "valid" ], [ [ 7804, 7804 ], "mapped", [ 7805 ] ], [ [ 7805, 7805 ], "valid" ], [ [ 7806, 7806 ], "mapped", [ 7807 ] ], [ [ 7807, 7807 ], "valid" ], [ [ 7808, 7808 ], "mapped", [ 7809 ] ], [ [ 7809, 7809 ], "valid" ], [ [ 7810, 7810 ], "mapped", [ 7811 ] ], [ [ 7811, 7811 ], "valid" ], [ [ 7812, 7812 ], "mapped", [ 7813 ] ], [ [ 7813, 7813 ], "valid" ], [ [ 7814, 7814 ], "mapped", [ 7815 ] ], [ [ 7815, 7815 ], "valid" ], [ [ 7816, 7816 ], "mapped", [ 7817 ] ], [ [ 7817, 7817 ], "valid" ], [ [ 7818, 7818 ], "mapped", [ 7819 ] ], [ [ 7819, 7819 ], "valid" ], [ [ 7820, 7820 ], "mapped", [ 7821 ] ], [ [ 7821, 7821 ], "valid" ], [ [ 7822, 7822 ], "mapped", [ 7823 ] ], [ [ 7823, 7823 ], "valid" ], [ [ 7824, 7824 ], "mapped", [ 7825 ] ], [ [ 7825, 7825 ], "valid" ], [ [ 7826, 7826 ], "mapped", [ 7827 ] ], [ [ 7827, 7827 ], "valid" ], [ [ 7828, 7828 ], "mapped", [ 7829 ] ], [ [ 7829, 7833 ], "valid" ], [ [ 7834, 7834 ], "mapped", [ 97, 702 ] ], [ [ 7835, 7835 ], "mapped", [ 7777 ] ], [ [ 7836, 7837 ], "valid" ], [ [ 7838, 7838 ], "mapped", [ 115, 115 ] ], [ [ 7839, 7839 ], "valid" ], [ [ 7840, 7840 ], "mapped", [ 7841 ] ], [ [ 7841, 7841 ], "valid" ], [ [ 7842, 7842 ], "mapped", [ 7843 ] ], [ [ 7843, 7843 ], "valid" ], [ [ 7844, 7844 ], "mapped", [ 7845 ] ], [ [ 7845, 7845 ], "valid" ], [ [ 7846, 7846 ], "mapped", [ 7847 ] ], [ [ 7847, 7847 ], "valid" ], [ [ 7848, 7848 ], "mapped", [ 7849 ] ], [ [ 7849, 7849 ], "valid" ], [ [ 7850, 7850 ], "mapped", [ 7851 ] ], [ [ 7851, 7851 ], "valid" ], [ [ 7852, 7852 ], "mapped", [ 7853 ] ], [ [ 7853, 7853 ], "valid" ], [ [ 7854, 7854 ], "mapped", [ 7855 ] ], [ [ 7855, 7855 ], "valid" ], [ [ 7856, 7856 ], "mapped", [ 7857 ] ], [ [ 7857, 7857 ], "valid" ], [ [ 7858, 7858 ], "mapped", [ 7859 ] ], [ [ 7859, 7859 ], "valid" ], [ [ 7860, 7860 ], "mapped", [ 7861 ] ], [ [ 7861, 7861 ], "valid" ], [ [ 7862, 7862 ], "mapped", [ 7863 ] ], [ [ 7863, 7863 ], "valid" ], [ [ 7864, 7864 ], "mapped", [ 7865 ] ], [ [ 7865, 7865 ], "valid" ], [ [ 7866, 7866 ], "mapped", [ 7867 ] ], [ [ 7867, 7867 ], "valid" ], [ [ 7868, 7868 ], "mapped", [ 7869 ] ], [ [ 7869, 7869 ], "valid" ], [ [ 7870, 7870 ], "mapped", [ 7871 ] ], [ [ 7871, 7871 ], "valid" ], [ [ 7872, 7872 ], "mapped", [ 7873 ] ], [ [ 7873, 7873 ], "valid" ], [ [ 7874, 7874 ], "mapped", [ 7875 ] ], [ [ 7875, 7875 ], "valid" ], [ [ 7876, 7876 ], "mapped", [ 7877 ] ], [ [ 7877, 7877 ], "valid" ], [ [ 7878, 7878 ], "mapped", [ 7879 ] ], [ [ 7879, 7879 ], "valid" ], [ [ 7880, 7880 ], "mapped", [ 7881 ] ], [ [ 7881, 7881 ], "valid" ], [ [ 7882, 7882 ], "mapped", [ 7883 ] ], [ [ 7883, 7883 ], "valid" ], [ [ 7884, 7884 ], "mapped", [ 7885 ] ], [ [ 7885, 7885 ], "valid" ], [ [ 7886, 7886 ], "mapped", [ 7887 ] ], [ [ 7887, 7887 ], "valid" ], [ [ 7888, 7888 ], "mapped", [ 7889 ] ], [ [ 7889, 7889 ], "valid" ], [ [ 7890, 7890 ], "mapped", [ 7891 ] ], [ [ 7891, 7891 ], "valid" ], [ [ 7892, 7892 ], "mapped", [ 7893 ] ], [ [ 7893, 7893 ], "valid" ], [ [ 7894, 7894 ], "mapped", [ 7895 ] ], [ [ 7895, 7895 ], "valid" ], [ [ 7896, 7896 ], "mapped", [ 7897 ] ], [ [ 7897, 7897 ], "valid" ], [ [ 7898, 7898 ], "mapped", [ 7899 ] ], [ [ 7899, 7899 ], "valid" ], [ [ 7900, 7900 ], "mapped", [ 7901 ] ], [ [ 7901, 7901 ], "valid" ], [ [ 7902, 7902 ], "mapped", [ 7903 ] ], [ [ 7903, 7903 ], "valid" ], [ [ 7904, 7904 ], "mapped", [ 7905 ] ], [ [ 7905, 7905 ], "valid" ], [ [ 7906, 7906 ], "mapped", [ 7907 ] ], [ [ 7907, 7907 ], "valid" ], [ [ 7908, 7908 ], "mapped", [ 7909 ] ], [ [ 7909, 7909 ], "valid" ], [ [ 7910, 7910 ], "mapped", [ 7911 ] ], [ [ 7911, 7911 ], "valid" ], [ [ 7912, 7912 ], "mapped", [ 7913 ] ], [ [ 7913, 7913 ], "valid" ], [ [ 7914, 7914 ], "mapped", [ 7915 ] ], [ [ 7915, 7915 ], "valid" ], [ [ 7916, 7916 ], "mapped", [ 7917 ] ], [ [ 7917, 7917 ], "valid" ], [ [ 7918, 7918 ], "mapped", [ 7919 ] ], [ [ 7919, 7919 ], "valid" ], [ [ 7920, 7920 ], "mapped", [ 7921 ] ], [ [ 7921, 7921 ], "valid" ], [ [ 7922, 7922 ], "mapped", [ 7923 ] ], [ [ 7923, 7923 ], "valid" ], [ [ 7924, 7924 ], "mapped", [ 7925 ] ], [ [ 7925, 7925 ], "valid" ], [ [ 7926, 7926 ], "mapped", [ 7927 ] ], [ [ 7927, 7927 ], "valid" ], [ [ 7928, 7928 ], "mapped", [ 7929 ] ], [ [ 7929, 7929 ], "valid" ], [ [ 7930, 7930 ], "mapped", [ 7931 ] ], [ [ 7931, 7931 ], "valid" ], [ [ 7932, 7932 ], "mapped", [ 7933 ] ], [ [ 7933, 7933 ], "valid" ], [ [ 7934, 7934 ], "mapped", [ 7935 ] ], [ [ 7935, 7935 ], "valid" ], [ [ 7936, 7943 ], "valid" ], [ [ 7944, 7944 ], "mapped", [ 7936 ] ], [ [ 7945, 7945 ], "mapped", [ 7937 ] ], [ [ 7946, 7946 ], "mapped", [ 7938 ] ], [ [ 7947, 7947 ], "mapped", [ 7939 ] ], [ [ 7948, 7948 ], "mapped", [ 7940 ] ], [ [ 7949, 7949 ], "mapped", [ 7941 ] ], [ [ 7950, 7950 ], "mapped", [ 7942 ] ], [ [ 7951, 7951 ], "mapped", [ 7943 ] ], [ [ 7952, 7957 ], "valid" ], [ [ 7958, 7959 ], "disallowed" ], [ [ 7960, 7960 ], "mapped", [ 7952 ] ], [ [ 7961, 7961 ], "mapped", [ 7953 ] ], [ [ 7962, 7962 ], "mapped", [ 7954 ] ], [ [ 7963, 7963 ], "mapped", [ 7955 ] ], [ [ 7964, 7964 ], "mapped", [ 7956 ] ], [ [ 7965, 7965 ], "mapped", [ 7957 ] ], [ [ 7966, 7967 ], "disallowed" ], [ [ 7968, 7975 ], "valid" ], [ [ 7976, 7976 ], "mapped", [ 7968 ] ], [ [ 7977, 7977 ], "mapped", [ 7969 ] ], [ [ 7978, 7978 ], "mapped", [ 7970 ] ], [ [ 7979, 7979 ], "mapped", [ 7971 ] ], [ [ 7980, 7980 ], "mapped", [ 7972 ] ], [ [ 7981, 7981 ], "mapped", [ 7973 ] ], [ [ 7982, 7982 ], "mapped", [ 7974 ] ], [ [ 7983, 7983 ], "mapped", [ 7975 ] ], [ [ 7984, 7991 ], "valid" ], [ [ 7992, 7992 ], "mapped", [ 7984 ] ], [ [ 7993, 7993 ], "mapped", [ 7985 ] ], [ [ 7994, 7994 ], "mapped", [ 7986 ] ], [ [ 7995, 7995 ], "mapped", [ 7987 ] ], [ [ 7996, 7996 ], "mapped", [ 7988 ] ], [ [ 7997, 7997 ], "mapped", [ 7989 ] ], [ [ 7998, 7998 ], "mapped", [ 7990 ] ], [ [ 7999, 7999 ], "mapped", [ 7991 ] ], [ [ 8e3, 8005 ], "valid" ], [ [ 8006, 8007 ], "disallowed" ], [ [ 8008, 8008 ], "mapped", [ 8e3 ] ], [ [ 8009, 8009 ], "mapped", [ 8001 ] ], [ [ 8010, 8010 ], "mapped", [ 8002 ] ], [ [ 8011, 8011 ], "mapped", [ 8003 ] ], [ [ 8012, 8012 ], "mapped", [ 8004 ] ], [ [ 8013, 8013 ], "mapped", [ 8005 ] ], [ [ 8014, 8015 ], "disallowed" ], [ [ 8016, 8023 ], "valid" ], [ [ 8024, 8024 ], "disallowed" ], [ [ 8025, 8025 ], "mapped", [ 8017 ] ], [ [ 8026, 8026 ], "disallowed" ], [ [ 8027, 8027 ], "mapped", [ 8019 ] ], [ [ 8028, 8028 ], "disallowed" ], [ [ 8029, 8029 ], "mapped", [ 8021 ] ], [ [ 8030, 8030 ], "disallowed" ], [ [ 8031, 8031 ], "mapped", [ 8023 ] ], [ [ 8032, 8039 ], "valid" ], [ [ 8040, 8040 ], "mapped", [ 8032 ] ], [ [ 8041, 8041 ], "mapped", [ 8033 ] ], [ [ 8042, 8042 ], "mapped", [ 8034 ] ], [ [ 8043, 8043 ], "mapped", [ 8035 ] ], [ [ 8044, 8044 ], "mapped", [ 8036 ] ], [ [ 8045, 8045 ], "mapped", [ 8037 ] ], [ [ 8046, 8046 ], "mapped", [ 8038 ] ], [ [ 8047, 8047 ], "mapped", [ 8039 ] ], [ [ 8048, 8048 ], "valid" ], [ [ 8049, 8049 ], "mapped", [ 940 ] ], [ [ 8050, 8050 ], "valid" ], [ [ 8051, 8051 ], "mapped", [ 941 ] ], [ [ 8052, 8052 ], "valid" ], [ [ 8053, 8053 ], "mapped", [ 942 ] ], [ [ 8054, 8054 ], "valid" ], [ [ 8055, 8055 ], "mapped", [ 943 ] ], [ [ 8056, 8056 ], "valid" ], [ [ 8057, 8057 ], "mapped", [ 972 ] ], [ [ 8058, 8058 ], "valid" ], [ [ 8059, 8059 ], "mapped", [ 973 ] ], [ [ 8060, 8060 ], "valid" ], [ [ 8061, 8061 ], "mapped", [ 974 ] ], [ [ 8062, 8063 ], "disallowed" ], [ [ 8064, 8064 ], "mapped", [ 7936, 953 ] ], [ [ 8065, 8065 ], "mapped", [ 7937, 953 ] ], [ [ 8066, 8066 ], "mapped", [ 7938, 953 ] ], [ [ 8067, 8067 ], "mapped", [ 7939, 953 ] ], [ [ 8068, 8068 ], "mapped", [ 7940, 953 ] ], [ [ 8069, 8069 ], "mapped", [ 7941, 953 ] ], [ [ 8070, 8070 ], "mapped", [ 7942, 953 ] ], [ [ 8071, 8071 ], "mapped", [ 7943, 953 ] ], [ [ 8072, 8072 ], "mapped", [ 7936, 953 ] ], [ [ 8073, 8073 ], "mapped", [ 7937, 953 ] ], [ [ 8074, 8074 ], "mapped", [ 7938, 953 ] ], [ [ 8075, 8075 ], "mapped", [ 7939, 953 ] ], [ [ 8076, 8076 ], "mapped", [ 7940, 953 ] ], [ [ 8077, 8077 ], "mapped", [ 7941, 953 ] ], [ [ 8078, 8078 ], "mapped", [ 7942, 953 ] ], [ [ 8079, 8079 ], "mapped", [ 7943, 953 ] ], [ [ 8080, 8080 ], "mapped", [ 7968, 953 ] ], [ [ 8081, 8081 ], "mapped", [ 7969, 953 ] ], [ [ 8082, 8082 ], "mapped", [ 7970, 953 ] ], [ [ 8083, 8083 ], "mapped", [ 7971, 953 ] ], [ [ 8084, 8084 ], "mapped", [ 7972, 953 ] ], [ [ 8085, 8085 ], "mapped", [ 7973, 953 ] ], [ [ 8086, 8086 ], "mapped", [ 7974, 953 ] ], [ [ 8087, 8087 ], "mapped", [ 7975, 953 ] ], [ [ 8088, 8088 ], "mapped", [ 7968, 953 ] ], [ [ 8089, 8089 ], "mapped", [ 7969, 953 ] ], [ [ 8090, 8090 ], "mapped", [ 7970, 953 ] ], [ [ 8091, 8091 ], "mapped", [ 7971, 953 ] ], [ [ 8092, 8092 ], "mapped", [ 7972, 953 ] ], [ [ 8093, 8093 ], "mapped", [ 7973, 953 ] ], [ [ 8094, 8094 ], "mapped", [ 7974, 953 ] ], [ [ 8095, 8095 ], "mapped", [ 7975, 953 ] ], [ [ 8096, 8096 ], "mapped", [ 8032, 953 ] ], [ [ 8097, 8097 ], "mapped", [ 8033, 953 ] ], [ [ 8098, 8098 ], "mapped", [ 8034, 953 ] ], [ [ 8099, 8099 ], "mapped", [ 8035, 953 ] ], [ [ 8100, 8100 ], "mapped", [ 8036, 953 ] ], [ [ 8101, 8101 ], "mapped", [ 8037, 953 ] ], [ [ 8102, 8102 ], "mapped", [ 8038, 953 ] ], [ [ 8103, 8103 ], "mapped", [ 8039, 953 ] ], [ [ 8104, 8104 ], "mapped", [ 8032, 953 ] ], [ [ 8105, 8105 ], "mapped", [ 8033, 953 ] ], [ [ 8106, 8106 ], "mapped", [ 8034, 953 ] ], [ [ 8107, 8107 ], "mapped", [ 8035, 953 ] ], [ [ 8108, 8108 ], "mapped", [ 8036, 953 ] ], [ [ 8109, 8109 ], "mapped", [ 8037, 953 ] ], [ [ 8110, 8110 ], "mapped", [ 8038, 953 ] ], [ [ 8111, 8111 ], "mapped", [ 8039, 953 ] ], [ [ 8112, 8113 ], "valid" ], [ [ 8114, 8114 ], "mapped", [ 8048, 953 ] ], [ [ 8115, 8115 ], "mapped", [ 945, 953 ] ], [ [ 8116, 8116 ], "mapped", [ 940, 953 ] ], [ [ 8117, 8117 ], "disallowed" ], [ [ 8118, 8118 ], "valid" ], [ [ 8119, 8119 ], "mapped", [ 8118, 953 ] ], [ [ 8120, 8120 ], "mapped", [ 8112 ] ], [ [ 8121, 8121 ], "mapped", [ 8113 ] ], [ [ 8122, 8122 ], "mapped", [ 8048 ] ], [ [ 8123, 8123 ], "mapped", [ 940 ] ], [ [ 8124, 8124 ], "mapped", [ 945, 953 ] ], [ [ 8125, 8125 ], "disallowed_STD3_mapped", [ 32, 787 ] ], [ [ 8126, 8126 ], "mapped", [ 953 ] ], [ [ 8127, 8127 ], "disallowed_STD3_mapped", [ 32, 787 ] ], [ [ 8128, 8128 ], "disallowed_STD3_mapped", [ 32, 834 ] ], [ [ 8129, 8129 ], "disallowed_STD3_mapped", [ 32, 776, 834 ] ], [ [ 8130, 8130 ], "mapped", [ 8052, 953 ] ], [ [ 8131, 8131 ], "mapped", [ 951, 953 ] ], [ [ 8132, 8132 ], "mapped", [ 942, 953 ] ], [ [ 8133, 8133 ], "disallowed" ], [ [ 8134, 8134 ], "valid" ], [ [ 8135, 8135 ], "mapped", [ 8134, 953 ] ], [ [ 8136, 8136 ], "mapped", [ 8050 ] ], [ [ 8137, 8137 ], "mapped", [ 941 ] ], [ [ 8138, 8138 ], "mapped", [ 8052 ] ], [ [ 8139, 8139 ], "mapped", [ 942 ] ], [ [ 8140, 8140 ], "mapped", [ 951, 953 ] ], [ [ 8141, 8141 ], "disallowed_STD3_mapped", [ 32, 787, 768 ] ], [ [ 8142, 8142 ], "disallowed_STD3_mapped", [ 32, 787, 769 ] ], [ [ 8143, 8143 ], "disallowed_STD3_mapped", [ 32, 787, 834 ] ], [ [ 8144, 8146 ], "valid" ], [ [ 8147, 8147 ], "mapped", [ 912 ] ], [ [ 8148, 8149 ], "disallowed" ], [ [ 8150, 8151 ], "valid" ], [ [ 8152, 8152 ], "mapped", [ 8144 ] ], [ [ 8153, 8153 ], "mapped", [ 8145 ] ], [ [ 8154, 8154 ], "mapped", [ 8054 ] ], [ [ 8155, 8155 ], "mapped", [ 943 ] ], [ [ 8156, 8156 ], "disallowed" ], [ [ 8157, 8157 ], "disallowed_STD3_mapped", [ 32, 788, 768 ] ], [ [ 8158, 8158 ], "disallowed_STD3_mapped", [ 32, 788, 769 ] ], [ [ 8159, 8159 ], "disallowed_STD3_mapped", [ 32, 788, 834 ] ], [ [ 8160, 8162 ], "valid" ], [ [ 8163, 8163 ], "mapped", [ 944 ] ], [ [ 8164, 8167 ], "valid" ], [ [ 8168, 8168 ], "mapped", [ 8160 ] ], [ [ 8169, 8169 ], "mapped", [ 8161 ] ], [ [ 8170, 8170 ], "mapped", [ 8058 ] ], [ [ 8171, 8171 ], "mapped", [ 973 ] ], [ [ 8172, 8172 ], "mapped", [ 8165 ] ], [ [ 8173, 8173 ], "disallowed_STD3_mapped", [ 32, 776, 768 ] ], [ [ 8174, 8174 ], "disallowed_STD3_mapped", [ 32, 776, 769 ] ], [ [ 8175, 8175 ], "disallowed_STD3_mapped", [ 96 ] ], [ [ 8176, 8177 ], "disallowed" ], [ [ 8178, 8178 ], "mapped", [ 8060, 953 ] ], [ [ 8179, 8179 ], "mapped", [ 969, 953 ] ], [ [ 8180, 8180 ], "mapped", [ 974, 953 ] ], [ [ 8181, 8181 ], "disallowed" ], [ [ 8182, 8182 ], "valid" ], [ [ 8183, 8183 ], "mapped", [ 8182, 953 ] ], [ [ 8184, 8184 ], "mapped", [ 8056 ] ], [ [ 8185, 8185 ], "mapped", [ 972 ] ], [ [ 8186, 8186 ], "mapped", [ 8060 ] ], [ [ 8187, 8187 ], "mapped", [ 974 ] ], [ [ 8188, 8188 ], "mapped", [ 969, 953 ] ], [ [ 8189, 8189 ], "disallowed_STD3_mapped", [ 32, 769 ] ], [ [ 8190, 8190 ], "disallowed_STD3_mapped", [ 32, 788 ] ], [ [ 8191, 8191 ], "disallowed" ], [ [ 8192, 8202 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 8203, 8203 ], "ignored" ], [ [ 8204, 8205 ], "deviation", [] ], [ [ 8206, 8207 ], "disallowed" ], [ [ 8208, 8208 ], "valid", [], "NV8" ], [ [ 8209, 8209 ], "mapped", [ 8208 ] ], [ [ 8210, 8214 ], "valid", [], "NV8" ], [ [ 8215, 8215 ], "disallowed_STD3_mapped", [ 32, 819 ] ], [ [ 8216, 8227 ], "valid", [], "NV8" ], [ [ 8228, 8230 ], "disallowed" ], [ [ 8231, 8231 ], "valid", [], "NV8" ], [ [ 8232, 8238 ], "disallowed" ], [ [ 8239, 8239 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 8240, 8242 ], "valid", [], "NV8" ], [ [ 8243, 8243 ], "mapped", [ 8242, 8242 ] ], [ [ 8244, 8244 ], "mapped", [ 8242, 8242, 8242 ] ], [ [ 8245, 8245 ], "valid", [], "NV8" ], [ [ 8246, 8246 ], "mapped", [ 8245, 8245 ] ], [ [ 8247, 8247 ], "mapped", [ 8245, 8245, 8245 ] ], [ [ 8248, 8251 ], "valid", [], "NV8" ], [ [ 8252, 8252 ], "disallowed_STD3_mapped", [ 33, 33 ] ], [ [ 8253, 8253 ], "valid", [], "NV8" ], [ [ 8254, 8254 ], "disallowed_STD3_mapped", [ 32, 773 ] ], [ [ 8255, 8262 ], "valid", [], "NV8" ], [ [ 8263, 8263 ], "disallowed_STD3_mapped", [ 63, 63 ] ], [ [ 8264, 8264 ], "disallowed_STD3_mapped", [ 63, 33 ] ], [ [ 8265, 8265 ], "disallowed_STD3_mapped", [ 33, 63 ] ], [ [ 8266, 8269 ], "valid", [], "NV8" ], [ [ 8270, 8274 ], "valid", [], "NV8" ], [ [ 8275, 8276 ], "valid", [], "NV8" ], [ [ 8277, 8278 ], "valid", [], "NV8" ], [ [ 8279, 8279 ], "mapped", [ 8242, 8242, 8242, 8242 ] ], [ [ 8280, 8286 ], "valid", [], "NV8" ], [ [ 8287, 8287 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 8288, 8288 ], "ignored" ], [ [ 8289, 8291 ], "disallowed" ], [ [ 8292, 8292 ], "ignored" ], [ [ 8293, 8293 ], "disallowed" ], [ [ 8294, 8297 ], "disallowed" ], [ [ 8298, 8303 ], "disallowed" ], [ [ 8304, 8304 ], "mapped", [ 48 ] ], [ [ 8305, 8305 ], "mapped", [ 105 ] ], [ [ 8306, 8307 ], "disallowed" ], [ [ 8308, 8308 ], "mapped", [ 52 ] ], [ [ 8309, 8309 ], "mapped", [ 53 ] ], [ [ 8310, 8310 ], "mapped", [ 54 ] ], [ [ 8311, 8311 ], "mapped", [ 55 ] ], [ [ 8312, 8312 ], "mapped", [ 56 ] ], [ [ 8313, 8313 ], "mapped", [ 57 ] ], [ [ 8314, 8314 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 8315, 8315 ], "mapped", [ 8722 ] ], [ [ 8316, 8316 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 8317, 8317 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 8318, 8318 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 8319, 8319 ], "mapped", [ 110 ] ], [ [ 8320, 8320 ], "mapped", [ 48 ] ], [ [ 8321, 8321 ], "mapped", [ 49 ] ], [ [ 8322, 8322 ], "mapped", [ 50 ] ], [ [ 8323, 8323 ], "mapped", [ 51 ] ], [ [ 8324, 8324 ], "mapped", [ 52 ] ], [ [ 8325, 8325 ], "mapped", [ 53 ] ], [ [ 8326, 8326 ], "mapped", [ 54 ] ], [ [ 8327, 8327 ], "mapped", [ 55 ] ], [ [ 8328, 8328 ], "mapped", [ 56 ] ], [ [ 8329, 8329 ], "mapped", [ 57 ] ], [ [ 8330, 8330 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 8331, 8331 ], "mapped", [ 8722 ] ], [ [ 8332, 8332 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 8333, 8333 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 8334, 8334 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 8335, 8335 ], "disallowed" ], [ [ 8336, 8336 ], "mapped", [ 97 ] ], [ [ 8337, 8337 ], "mapped", [ 101 ] ], [ [ 8338, 8338 ], "mapped", [ 111 ] ], [ [ 8339, 8339 ], "mapped", [ 120 ] ], [ [ 8340, 8340 ], "mapped", [ 601 ] ], [ [ 8341, 8341 ], "mapped", [ 104 ] ], [ [ 8342, 8342 ], "mapped", [ 107 ] ], [ [ 8343, 8343 ], "mapped", [ 108 ] ], [ [ 8344, 8344 ], "mapped", [ 109 ] ], [ [ 8345, 8345 ], "mapped", [ 110 ] ], [ [ 8346, 8346 ], "mapped", [ 112 ] ], [ [ 8347, 8347 ], "mapped", [ 115 ] ], [ [ 8348, 8348 ], "mapped", [ 116 ] ], [ [ 8349, 8351 ], "disallowed" ], [ [ 8352, 8359 ], "valid", [], "NV8" ], [ [ 8360, 8360 ], "mapped", [ 114, 115 ] ], [ [ 8361, 8362 ], "valid", [], "NV8" ], [ [ 8363, 8363 ], "valid", [], "NV8" ], [ [ 8364, 8364 ], "valid", [], "NV8" ], [ [ 8365, 8367 ], "valid", [], "NV8" ], [ [ 8368, 8369 ], "valid", [], "NV8" ], [ [ 8370, 8373 ], "valid", [], "NV8" ], [ [ 8374, 8376 ], "valid", [], "NV8" ], [ [ 8377, 8377 ], "valid", [], "NV8" ], [ [ 8378, 8378 ], "valid", [], "NV8" ], [ [ 8379, 8381 ], "valid", [], "NV8" ], [ [ 8382, 8382 ], "valid", [], "NV8" ], [ [ 8383, 8399 ], "disallowed" ], [ [ 8400, 8417 ], "valid", [], "NV8" ], [ [ 8418, 8419 ], "valid", [], "NV8" ], [ [ 8420, 8426 ], "valid", [], "NV8" ], [ [ 8427, 8427 ], "valid", [], "NV8" ], [ [ 8428, 8431 ], "valid", [], "NV8" ], [ [ 8432, 8432 ], "valid", [], "NV8" ], [ [ 8433, 8447 ], "disallowed" ], [ [ 8448, 8448 ], "disallowed_STD3_mapped", [ 97, 47, 99 ] ], [ [ 8449, 8449 ], "disallowed_STD3_mapped", [ 97, 47, 115 ] ], [ [ 8450, 8450 ], "mapped", [ 99 ] ], [ [ 8451, 8451 ], "mapped", [ 176, 99 ] ], [ [ 8452, 8452 ], "valid", [], "NV8" ], [ [ 8453, 8453 ], "disallowed_STD3_mapped", [ 99, 47, 111 ] ], [ [ 8454, 8454 ], "disallowed_STD3_mapped", [ 99, 47, 117 ] ], [ [ 8455, 8455 ], "mapped", [ 603 ] ], [ [ 8456, 8456 ], "valid", [], "NV8" ], [ [ 8457, 8457 ], "mapped", [ 176, 102 ] ], [ [ 8458, 8458 ], "mapped", [ 103 ] ], [ [ 8459, 8462 ], "mapped", [ 104 ] ], [ [ 8463, 8463 ], "mapped", [ 295 ] ], [ [ 8464, 8465 ], "mapped", [ 105 ] ], [ [ 8466, 8467 ], "mapped", [ 108 ] ], [ [ 8468, 8468 ], "valid", [], "NV8" ], [ [ 8469, 8469 ], "mapped", [ 110 ] ], [ [ 8470, 8470 ], "mapped", [ 110, 111 ] ], [ [ 8471, 8472 ], "valid", [], "NV8" ], [ [ 8473, 8473 ], "mapped", [ 112 ] ], [ [ 8474, 8474 ], "mapped", [ 113 ] ], [ [ 8475, 8477 ], "mapped", [ 114 ] ], [ [ 8478, 8479 ], "valid", [], "NV8" ], [ [ 8480, 8480 ], "mapped", [ 115, 109 ] ], [ [ 8481, 8481 ], "mapped", [ 116, 101, 108 ] ], [ [ 8482, 8482 ], "mapped", [ 116, 109 ] ], [ [ 8483, 8483 ], "valid", [], "NV8" ], [ [ 8484, 8484 ], "mapped", [ 122 ] ], [ [ 8485, 8485 ], "valid", [], "NV8" ], [ [ 8486, 8486 ], "mapped", [ 969 ] ], [ [ 8487, 8487 ], "valid", [], "NV8" ], [ [ 8488, 8488 ], "mapped", [ 122 ] ], [ [ 8489, 8489 ], "valid", [], "NV8" ], [ [ 8490, 8490 ], "mapped", [ 107 ] ], [ [ 8491, 8491 ], "mapped", [ 229 ] ], [ [ 8492, 8492 ], "mapped", [ 98 ] ], [ [ 8493, 8493 ], "mapped", [ 99 ] ], [ [ 8494, 8494 ], "valid", [], "NV8" ], [ [ 8495, 8496 ], "mapped", [ 101 ] ], [ [ 8497, 8497 ], "mapped", [ 102 ] ], [ [ 8498, 8498 ], "disallowed" ], [ [ 8499, 8499 ], "mapped", [ 109 ] ], [ [ 8500, 8500 ], "mapped", [ 111 ] ], [ [ 8501, 8501 ], "mapped", [ 1488 ] ], [ [ 8502, 8502 ], "mapped", [ 1489 ] ], [ [ 8503, 8503 ], "mapped", [ 1490 ] ], [ [ 8504, 8504 ], "mapped", [ 1491 ] ], [ [ 8505, 8505 ], "mapped", [ 105 ] ], [ [ 8506, 8506 ], "valid", [], "NV8" ], [ [ 8507, 8507 ], "mapped", [ 102, 97, 120 ] ], [ [ 8508, 8508 ], "mapped", [ 960 ] ], [ [ 8509, 8510 ], "mapped", [ 947 ] ], [ [ 8511, 8511 ], "mapped", [ 960 ] ], [ [ 8512, 8512 ], "mapped", [ 8721 ] ], [ [ 8513, 8516 ], "valid", [], "NV8" ], [ [ 8517, 8518 ], "mapped", [ 100 ] ], [ [ 8519, 8519 ], "mapped", [ 101 ] ], [ [ 8520, 8520 ], "mapped", [ 105 ] ], [ [ 8521, 8521 ], "mapped", [ 106 ] ], [ [ 8522, 8523 ], "valid", [], "NV8" ], [ [ 8524, 8524 ], "valid", [], "NV8" ], [ [ 8525, 8525 ], "valid", [], "NV8" ], [ [ 8526, 8526 ], "valid" ], [ [ 8527, 8527 ], "valid", [], "NV8" ], [ [ 8528, 8528 ], "mapped", [ 49, 8260, 55 ] ], [ [ 8529, 8529 ], "mapped", [ 49, 8260, 57 ] ], [ [ 8530, 8530 ], "mapped", [ 49, 8260, 49, 48 ] ], [ [ 8531, 8531 ], "mapped", [ 49, 8260, 51 ] ], [ [ 8532, 8532 ], "mapped", [ 50, 8260, 51 ] ], [ [ 8533, 8533 ], "mapped", [ 49, 8260, 53 ] ], [ [ 8534, 8534 ], "mapped", [ 50, 8260, 53 ] ], [ [ 8535, 8535 ], "mapped", [ 51, 8260, 53 ] ], [ [ 8536, 8536 ], "mapped", [ 52, 8260, 53 ] ], [ [ 8537, 8537 ], "mapped", [ 49, 8260, 54 ] ], [ [ 8538, 8538 ], "mapped", [ 53, 8260, 54 ] ], [ [ 8539, 8539 ], "mapped", [ 49, 8260, 56 ] ], [ [ 8540, 8540 ], "mapped", [ 51, 8260, 56 ] ], [ [ 8541, 8541 ], "mapped", [ 53, 8260, 56 ] ], [ [ 8542, 8542 ], "mapped", [ 55, 8260, 56 ] ], [ [ 8543, 8543 ], "mapped", [ 49, 8260 ] ], [ [ 8544, 8544 ], "mapped", [ 105 ] ], [ [ 8545, 8545 ], "mapped", [ 105, 105 ] ], [ [ 8546, 8546 ], "mapped", [ 105, 105, 105 ] ], [ [ 8547, 8547 ], "mapped", [ 105, 118 ] ], [ [ 8548, 8548 ], "mapped", [ 118 ] ], [ [ 8549, 8549 ], "mapped", [ 118, 105 ] ], [ [ 8550, 8550 ], "mapped", [ 118, 105, 105 ] ], [ [ 8551, 8551 ], "mapped", [ 118, 105, 105, 105 ] ], [ [ 8552, 8552 ], "mapped", [ 105, 120 ] ], [ [ 8553, 8553 ], "mapped", [ 120 ] ], [ [ 8554, 8554 ], "mapped", [ 120, 105 ] ], [ [ 8555, 8555 ], "mapped", [ 120, 105, 105 ] ], [ [ 8556, 8556 ], "mapped", [ 108 ] ], [ [ 8557, 8557 ], "mapped", [ 99 ] ], [ [ 8558, 8558 ], "mapped", [ 100 ] ], [ [ 8559, 8559 ], "mapped", [ 109 ] ], [ [ 8560, 8560 ], "mapped", [ 105 ] ], [ [ 8561, 8561 ], "mapped", [ 105, 105 ] ], [ [ 8562, 8562 ], "mapped", [ 105, 105, 105 ] ], [ [ 8563, 8563 ], "mapped", [ 105, 118 ] ], [ [ 8564, 8564 ], "mapped", [ 118 ] ], [ [ 8565, 8565 ], "mapped", [ 118, 105 ] ], [ [ 8566, 8566 ], "mapped", [ 118, 105, 105 ] ], [ [ 8567, 8567 ], "mapped", [ 118, 105, 105, 105 ] ], [ [ 8568, 8568 ], "mapped", [ 105, 120 ] ], [ [ 8569, 8569 ], "mapped", [ 120 ] ], [ [ 8570, 8570 ], "mapped", [ 120, 105 ] ], [ [ 8571, 8571 ], "mapped", [ 120, 105, 105 ] ], [ [ 8572, 8572 ], "mapped", [ 108 ] ], [ [ 8573, 8573 ], "mapped", [ 99 ] ], [ [ 8574, 8574 ], "mapped", [ 100 ] ], [ [ 8575, 8575 ], "mapped", [ 109 ] ], [ [ 8576, 8578 ], "valid", [], "NV8" ], [ [ 8579, 8579 ], "disallowed" ], [ [ 8580, 8580 ], "valid" ], [ [ 8581, 8584 ], "valid", [], "NV8" ], [ [ 8585, 8585 ], "mapped", [ 48, 8260, 51 ] ], [ [ 8586, 8587 ], "valid", [], "NV8" ], [ [ 8588, 8591 ], "disallowed" ], [ [ 8592, 8682 ], "valid", [], "NV8" ], [ [ 8683, 8691 ], "valid", [], "NV8" ], [ [ 8692, 8703 ], "valid", [], "NV8" ], [ [ 8704, 8747 ], "valid", [], "NV8" ], [ [ 8748, 8748 ], "mapped", [ 8747, 8747 ] ], [ [ 8749, 8749 ], "mapped", [ 8747, 8747, 8747 ] ], [ [ 8750, 8750 ], "valid", [], "NV8" ], [ [ 8751, 8751 ], "mapped", [ 8750, 8750 ] ], [ [ 8752, 8752 ], "mapped", [ 8750, 8750, 8750 ] ], [ [ 8753, 8799 ], "valid", [], "NV8" ], [ [ 8800, 8800 ], "disallowed_STD3_valid" ], [ [ 8801, 8813 ], "valid", [], "NV8" ], [ [ 8814, 8815 ], "disallowed_STD3_valid" ], [ [ 8816, 8945 ], "valid", [], "NV8" ], [ [ 8946, 8959 ], "valid", [], "NV8" ], [ [ 8960, 8960 ], "valid", [], "NV8" ], [ [ 8961, 8961 ], "valid", [], "NV8" ], [ [ 8962, 9e3 ], "valid", [], "NV8" ], [ [ 9001, 9001 ], "mapped", [ 12296 ] ], [ [ 9002, 9002 ], "mapped", [ 12297 ] ], [ [ 9003, 9082 ], "valid", [], "NV8" ], [ [ 9083, 9083 ], "valid", [], "NV8" ], [ [ 9084, 9084 ], "valid", [], "NV8" ], [ [ 9085, 9114 ], "valid", [], "NV8" ], [ [ 9115, 9166 ], "valid", [], "NV8" ], [ [ 9167, 9168 ], "valid", [], "NV8" ], [ [ 9169, 9179 ], "valid", [], "NV8" ], [ [ 9180, 9191 ], "valid", [], "NV8" ], [ [ 9192, 9192 ], "valid", [], "NV8" ], [ [ 9193, 9203 ], "valid", [], "NV8" ], [ [ 9204, 9210 ], "valid", [], "NV8" ], [ [ 9211, 9215 ], "disallowed" ], [ [ 9216, 9252 ], "valid", [], "NV8" ], [ [ 9253, 9254 ], "valid", [], "NV8" ], [ [ 9255, 9279 ], "disallowed" ], [ [ 9280, 9290 ], "valid", [], "NV8" ], [ [ 9291, 9311 ], "disallowed" ], [ [ 9312, 9312 ], "mapped", [ 49 ] ], [ [ 9313, 9313 ], "mapped", [ 50 ] ], [ [ 9314, 9314 ], "mapped", [ 51 ] ], [ [ 9315, 9315 ], "mapped", [ 52 ] ], [ [ 9316, 9316 ], "mapped", [ 53 ] ], [ [ 9317, 9317 ], "mapped", [ 54 ] ], [ [ 9318, 9318 ], "mapped", [ 55 ] ], [ [ 9319, 9319 ], "mapped", [ 56 ] ], [ [ 9320, 9320 ], "mapped", [ 57 ] ], [ [ 9321, 9321 ], "mapped", [ 49, 48 ] ], [ [ 9322, 9322 ], "mapped", [ 49, 49 ] ], [ [ 9323, 9323 ], "mapped", [ 49, 50 ] ], [ [ 9324, 9324 ], "mapped", [ 49, 51 ] ], [ [ 9325, 9325 ], "mapped", [ 49, 52 ] ], [ [ 9326, 9326 ], "mapped", [ 49, 53 ] ], [ [ 9327, 9327 ], "mapped", [ 49, 54 ] ], [ [ 9328, 9328 ], "mapped", [ 49, 55 ] ], [ [ 9329, 9329 ], "mapped", [ 49, 56 ] ], [ [ 9330, 9330 ], "mapped", [ 49, 57 ] ], [ [ 9331, 9331 ], "mapped", [ 50, 48 ] ], [ [ 9332, 9332 ], "disallowed_STD3_mapped", [ 40, 49, 41 ] ], [ [ 9333, 9333 ], "disallowed_STD3_mapped", [ 40, 50, 41 ] ], [ [ 9334, 9334 ], "disallowed_STD3_mapped", [ 40, 51, 41 ] ], [ [ 9335, 9335 ], "disallowed_STD3_mapped", [ 40, 52, 41 ] ], [ [ 9336, 9336 ], "disallowed_STD3_mapped", [ 40, 53, 41 ] ], [ [ 9337, 9337 ], "disallowed_STD3_mapped", [ 40, 54, 41 ] ], [ [ 9338, 9338 ], "disallowed_STD3_mapped", [ 40, 55, 41 ] ], [ [ 9339, 9339 ], "disallowed_STD3_mapped", [ 40, 56, 41 ] ], [ [ 9340, 9340 ], "disallowed_STD3_mapped", [ 40, 57, 41 ] ], [ [ 9341, 9341 ], "disallowed_STD3_mapped", [ 40, 49, 48, 41 ] ], [ [ 9342, 9342 ], "disallowed_STD3_mapped", [ 40, 49, 49, 41 ] ], [ [ 9343, 9343 ], "disallowed_STD3_mapped", [ 40, 49, 50, 41 ] ], [ [ 9344, 9344 ], "disallowed_STD3_mapped", [ 40, 49, 51, 41 ] ], [ [ 9345, 9345 ], "disallowed_STD3_mapped", [ 40, 49, 52, 41 ] ], [ [ 9346, 9346 ], "disallowed_STD3_mapped", [ 40, 49, 53, 41 ] ], [ [ 9347, 9347 ], "disallowed_STD3_mapped", [ 40, 49, 54, 41 ] ], [ [ 9348, 9348 ], "disallowed_STD3_mapped", [ 40, 49, 55, 41 ] ], [ [ 9349, 9349 ], "disallowed_STD3_mapped", [ 40, 49, 56, 41 ] ], [ [ 9350, 9350 ], "disallowed_STD3_mapped", [ 40, 49, 57, 41 ] ], [ [ 9351, 9351 ], "disallowed_STD3_mapped", [ 40, 50, 48, 41 ] ], [ [ 9352, 9371 ], "disallowed" ], [ [ 9372, 9372 ], "disallowed_STD3_mapped", [ 40, 97, 41 ] ], [ [ 9373, 9373 ], "disallowed_STD3_mapped", [ 40, 98, 41 ] ], [ [ 9374, 9374 ], "disallowed_STD3_mapped", [ 40, 99, 41 ] ], [ [ 9375, 9375 ], "disallowed_STD3_mapped", [ 40, 100, 41 ] ], [ [ 9376, 9376 ], "disallowed_STD3_mapped", [ 40, 101, 41 ] ], [ [ 9377, 9377 ], "disallowed_STD3_mapped", [ 40, 102, 41 ] ], [ [ 9378, 9378 ], "disallowed_STD3_mapped", [ 40, 103, 41 ] ], [ [ 9379, 9379 ], "disallowed_STD3_mapped", [ 40, 104, 41 ] ], [ [ 9380, 9380 ], "disallowed_STD3_mapped", [ 40, 105, 41 ] ], [ [ 9381, 9381 ], "disallowed_STD3_mapped", [ 40, 106, 41 ] ], [ [ 9382, 9382 ], "disallowed_STD3_mapped", [ 40, 107, 41 ] ], [ [ 9383, 9383 ], "disallowed_STD3_mapped", [ 40, 108, 41 ] ], [ [ 9384, 9384 ], "disallowed_STD3_mapped", [ 40, 109, 41 ] ], [ [ 9385, 9385 ], "disallowed_STD3_mapped", [ 40, 110, 41 ] ], [ [ 9386, 9386 ], "disallowed_STD3_mapped", [ 40, 111, 41 ] ], [ [ 9387, 9387 ], "disallowed_STD3_mapped", [ 40, 112, 41 ] ], [ [ 9388, 9388 ], "disallowed_STD3_mapped", [ 40, 113, 41 ] ], [ [ 9389, 9389 ], "disallowed_STD3_mapped", [ 40, 114, 41 ] ], [ [ 9390, 9390 ], "disallowed_STD3_mapped", [ 40, 115, 41 ] ], [ [ 9391, 9391 ], "disallowed_STD3_mapped", [ 40, 116, 41 ] ], [ [ 9392, 9392 ], "disallowed_STD3_mapped", [ 40, 117, 41 ] ], [ [ 9393, 9393 ], "disallowed_STD3_mapped", [ 40, 118, 41 ] ], [ [ 9394, 9394 ], "disallowed_STD3_mapped", [ 40, 119, 41 ] ], [ [ 9395, 9395 ], "disallowed_STD3_mapped", [ 40, 120, 41 ] ], [ [ 9396, 9396 ], "disallowed_STD3_mapped", [ 40, 121, 41 ] ], [ [ 9397, 9397 ], "disallowed_STD3_mapped", [ 40, 122, 41 ] ], [ [ 9398, 9398 ], "mapped", [ 97 ] ], [ [ 9399, 9399 ], "mapped", [ 98 ] ], [ [ 9400, 9400 ], "mapped", [ 99 ] ], [ [ 9401, 9401 ], "mapped", [ 100 ] ], [ [ 9402, 9402 ], "mapped", [ 101 ] ], [ [ 9403, 9403 ], "mapped", [ 102 ] ], [ [ 9404, 9404 ], "mapped", [ 103 ] ], [ [ 9405, 9405 ], "mapped", [ 104 ] ], [ [ 9406, 9406 ], "mapped", [ 105 ] ], [ [ 9407, 9407 ], "mapped", [ 106 ] ], [ [ 9408, 9408 ], "mapped", [ 107 ] ], [ [ 9409, 9409 ], "mapped", [ 108 ] ], [ [ 9410, 9410 ], "mapped", [ 109 ] ], [ [ 9411, 9411 ], "mapped", [ 110 ] ], [ [ 9412, 9412 ], "mapped", [ 111 ] ], [ [ 9413, 9413 ], "mapped", [ 112 ] ], [ [ 9414, 9414 ], "mapped", [ 113 ] ], [ [ 9415, 9415 ], "mapped", [ 114 ] ], [ [ 9416, 9416 ], "mapped", [ 115 ] ], [ [ 9417, 9417 ], "mapped", [ 116 ] ], [ [ 9418, 9418 ], "mapped", [ 117 ] ], [ [ 9419, 9419 ], "mapped", [ 118 ] ], [ [ 9420, 9420 ], "mapped", [ 119 ] ], [ [ 9421, 9421 ], "mapped", [ 120 ] ], [ [ 9422, 9422 ], "mapped", [ 121 ] ], [ [ 9423, 9423 ], "mapped", [ 122 ] ], [ [ 9424, 9424 ], "mapped", [ 97 ] ], [ [ 9425, 9425 ], "mapped", [ 98 ] ], [ [ 9426, 9426 ], "mapped", [ 99 ] ], [ [ 9427, 9427 ], "mapped", [ 100 ] ], [ [ 9428, 9428 ], "mapped", [ 101 ] ], [ [ 9429, 9429 ], "mapped", [ 102 ] ], [ [ 9430, 9430 ], "mapped", [ 103 ] ], [ [ 9431, 9431 ], "mapped", [ 104 ] ], [ [ 9432, 9432 ], "mapped", [ 105 ] ], [ [ 9433, 9433 ], "mapped", [ 106 ] ], [ [ 9434, 9434 ], "mapped", [ 107 ] ], [ [ 9435, 9435 ], "mapped", [ 108 ] ], [ [ 9436, 9436 ], "mapped", [ 109 ] ], [ [ 9437, 9437 ], "mapped", [ 110 ] ], [ [ 9438, 9438 ], "mapped", [ 111 ] ], [ [ 9439, 9439 ], "mapped", [ 112 ] ], [ [ 9440, 9440 ], "mapped", [ 113 ] ], [ [ 9441, 9441 ], "mapped", [ 114 ] ], [ [ 9442, 9442 ], "mapped", [ 115 ] ], [ [ 9443, 9443 ], "mapped", [ 116 ] ], [ [ 9444, 9444 ], "mapped", [ 117 ] ], [ [ 9445, 9445 ], "mapped", [ 118 ] ], [ [ 9446, 9446 ], "mapped", [ 119 ] ], [ [ 9447, 9447 ], "mapped", [ 120 ] ], [ [ 9448, 9448 ], "mapped", [ 121 ] ], [ [ 9449, 9449 ], "mapped", [ 122 ] ], [ [ 9450, 9450 ], "mapped", [ 48 ] ], [ [ 9451, 9470 ], "valid", [], "NV8" ], [ [ 9471, 9471 ], "valid", [], "NV8" ], [ [ 9472, 9621 ], "valid", [], "NV8" ], [ [ 9622, 9631 ], "valid", [], "NV8" ], [ [ 9632, 9711 ], "valid", [], "NV8" ], [ [ 9712, 9719 ], "valid", [], "NV8" ], [ [ 9720, 9727 ], "valid", [], "NV8" ], [ [ 9728, 9747 ], "valid", [], "NV8" ], [ [ 9748, 9749 ], "valid", [], "NV8" ], [ [ 9750, 9751 ], "valid", [], "NV8" ], [ [ 9752, 9752 ], "valid", [], "NV8" ], [ [ 9753, 9753 ], "valid", [], "NV8" ], [ [ 9754, 9839 ], "valid", [], "NV8" ], [ [ 9840, 9841 ], "valid", [], "NV8" ], [ [ 9842, 9853 ], "valid", [], "NV8" ], [ [ 9854, 9855 ], "valid", [], "NV8" ], [ [ 9856, 9865 ], "valid", [], "NV8" ], [ [ 9866, 9873 ], "valid", [], "NV8" ], [ [ 9874, 9884 ], "valid", [], "NV8" ], [ [ 9885, 9885 ], "valid", [], "NV8" ], [ [ 9886, 9887 ], "valid", [], "NV8" ], [ [ 9888, 9889 ], "valid", [], "NV8" ], [ [ 9890, 9905 ], "valid", [], "NV8" ], [ [ 9906, 9906 ], "valid", [], "NV8" ], [ [ 9907, 9916 ], "valid", [], "NV8" ], [ [ 9917, 9919 ], "valid", [], "NV8" ], [ [ 9920, 9923 ], "valid", [], "NV8" ], [ [ 9924, 9933 ], "valid", [], "NV8" ], [ [ 9934, 9934 ], "valid", [], "NV8" ], [ [ 9935, 9953 ], "valid", [], "NV8" ], [ [ 9954, 9954 ], "valid", [], "NV8" ], [ [ 9955, 9955 ], "valid", [], "NV8" ], [ [ 9956, 9959 ], "valid", [], "NV8" ], [ [ 9960, 9983 ], "valid", [], "NV8" ], [ [ 9984, 9984 ], "valid", [], "NV8" ], [ [ 9985, 9988 ], "valid", [], "NV8" ], [ [ 9989, 9989 ], "valid", [], "NV8" ], [ [ 9990, 9993 ], "valid", [], "NV8" ], [ [ 9994, 9995 ], "valid", [], "NV8" ], [ [ 9996, 10023 ], "valid", [], "NV8" ], [ [ 10024, 10024 ], "valid", [], "NV8" ], [ [ 10025, 10059 ], "valid", [], "NV8" ], [ [ 10060, 10060 ], "valid", [], "NV8" ], [ [ 10061, 10061 ], "valid", [], "NV8" ], [ [ 10062, 10062 ], "valid", [], "NV8" ], [ [ 10063, 10066 ], "valid", [], "NV8" ], [ [ 10067, 10069 ], "valid", [], "NV8" ], [ [ 10070, 10070 ], "valid", [], "NV8" ], [ [ 10071, 10071 ], "valid", [], "NV8" ], [ [ 10072, 10078 ], "valid", [], "NV8" ], [ [ 10079, 10080 ], "valid", [], "NV8" ], [ [ 10081, 10087 ], "valid", [], "NV8" ], [ [ 10088, 10101 ], "valid", [], "NV8" ], [ [ 10102, 10132 ], "valid", [], "NV8" ], [ [ 10133, 10135 ], "valid", [], "NV8" ], [ [ 10136, 10159 ], "valid", [], "NV8" ], [ [ 10160, 10160 ], "valid", [], "NV8" ], [ [ 10161, 10174 ], "valid", [], "NV8" ], [ [ 10175, 10175 ], "valid", [], "NV8" ], [ [ 10176, 10182 ], "valid", [], "NV8" ], [ [ 10183, 10186 ], "valid", [], "NV8" ], [ [ 10187, 10187 ], "valid", [], "NV8" ], [ [ 10188, 10188 ], "valid", [], "NV8" ], [ [ 10189, 10189 ], "valid", [], "NV8" ], [ [ 10190, 10191 ], "valid", [], "NV8" ], [ [ 10192, 10219 ], "valid", [], "NV8" ], [ [ 10220, 10223 ], "valid", [], "NV8" ], [ [ 10224, 10239 ], "valid", [], "NV8" ], [ [ 10240, 10495 ], "valid", [], "NV8" ], [ [ 10496, 10763 ], "valid", [], "NV8" ], [ [ 10764, 10764 ], "mapped", [ 8747, 8747, 8747, 8747 ] ], [ [ 10765, 10867 ], "valid", [], "NV8" ], [ [ 10868, 10868 ], "disallowed_STD3_mapped", [ 58, 58, 61 ] ], [ [ 10869, 10869 ], "disallowed_STD3_mapped", [ 61, 61 ] ], [ [ 10870, 10870 ], "disallowed_STD3_mapped", [ 61, 61, 61 ] ], [ [ 10871, 10971 ], "valid", [], "NV8" ], [ [ 10972, 10972 ], "mapped", [ 10973, 824 ] ], [ [ 10973, 11007 ], "valid", [], "NV8" ], [ [ 11008, 11021 ], "valid", [], "NV8" ], [ [ 11022, 11027 ], "valid", [], "NV8" ], [ [ 11028, 11034 ], "valid", [], "NV8" ], [ [ 11035, 11039 ], "valid", [], "NV8" ], [ [ 11040, 11043 ], "valid", [], "NV8" ], [ [ 11044, 11084 ], "valid", [], "NV8" ], [ [ 11085, 11087 ], "valid", [], "NV8" ], [ [ 11088, 11092 ], "valid", [], "NV8" ], [ [ 11093, 11097 ], "valid", [], "NV8" ], [ [ 11098, 11123 ], "valid", [], "NV8" ], [ [ 11124, 11125 ], "disallowed" ], [ [ 11126, 11157 ], "valid", [], "NV8" ], [ [ 11158, 11159 ], "disallowed" ], [ [ 11160, 11193 ], "valid", [], "NV8" ], [ [ 11194, 11196 ], "disallowed" ], [ [ 11197, 11208 ], "valid", [], "NV8" ], [ [ 11209, 11209 ], "disallowed" ], [ [ 11210, 11217 ], "valid", [], "NV8" ], [ [ 11218, 11243 ], "disallowed" ], [ [ 11244, 11247 ], "valid", [], "NV8" ], [ [ 11248, 11263 ], "disallowed" ], [ [ 11264, 11264 ], "mapped", [ 11312 ] ], [ [ 11265, 11265 ], "mapped", [ 11313 ] ], [ [ 11266, 11266 ], "mapped", [ 11314 ] ], [ [ 11267, 11267 ], "mapped", [ 11315 ] ], [ [ 11268, 11268 ], "mapped", [ 11316 ] ], [ [ 11269, 11269 ], "mapped", [ 11317 ] ], [ [ 11270, 11270 ], "mapped", [ 11318 ] ], [ [ 11271, 11271 ], "mapped", [ 11319 ] ], [ [ 11272, 11272 ], "mapped", [ 11320 ] ], [ [ 11273, 11273 ], "mapped", [ 11321 ] ], [ [ 11274, 11274 ], "mapped", [ 11322 ] ], [ [ 11275, 11275 ], "mapped", [ 11323 ] ], [ [ 11276, 11276 ], "mapped", [ 11324 ] ], [ [ 11277, 11277 ], "mapped", [ 11325 ] ], [ [ 11278, 11278 ], "mapped", [ 11326 ] ], [ [ 11279, 11279 ], "mapped", [ 11327 ] ], [ [ 11280, 11280 ], "mapped", [ 11328 ] ], [ [ 11281, 11281 ], "mapped", [ 11329 ] ], [ [ 11282, 11282 ], "mapped", [ 11330 ] ], [ [ 11283, 11283 ], "mapped", [ 11331 ] ], [ [ 11284, 11284 ], "mapped", [ 11332 ] ], [ [ 11285, 11285 ], "mapped", [ 11333 ] ], [ [ 11286, 11286 ], "mapped", [ 11334 ] ], [ [ 11287, 11287 ], "mapped", [ 11335 ] ], [ [ 11288, 11288 ], "mapped", [ 11336 ] ], [ [ 11289, 11289 ], "mapped", [ 11337 ] ], [ [ 11290, 11290 ], "mapped", [ 11338 ] ], [ [ 11291, 11291 ], "mapped", [ 11339 ] ], [ [ 11292, 11292 ], "mapped", [ 11340 ] ], [ [ 11293, 11293 ], "mapped", [ 11341 ] ], [ [ 11294, 11294 ], "mapped", [ 11342 ] ], [ [ 11295, 11295 ], "mapped", [ 11343 ] ], [ [ 11296, 11296 ], "mapped", [ 11344 ] ], [ [ 11297, 11297 ], "mapped", [ 11345 ] ], [ [ 11298, 11298 ], "mapped", [ 11346 ] ], [ [ 11299, 11299 ], "mapped", [ 11347 ] ], [ [ 11300, 11300 ], "mapped", [ 11348 ] ], [ [ 11301, 11301 ], "mapped", [ 11349 ] ], [ [ 11302, 11302 ], "mapped", [ 11350 ] ], [ [ 11303, 11303 ], "mapped", [ 11351 ] ], [ [ 11304, 11304 ], "mapped", [ 11352 ] ], [ [ 11305, 11305 ], "mapped", [ 11353 ] ], [ [ 11306, 11306 ], "mapped", [ 11354 ] ], [ [ 11307, 11307 ], "mapped", [ 11355 ] ], [ [ 11308, 11308 ], "mapped", [ 11356 ] ], [ [ 11309, 11309 ], "mapped", [ 11357 ] ], [ [ 11310, 11310 ], "mapped", [ 11358 ] ], [ [ 11311, 11311 ], "disallowed" ], [ [ 11312, 11358 ], "valid" ], [ [ 11359, 11359 ], "disallowed" ], [ [ 11360, 11360 ], "mapped", [ 11361 ] ], [ [ 11361, 11361 ], "valid" ], [ [ 11362, 11362 ], "mapped", [ 619 ] ], [ [ 11363, 11363 ], "mapped", [ 7549 ] ], [ [ 11364, 11364 ], "mapped", [ 637 ] ], [ [ 11365, 11366 ], "valid" ], [ [ 11367, 11367 ], "mapped", [ 11368 ] ], [ [ 11368, 11368 ], "valid" ], [ [ 11369, 11369 ], "mapped", [ 11370 ] ], [ [ 11370, 11370 ], "valid" ], [ [ 11371, 11371 ], "mapped", [ 11372 ] ], [ [ 11372, 11372 ], "valid" ], [ [ 11373, 11373 ], "mapped", [ 593 ] ], [ [ 11374, 11374 ], "mapped", [ 625 ] ], [ [ 11375, 11375 ], "mapped", [ 592 ] ], [ [ 11376, 11376 ], "mapped", [ 594 ] ], [ [ 11377, 11377 ], "valid" ], [ [ 11378, 11378 ], "mapped", [ 11379 ] ], [ [ 11379, 11379 ], "valid" ], [ [ 11380, 11380 ], "valid" ], [ [ 11381, 11381 ], "mapped", [ 11382 ] ], [ [ 11382, 11383 ], "valid" ], [ [ 11384, 11387 ], "valid" ], [ [ 11388, 11388 ], "mapped", [ 106 ] ], [ [ 11389, 11389 ], "mapped", [ 118 ] ], [ [ 11390, 11390 ], "mapped", [ 575 ] ], [ [ 11391, 11391 ], "mapped", [ 576 ] ], [ [ 11392, 11392 ], "mapped", [ 11393 ] ], [ [ 11393, 11393 ], "valid" ], [ [ 11394, 11394 ], "mapped", [ 11395 ] ], [ [ 11395, 11395 ], "valid" ], [ [ 11396, 11396 ], "mapped", [ 11397 ] ], [ [ 11397, 11397 ], "valid" ], [ [ 11398, 11398 ], "mapped", [ 11399 ] ], [ [ 11399, 11399 ], "valid" ], [ [ 11400, 11400 ], "mapped", [ 11401 ] ], [ [ 11401, 11401 ], "valid" ], [ [ 11402, 11402 ], "mapped", [ 11403 ] ], [ [ 11403, 11403 ], "valid" ], [ [ 11404, 11404 ], "mapped", [ 11405 ] ], [ [ 11405, 11405 ], "valid" ], [ [ 11406, 11406 ], "mapped", [ 11407 ] ], [ [ 11407, 11407 ], "valid" ], [ [ 11408, 11408 ], "mapped", [ 11409 ] ], [ [ 11409, 11409 ], "valid" ], [ [ 11410, 11410 ], "mapped", [ 11411 ] ], [ [ 11411, 11411 ], "valid" ], [ [ 11412, 11412 ], "mapped", [ 11413 ] ], [ [ 11413, 11413 ], "valid" ], [ [ 11414, 11414 ], "mapped", [ 11415 ] ], [ [ 11415, 11415 ], "valid" ], [ [ 11416, 11416 ], "mapped", [ 11417 ] ], [ [ 11417, 11417 ], "valid" ], [ [ 11418, 11418 ], "mapped", [ 11419 ] ], [ [ 11419, 11419 ], "valid" ], [ [ 11420, 11420 ], "mapped", [ 11421 ] ], [ [ 11421, 11421 ], "valid" ], [ [ 11422, 11422 ], "mapped", [ 11423 ] ], [ [ 11423, 11423 ], "valid" ], [ [ 11424, 11424 ], "mapped", [ 11425 ] ], [ [ 11425, 11425 ], "valid" ], [ [ 11426, 11426 ], "mapped", [ 11427 ] ], [ [ 11427, 11427 ], "valid" ], [ [ 11428, 11428 ], "mapped", [ 11429 ] ], [ [ 11429, 11429 ], "valid" ], [ [ 11430, 11430 ], "mapped", [ 11431 ] ], [ [ 11431, 11431 ], "valid" ], [ [ 11432, 11432 ], "mapped", [ 11433 ] ], [ [ 11433, 11433 ], "valid" ], [ [ 11434, 11434 ], "mapped", [ 11435 ] ], [ [ 11435, 11435 ], "valid" ], [ [ 11436, 11436 ], "mapped", [ 11437 ] ], [ [ 11437, 11437 ], "valid" ], [ [ 11438, 11438 ], "mapped", [ 11439 ] ], [ [ 11439, 11439 ], "valid" ], [ [ 11440, 11440 ], "mapped", [ 11441 ] ], [ [ 11441, 11441 ], "valid" ], [ [ 11442, 11442 ], "mapped", [ 11443 ] ], [ [ 11443, 11443 ], "valid" ], [ [ 11444, 11444 ], "mapped", [ 11445 ] ], [ [ 11445, 11445 ], "valid" ], [ [ 11446, 11446 ], "mapped", [ 11447 ] ], [ [ 11447, 11447 ], "valid" ], [ [ 11448, 11448 ], "mapped", [ 11449 ] ], [ [ 11449, 11449 ], "valid" ], [ [ 11450, 11450 ], "mapped", [ 11451 ] ], [ [ 11451, 11451 ], "valid" ], [ [ 11452, 11452 ], "mapped", [ 11453 ] ], [ [ 11453, 11453 ], "valid" ], [ [ 11454, 11454 ], "mapped", [ 11455 ] ], [ [ 11455, 11455 ], "valid" ], [ [ 11456, 11456 ], "mapped", [ 11457 ] ], [ [ 11457, 11457 ], "valid" ], [ [ 11458, 11458 ], "mapped", [ 11459 ] ], [ [ 11459, 11459 ], "valid" ], [ [ 11460, 11460 ], "mapped", [ 11461 ] ], [ [ 11461, 11461 ], "valid" ], [ [ 11462, 11462 ], "mapped", [ 11463 ] ], [ [ 11463, 11463 ], "valid" ], [ [ 11464, 11464 ], "mapped", [ 11465 ] ], [ [ 11465, 11465 ], "valid" ], [ [ 11466, 11466 ], "mapped", [ 11467 ] ], [ [ 11467, 11467 ], "valid" ], [ [ 11468, 11468 ], "mapped", [ 11469 ] ], [ [ 11469, 11469 ], "valid" ], [ [ 11470, 11470 ], "mapped", [ 11471 ] ], [ [ 11471, 11471 ], "valid" ], [ [ 11472, 11472 ], "mapped", [ 11473 ] ], [ [ 11473, 11473 ], "valid" ], [ [ 11474, 11474 ], "mapped", [ 11475 ] ], [ [ 11475, 11475 ], "valid" ], [ [ 11476, 11476 ], "mapped", [ 11477 ] ], [ [ 11477, 11477 ], "valid" ], [ [ 11478, 11478 ], "mapped", [ 11479 ] ], [ [ 11479, 11479 ], "valid" ], [ [ 11480, 11480 ], "mapped", [ 11481 ] ], [ [ 11481, 11481 ], "valid" ], [ [ 11482, 11482 ], "mapped", [ 11483 ] ], [ [ 11483, 11483 ], "valid" ], [ [ 11484, 11484 ], "mapped", [ 11485 ] ], [ [ 11485, 11485 ], "valid" ], [ [ 11486, 11486 ], "mapped", [ 11487 ] ], [ [ 11487, 11487 ], "valid" ], [ [ 11488, 11488 ], "mapped", [ 11489 ] ], [ [ 11489, 11489 ], "valid" ], [ [ 11490, 11490 ], "mapped", [ 11491 ] ], [ [ 11491, 11492 ], "valid" ], [ [ 11493, 11498 ], "valid", [], "NV8" ], [ [ 11499, 11499 ], "mapped", [ 11500 ] ], [ [ 11500, 11500 ], "valid" ], [ [ 11501, 11501 ], "mapped", [ 11502 ] ], [ [ 11502, 11505 ], "valid" ], [ [ 11506, 11506 ], "mapped", [ 11507 ] ], [ [ 11507, 11507 ], "valid" ], [ [ 11508, 11512 ], "disallowed" ], [ [ 11513, 11519 ], "valid", [], "NV8" ], [ [ 11520, 11557 ], "valid" ], [ [ 11558, 11558 ], "disallowed" ], [ [ 11559, 11559 ], "valid" ], [ [ 11560, 11564 ], "disallowed" ], [ [ 11565, 11565 ], "valid" ], [ [ 11566, 11567 ], "disallowed" ], [ [ 11568, 11621 ], "valid" ], [ [ 11622, 11623 ], "valid" ], [ [ 11624, 11630 ], "disallowed" ], [ [ 11631, 11631 ], "mapped", [ 11617 ] ], [ [ 11632, 11632 ], "valid", [], "NV8" ], [ [ 11633, 11646 ], "disallowed" ], [ [ 11647, 11647 ], "valid" ], [ [ 11648, 11670 ], "valid" ], [ [ 11671, 11679 ], "disallowed" ], [ [ 11680, 11686 ], "valid" ], [ [ 11687, 11687 ], "disallowed" ], [ [ 11688, 11694 ], "valid" ], [ [ 11695, 11695 ], "disallowed" ], [ [ 11696, 11702 ], "valid" ], [ [ 11703, 11703 ], "disallowed" ], [ [ 11704, 11710 ], "valid" ], [ [ 11711, 11711 ], "disallowed" ], [ [ 11712, 11718 ], "valid" ], [ [ 11719, 11719 ], "disallowed" ], [ [ 11720, 11726 ], "valid" ], [ [ 11727, 11727 ], "disallowed" ], [ [ 11728, 11734 ], "valid" ], [ [ 11735, 11735 ], "disallowed" ], [ [ 11736, 11742 ], "valid" ], [ [ 11743, 11743 ], "disallowed" ], [ [ 11744, 11775 ], "valid" ], [ [ 11776, 11799 ], "valid", [], "NV8" ], [ [ 11800, 11803 ], "valid", [], "NV8" ], [ [ 11804, 11805 ], "valid", [], "NV8" ], [ [ 11806, 11822 ], "valid", [], "NV8" ], [ [ 11823, 11823 ], "valid" ], [ [ 11824, 11824 ], "valid", [], "NV8" ], [ [ 11825, 11825 ], "valid", [], "NV8" ], [ [ 11826, 11835 ], "valid", [], "NV8" ], [ [ 11836, 11842 ], "valid", [], "NV8" ], [ [ 11843, 11903 ], "disallowed" ], [ [ 11904, 11929 ], "valid", [], "NV8" ], [ [ 11930, 11930 ], "disallowed" ], [ [ 11931, 11934 ], "valid", [], "NV8" ], [ [ 11935, 11935 ], "mapped", [ 27597 ] ], [ [ 11936, 12018 ], "valid", [], "NV8" ], [ [ 12019, 12019 ], "mapped", [ 40863 ] ], [ [ 12020, 12031 ], "disallowed" ], [ [ 12032, 12032 ], "mapped", [ 19968 ] ], [ [ 12033, 12033 ], "mapped", [ 20008 ] ], [ [ 12034, 12034 ], "mapped", [ 20022 ] ], [ [ 12035, 12035 ], "mapped", [ 20031 ] ], [ [ 12036, 12036 ], "mapped", [ 20057 ] ], [ [ 12037, 12037 ], "mapped", [ 20101 ] ], [ [ 12038, 12038 ], "mapped", [ 20108 ] ], [ [ 12039, 12039 ], "mapped", [ 20128 ] ], [ [ 12040, 12040 ], "mapped", [ 20154 ] ], [ [ 12041, 12041 ], "mapped", [ 20799 ] ], [ [ 12042, 12042 ], "mapped", [ 20837 ] ], [ [ 12043, 12043 ], "mapped", [ 20843 ] ], [ [ 12044, 12044 ], "mapped", [ 20866 ] ], [ [ 12045, 12045 ], "mapped", [ 20886 ] ], [ [ 12046, 12046 ], "mapped", [ 20907 ] ], [ [ 12047, 12047 ], "mapped", [ 20960 ] ], [ [ 12048, 12048 ], "mapped", [ 20981 ] ], [ [ 12049, 12049 ], "mapped", [ 20992 ] ], [ [ 12050, 12050 ], "mapped", [ 21147 ] ], [ [ 12051, 12051 ], "mapped", [ 21241 ] ], [ [ 12052, 12052 ], "mapped", [ 21269 ] ], [ [ 12053, 12053 ], "mapped", [ 21274 ] ], [ [ 12054, 12054 ], "mapped", [ 21304 ] ], [ [ 12055, 12055 ], "mapped", [ 21313 ] ], [ [ 12056, 12056 ], "mapped", [ 21340 ] ], [ [ 12057, 12057 ], "mapped", [ 21353 ] ], [ [ 12058, 12058 ], "mapped", [ 21378 ] ], [ [ 12059, 12059 ], "mapped", [ 21430 ] ], [ [ 12060, 12060 ], "mapped", [ 21448 ] ], [ [ 12061, 12061 ], "mapped", [ 21475 ] ], [ [ 12062, 12062 ], "mapped", [ 22231 ] ], [ [ 12063, 12063 ], "mapped", [ 22303 ] ], [ [ 12064, 12064 ], "mapped", [ 22763 ] ], [ [ 12065, 12065 ], "mapped", [ 22786 ] ], [ [ 12066, 12066 ], "mapped", [ 22794 ] ], [ [ 12067, 12067 ], "mapped", [ 22805 ] ], [ [ 12068, 12068 ], "mapped", [ 22823 ] ], [ [ 12069, 12069 ], "mapped", [ 22899 ] ], [ [ 12070, 12070 ], "mapped", [ 23376 ] ], [ [ 12071, 12071 ], "mapped", [ 23424 ] ], [ [ 12072, 12072 ], "mapped", [ 23544 ] ], [ [ 12073, 12073 ], "mapped", [ 23567 ] ], [ [ 12074, 12074 ], "mapped", [ 23586 ] ], [ [ 12075, 12075 ], "mapped", [ 23608 ] ], [ [ 12076, 12076 ], "mapped", [ 23662 ] ], [ [ 12077, 12077 ], "mapped", [ 23665 ] ], [ [ 12078, 12078 ], "mapped", [ 24027 ] ], [ [ 12079, 12079 ], "mapped", [ 24037 ] ], [ [ 12080, 12080 ], "mapped", [ 24049 ] ], [ [ 12081, 12081 ], "mapped", [ 24062 ] ], [ [ 12082, 12082 ], "mapped", [ 24178 ] ], [ [ 12083, 12083 ], "mapped", [ 24186 ] ], [ [ 12084, 12084 ], "mapped", [ 24191 ] ], [ [ 12085, 12085 ], "mapped", [ 24308 ] ], [ [ 12086, 12086 ], "mapped", [ 24318 ] ], [ [ 12087, 12087 ], "mapped", [ 24331 ] ], [ [ 12088, 12088 ], "mapped", [ 24339 ] ], [ [ 12089, 12089 ], "mapped", [ 24400 ] ], [ [ 12090, 12090 ], "mapped", [ 24417 ] ], [ [ 12091, 12091 ], "mapped", [ 24435 ] ], [ [ 12092, 12092 ], "mapped", [ 24515 ] ], [ [ 12093, 12093 ], "mapped", [ 25096 ] ], [ [ 12094, 12094 ], "mapped", [ 25142 ] ], [ [ 12095, 12095 ], "mapped", [ 25163 ] ], [ [ 12096, 12096 ], "mapped", [ 25903 ] ], [ [ 12097, 12097 ], "mapped", [ 25908 ] ], [ [ 12098, 12098 ], "mapped", [ 25991 ] ], [ [ 12099, 12099 ], "mapped", [ 26007 ] ], [ [ 12100, 12100 ], "mapped", [ 26020 ] ], [ [ 12101, 12101 ], "mapped", [ 26041 ] ], [ [ 12102, 12102 ], "mapped", [ 26080 ] ], [ [ 12103, 12103 ], "mapped", [ 26085 ] ], [ [ 12104, 12104 ], "mapped", [ 26352 ] ], [ [ 12105, 12105 ], "mapped", [ 26376 ] ], [ [ 12106, 12106 ], "mapped", [ 26408 ] ], [ [ 12107, 12107 ], "mapped", [ 27424 ] ], [ [ 12108, 12108 ], "mapped", [ 27490 ] ], [ [ 12109, 12109 ], "mapped", [ 27513 ] ], [ [ 12110, 12110 ], "mapped", [ 27571 ] ], [ [ 12111, 12111 ], "mapped", [ 27595 ] ], [ [ 12112, 12112 ], "mapped", [ 27604 ] ], [ [ 12113, 12113 ], "mapped", [ 27611 ] ], [ [ 12114, 12114 ], "mapped", [ 27663 ] ], [ [ 12115, 12115 ], "mapped", [ 27668 ] ], [ [ 12116, 12116 ], "mapped", [ 27700 ] ], [ [ 12117, 12117 ], "mapped", [ 28779 ] ], [ [ 12118, 12118 ], "mapped", [ 29226 ] ], [ [ 12119, 12119 ], "mapped", [ 29238 ] ], [ [ 12120, 12120 ], "mapped", [ 29243 ] ], [ [ 12121, 12121 ], "mapped", [ 29247 ] ], [ [ 12122, 12122 ], "mapped", [ 29255 ] ], [ [ 12123, 12123 ], "mapped", [ 29273 ] ], [ [ 12124, 12124 ], "mapped", [ 29275 ] ], [ [ 12125, 12125 ], "mapped", [ 29356 ] ], [ [ 12126, 12126 ], "mapped", [ 29572 ] ], [ [ 12127, 12127 ], "mapped", [ 29577 ] ], [ [ 12128, 12128 ], "mapped", [ 29916 ] ], [ [ 12129, 12129 ], "mapped", [ 29926 ] ], [ [ 12130, 12130 ], "mapped", [ 29976 ] ], [ [ 12131, 12131 ], "mapped", [ 29983 ] ], [ [ 12132, 12132 ], "mapped", [ 29992 ] ], [ [ 12133, 12133 ], "mapped", [ 3e4 ] ], [ [ 12134, 12134 ], "mapped", [ 30091 ] ], [ [ 12135, 12135 ], "mapped", [ 30098 ] ], [ [ 12136, 12136 ], "mapped", [ 30326 ] ], [ [ 12137, 12137 ], "mapped", [ 30333 ] ], [ [ 12138, 12138 ], "mapped", [ 30382 ] ], [ [ 12139, 12139 ], "mapped", [ 30399 ] ], [ [ 12140, 12140 ], "mapped", [ 30446 ] ], [ [ 12141, 12141 ], "mapped", [ 30683 ] ], [ [ 12142, 12142 ], "mapped", [ 30690 ] ], [ [ 12143, 12143 ], "mapped", [ 30707 ] ], [ [ 12144, 12144 ], "mapped", [ 31034 ] ], [ [ 12145, 12145 ], "mapped", [ 31160 ] ], [ [ 12146, 12146 ], "mapped", [ 31166 ] ], [ [ 12147, 12147 ], "mapped", [ 31348 ] ], [ [ 12148, 12148 ], "mapped", [ 31435 ] ], [ [ 12149, 12149 ], "mapped", [ 31481 ] ], [ [ 12150, 12150 ], "mapped", [ 31859 ] ], [ [ 12151, 12151 ], "mapped", [ 31992 ] ], [ [ 12152, 12152 ], "mapped", [ 32566 ] ], [ [ 12153, 12153 ], "mapped", [ 32593 ] ], [ [ 12154, 12154 ], "mapped", [ 32650 ] ], [ [ 12155, 12155 ], "mapped", [ 32701 ] ], [ [ 12156, 12156 ], "mapped", [ 32769 ] ], [ [ 12157, 12157 ], "mapped", [ 32780 ] ], [ [ 12158, 12158 ], "mapped", [ 32786 ] ], [ [ 12159, 12159 ], "mapped", [ 32819 ] ], [ [ 12160, 12160 ], "mapped", [ 32895 ] ], [ [ 12161, 12161 ], "mapped", [ 32905 ] ], [ [ 12162, 12162 ], "mapped", [ 33251 ] ], [ [ 12163, 12163 ], "mapped", [ 33258 ] ], [ [ 12164, 12164 ], "mapped", [ 33267 ] ], [ [ 12165, 12165 ], "mapped", [ 33276 ] ], [ [ 12166, 12166 ], "mapped", [ 33292 ] ], [ [ 12167, 12167 ], "mapped", [ 33307 ] ], [ [ 12168, 12168 ], "mapped", [ 33311 ] ], [ [ 12169, 12169 ], "mapped", [ 33390 ] ], [ [ 12170, 12170 ], "mapped", [ 33394 ] ], [ [ 12171, 12171 ], "mapped", [ 33400 ] ], [ [ 12172, 12172 ], "mapped", [ 34381 ] ], [ [ 12173, 12173 ], "mapped", [ 34411 ] ], [ [ 12174, 12174 ], "mapped", [ 34880 ] ], [ [ 12175, 12175 ], "mapped", [ 34892 ] ], [ [ 12176, 12176 ], "mapped", [ 34915 ] ], [ [ 12177, 12177 ], "mapped", [ 35198 ] ], [ [ 12178, 12178 ], "mapped", [ 35211 ] ], [ [ 12179, 12179 ], "mapped", [ 35282 ] ], [ [ 12180, 12180 ], "mapped", [ 35328 ] ], [ [ 12181, 12181 ], "mapped", [ 35895 ] ], [ [ 12182, 12182 ], "mapped", [ 35910 ] ], [ [ 12183, 12183 ], "mapped", [ 35925 ] ], [ [ 12184, 12184 ], "mapped", [ 35960 ] ], [ [ 12185, 12185 ], "mapped", [ 35997 ] ], [ [ 12186, 12186 ], "mapped", [ 36196 ] ], [ [ 12187, 12187 ], "mapped", [ 36208 ] ], [ [ 12188, 12188 ], "mapped", [ 36275 ] ], [ [ 12189, 12189 ], "mapped", [ 36523 ] ], [ [ 12190, 12190 ], "mapped", [ 36554 ] ], [ [ 12191, 12191 ], "mapped", [ 36763 ] ], [ [ 12192, 12192 ], "mapped", [ 36784 ] ], [ [ 12193, 12193 ], "mapped", [ 36789 ] ], [ [ 12194, 12194 ], "mapped", [ 37009 ] ], [ [ 12195, 12195 ], "mapped", [ 37193 ] ], [ [ 12196, 12196 ], "mapped", [ 37318 ] ], [ [ 12197, 12197 ], "mapped", [ 37324 ] ], [ [ 12198, 12198 ], "mapped", [ 37329 ] ], [ [ 12199, 12199 ], "mapped", [ 38263 ] ], [ [ 12200, 12200 ], "mapped", [ 38272 ] ], [ [ 12201, 12201 ], "mapped", [ 38428 ] ], [ [ 12202, 12202 ], "mapped", [ 38582 ] ], [ [ 12203, 12203 ], "mapped", [ 38585 ] ], [ [ 12204, 12204 ], "mapped", [ 38632 ] ], [ [ 12205, 12205 ], "mapped", [ 38737 ] ], [ [ 12206, 12206 ], "mapped", [ 38750 ] ], [ [ 12207, 12207 ], "mapped", [ 38754 ] ], [ [ 12208, 12208 ], "mapped", [ 38761 ] ], [ [ 12209, 12209 ], "mapped", [ 38859 ] ], [ [ 12210, 12210 ], "mapped", [ 38893 ] ], [ [ 12211, 12211 ], "mapped", [ 38899 ] ], [ [ 12212, 12212 ], "mapped", [ 38913 ] ], [ [ 12213, 12213 ], "mapped", [ 39080 ] ], [ [ 12214, 12214 ], "mapped", [ 39131 ] ], [ [ 12215, 12215 ], "mapped", [ 39135 ] ], [ [ 12216, 12216 ], "mapped", [ 39318 ] ], [ [ 12217, 12217 ], "mapped", [ 39321 ] ], [ [ 12218, 12218 ], "mapped", [ 39340 ] ], [ [ 12219, 12219 ], "mapped", [ 39592 ] ], [ [ 12220, 12220 ], "mapped", [ 39640 ] ], [ [ 12221, 12221 ], "mapped", [ 39647 ] ], [ [ 12222, 12222 ], "mapped", [ 39717 ] ], [ [ 12223, 12223 ], "mapped", [ 39727 ] ], [ [ 12224, 12224 ], "mapped", [ 39730 ] ], [ [ 12225, 12225 ], "mapped", [ 39740 ] ], [ [ 12226, 12226 ], "mapped", [ 39770 ] ], [ [ 12227, 12227 ], "mapped", [ 40165 ] ], [ [ 12228, 12228 ], "mapped", [ 40565 ] ], [ [ 12229, 12229 ], "mapped", [ 40575 ] ], [ [ 12230, 12230 ], "mapped", [ 40613 ] ], [ [ 12231, 12231 ], "mapped", [ 40635 ] ], [ [ 12232, 12232 ], "mapped", [ 40643 ] ], [ [ 12233, 12233 ], "mapped", [ 40653 ] ], [ [ 12234, 12234 ], "mapped", [ 40657 ] ], [ [ 12235, 12235 ], "mapped", [ 40697 ] ], [ [ 12236, 12236 ], "mapped", [ 40701 ] ], [ [ 12237, 12237 ], "mapped", [ 40718 ] ], [ [ 12238, 12238 ], "mapped", [ 40723 ] ], [ [ 12239, 12239 ], "mapped", [ 40736 ] ], [ [ 12240, 12240 ], "mapped", [ 40763 ] ], [ [ 12241, 12241 ], "mapped", [ 40778 ] ], [ [ 12242, 12242 ], "mapped", [ 40786 ] ], [ [ 12243, 12243 ], "mapped", [ 40845 ] ], [ [ 12244, 12244 ], "mapped", [ 40860 ] ], [ [ 12245, 12245 ], "mapped", [ 40864 ] ], [ [ 12246, 12271 ], "disallowed" ], [ [ 12272, 12283 ], "disallowed" ], [ [ 12284, 12287 ], "disallowed" ], [ [ 12288, 12288 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 12289, 12289 ], "valid", [], "NV8" ], [ [ 12290, 12290 ], "mapped", [ 46 ] ], [ [ 12291, 12292 ], "valid", [], "NV8" ], [ [ 12293, 12295 ], "valid" ], [ [ 12296, 12329 ], "valid", [], "NV8" ], [ [ 12330, 12333 ], "valid" ], [ [ 12334, 12341 ], "valid", [], "NV8" ], [ [ 12342, 12342 ], "mapped", [ 12306 ] ], [ [ 12343, 12343 ], "valid", [], "NV8" ], [ [ 12344, 12344 ], "mapped", [ 21313 ] ], [ [ 12345, 12345 ], "mapped", [ 21316 ] ], [ [ 12346, 12346 ], "mapped", [ 21317 ] ], [ [ 12347, 12347 ], "valid", [], "NV8" ], [ [ 12348, 12348 ], "valid" ], [ [ 12349, 12349 ], "valid", [], "NV8" ], [ [ 12350, 12350 ], "valid", [], "NV8" ], [ [ 12351, 12351 ], "valid", [], "NV8" ], [ [ 12352, 12352 ], "disallowed" ], [ [ 12353, 12436 ], "valid" ], [ [ 12437, 12438 ], "valid" ], [ [ 12439, 12440 ], "disallowed" ], [ [ 12441, 12442 ], "valid" ], [ [ 12443, 12443 ], "disallowed_STD3_mapped", [ 32, 12441 ] ], [ [ 12444, 12444 ], "disallowed_STD3_mapped", [ 32, 12442 ] ], [ [ 12445, 12446 ], "valid" ], [ [ 12447, 12447 ], "mapped", [ 12424, 12426 ] ], [ [ 12448, 12448 ], "valid", [], "NV8" ], [ [ 12449, 12542 ], "valid" ], [ [ 12543, 12543 ], "mapped", [ 12467, 12488 ] ], [ [ 12544, 12548 ], "disallowed" ], [ [ 12549, 12588 ], "valid" ], [ [ 12589, 12589 ], "valid" ], [ [ 12590, 12592 ], "disallowed" ], [ [ 12593, 12593 ], "mapped", [ 4352 ] ], [ [ 12594, 12594 ], "mapped", [ 4353 ] ], [ [ 12595, 12595 ], "mapped", [ 4522 ] ], [ [ 12596, 12596 ], "mapped", [ 4354 ] ], [ [ 12597, 12597 ], "mapped", [ 4524 ] ], [ [ 12598, 12598 ], "mapped", [ 4525 ] ], [ [ 12599, 12599 ], "mapped", [ 4355 ] ], [ [ 12600, 12600 ], "mapped", [ 4356 ] ], [ [ 12601, 12601 ], "mapped", [ 4357 ] ], [ [ 12602, 12602 ], "mapped", [ 4528 ] ], [ [ 12603, 12603 ], "mapped", [ 4529 ] ], [ [ 12604, 12604 ], "mapped", [ 4530 ] ], [ [ 12605, 12605 ], "mapped", [ 4531 ] ], [ [ 12606, 12606 ], "mapped", [ 4532 ] ], [ [ 12607, 12607 ], "mapped", [ 4533 ] ], [ [ 12608, 12608 ], "mapped", [ 4378 ] ], [ [ 12609, 12609 ], "mapped", [ 4358 ] ], [ [ 12610, 12610 ], "mapped", [ 4359 ] ], [ [ 12611, 12611 ], "mapped", [ 4360 ] ], [ [ 12612, 12612 ], "mapped", [ 4385 ] ], [ [ 12613, 12613 ], "mapped", [ 4361 ] ], [ [ 12614, 12614 ], "mapped", [ 4362 ] ], [ [ 12615, 12615 ], "mapped", [ 4363 ] ], [ [ 12616, 12616 ], "mapped", [ 4364 ] ], [ [ 12617, 12617 ], "mapped", [ 4365 ] ], [ [ 12618, 12618 ], "mapped", [ 4366 ] ], [ [ 12619, 12619 ], "mapped", [ 4367 ] ], [ [ 12620, 12620 ], "mapped", [ 4368 ] ], [ [ 12621, 12621 ], "mapped", [ 4369 ] ], [ [ 12622, 12622 ], "mapped", [ 4370 ] ], [ [ 12623, 12623 ], "mapped", [ 4449 ] ], [ [ 12624, 12624 ], "mapped", [ 4450 ] ], [ [ 12625, 12625 ], "mapped", [ 4451 ] ], [ [ 12626, 12626 ], "mapped", [ 4452 ] ], [ [ 12627, 12627 ], "mapped", [ 4453 ] ], [ [ 12628, 12628 ], "mapped", [ 4454 ] ], [ [ 12629, 12629 ], "mapped", [ 4455 ] ], [ [ 12630, 12630 ], "mapped", [ 4456 ] ], [ [ 12631, 12631 ], "mapped", [ 4457 ] ], [ [ 12632, 12632 ], "mapped", [ 4458 ] ], [ [ 12633, 12633 ], "mapped", [ 4459 ] ], [ [ 12634, 12634 ], "mapped", [ 4460 ] ], [ [ 12635, 12635 ], "mapped", [ 4461 ] ], [ [ 12636, 12636 ], "mapped", [ 4462 ] ], [ [ 12637, 12637 ], "mapped", [ 4463 ] ], [ [ 12638, 12638 ], "mapped", [ 4464 ] ], [ [ 12639, 12639 ], "mapped", [ 4465 ] ], [ [ 12640, 12640 ], "mapped", [ 4466 ] ], [ [ 12641, 12641 ], "mapped", [ 4467 ] ], [ [ 12642, 12642 ], "mapped", [ 4468 ] ], [ [ 12643, 12643 ], "mapped", [ 4469 ] ], [ [ 12644, 12644 ], "disallowed" ], [ [ 12645, 12645 ], "mapped", [ 4372 ] ], [ [ 12646, 12646 ], "mapped", [ 4373 ] ], [ [ 12647, 12647 ], "mapped", [ 4551 ] ], [ [ 12648, 12648 ], "mapped", [ 4552 ] ], [ [ 12649, 12649 ], "mapped", [ 4556 ] ], [ [ 12650, 12650 ], "mapped", [ 4558 ] ], [ [ 12651, 12651 ], "mapped", [ 4563 ] ], [ [ 12652, 12652 ], "mapped", [ 4567 ] ], [ [ 12653, 12653 ], "mapped", [ 4569 ] ], [ [ 12654, 12654 ], "mapped", [ 4380 ] ], [ [ 12655, 12655 ], "mapped", [ 4573 ] ], [ [ 12656, 12656 ], "mapped", [ 4575 ] ], [ [ 12657, 12657 ], "mapped", [ 4381 ] ], [ [ 12658, 12658 ], "mapped", [ 4382 ] ], [ [ 12659, 12659 ], "mapped", [ 4384 ] ], [ [ 12660, 12660 ], "mapped", [ 4386 ] ], [ [ 12661, 12661 ], "mapped", [ 4387 ] ], [ [ 12662, 12662 ], "mapped", [ 4391 ] ], [ [ 12663, 12663 ], "mapped", [ 4393 ] ], [ [ 12664, 12664 ], "mapped", [ 4395 ] ], [ [ 12665, 12665 ], "mapped", [ 4396 ] ], [ [ 12666, 12666 ], "mapped", [ 4397 ] ], [ [ 12667, 12667 ], "mapped", [ 4398 ] ], [ [ 12668, 12668 ], "mapped", [ 4399 ] ], [ [ 12669, 12669 ], "mapped", [ 4402 ] ], [ [ 12670, 12670 ], "mapped", [ 4406 ] ], [ [ 12671, 12671 ], "mapped", [ 4416 ] ], [ [ 12672, 12672 ], "mapped", [ 4423 ] ], [ [ 12673, 12673 ], "mapped", [ 4428 ] ], [ [ 12674, 12674 ], "mapped", [ 4593 ] ], [ [ 12675, 12675 ], "mapped", [ 4594 ] ], [ [ 12676, 12676 ], "mapped", [ 4439 ] ], [ [ 12677, 12677 ], "mapped", [ 4440 ] ], [ [ 12678, 12678 ], "mapped", [ 4441 ] ], [ [ 12679, 12679 ], "mapped", [ 4484 ] ], [ [ 12680, 12680 ], "mapped", [ 4485 ] ], [ [ 12681, 12681 ], "mapped", [ 4488 ] ], [ [ 12682, 12682 ], "mapped", [ 4497 ] ], [ [ 12683, 12683 ], "mapped", [ 4498 ] ], [ [ 12684, 12684 ], "mapped", [ 4500 ] ], [ [ 12685, 12685 ], "mapped", [ 4510 ] ], [ [ 12686, 12686 ], "mapped", [ 4513 ] ], [ [ 12687, 12687 ], "disallowed" ], [ [ 12688, 12689 ], "valid", [], "NV8" ], [ [ 12690, 12690 ], "mapped", [ 19968 ] ], [ [ 12691, 12691 ], "mapped", [ 20108 ] ], [ [ 12692, 12692 ], "mapped", [ 19977 ] ], [ [ 12693, 12693 ], "mapped", [ 22235 ] ], [ [ 12694, 12694 ], "mapped", [ 19978 ] ], [ [ 12695, 12695 ], "mapped", [ 20013 ] ], [ [ 12696, 12696 ], "mapped", [ 19979 ] ], [ [ 12697, 12697 ], "mapped", [ 30002 ] ], [ [ 12698, 12698 ], "mapped", [ 20057 ] ], [ [ 12699, 12699 ], "mapped", [ 19993 ] ], [ [ 12700, 12700 ], "mapped", [ 19969 ] ], [ [ 12701, 12701 ], "mapped", [ 22825 ] ], [ [ 12702, 12702 ], "mapped", [ 22320 ] ], [ [ 12703, 12703 ], "mapped", [ 20154 ] ], [ [ 12704, 12727 ], "valid" ], [ [ 12728, 12730 ], "valid" ], [ [ 12731, 12735 ], "disallowed" ], [ [ 12736, 12751 ], "valid", [], "NV8" ], [ [ 12752, 12771 ], "valid", [], "NV8" ], [ [ 12772, 12783 ], "disallowed" ], [ [ 12784, 12799 ], "valid" ], [ [ 12800, 12800 ], "disallowed_STD3_mapped", [ 40, 4352, 41 ] ], [ [ 12801, 12801 ], "disallowed_STD3_mapped", [ 40, 4354, 41 ] ], [ [ 12802, 12802 ], "disallowed_STD3_mapped", [ 40, 4355, 41 ] ], [ [ 12803, 12803 ], "disallowed_STD3_mapped", [ 40, 4357, 41 ] ], [ [ 12804, 12804 ], "disallowed_STD3_mapped", [ 40, 4358, 41 ] ], [ [ 12805, 12805 ], "disallowed_STD3_mapped", [ 40, 4359, 41 ] ], [ [ 12806, 12806 ], "disallowed_STD3_mapped", [ 40, 4361, 41 ] ], [ [ 12807, 12807 ], "disallowed_STD3_mapped", [ 40, 4363, 41 ] ], [ [ 12808, 12808 ], "disallowed_STD3_mapped", [ 40, 4364, 41 ] ], [ [ 12809, 12809 ], "disallowed_STD3_mapped", [ 40, 4366, 41 ] ], [ [ 12810, 12810 ], "disallowed_STD3_mapped", [ 40, 4367, 41 ] ], [ [ 12811, 12811 ], "disallowed_STD3_mapped", [ 40, 4368, 41 ] ], [ [ 12812, 12812 ], "disallowed_STD3_mapped", [ 40, 4369, 41 ] ], [ [ 12813, 12813 ], "disallowed_STD3_mapped", [ 40, 4370, 41 ] ], [ [ 12814, 12814 ], "disallowed_STD3_mapped", [ 40, 44032, 41 ] ], [ [ 12815, 12815 ], "disallowed_STD3_mapped", [ 40, 45208, 41 ] ], [ [ 12816, 12816 ], "disallowed_STD3_mapped", [ 40, 45796, 41 ] ], [ [ 12817, 12817 ], "disallowed_STD3_mapped", [ 40, 46972, 41 ] ], [ [ 12818, 12818 ], "disallowed_STD3_mapped", [ 40, 47560, 41 ] ], [ [ 12819, 12819 ], "disallowed_STD3_mapped", [ 40, 48148, 41 ] ], [ [ 12820, 12820 ], "disallowed_STD3_mapped", [ 40, 49324, 41 ] ], [ [ 12821, 12821 ], "disallowed_STD3_mapped", [ 40, 50500, 41 ] ], [ [ 12822, 12822 ], "disallowed_STD3_mapped", [ 40, 51088, 41 ] ], [ [ 12823, 12823 ], "disallowed_STD3_mapped", [ 40, 52264, 41 ] ], [ [ 12824, 12824 ], "disallowed_STD3_mapped", [ 40, 52852, 41 ] ], [ [ 12825, 12825 ], "disallowed_STD3_mapped", [ 40, 53440, 41 ] ], [ [ 12826, 12826 ], "disallowed_STD3_mapped", [ 40, 54028, 41 ] ], [ [ 12827, 12827 ], "disallowed_STD3_mapped", [ 40, 54616, 41 ] ], [ [ 12828, 12828 ], "disallowed_STD3_mapped", [ 40, 51452, 41 ] ], [ [ 12829, 12829 ], "disallowed_STD3_mapped", [ 40, 50724, 51204, 41 ] ], [ [ 12830, 12830 ], "disallowed_STD3_mapped", [ 40, 50724, 54980, 41 ] ], [ [ 12831, 12831 ], "disallowed" ], [ [ 12832, 12832 ], "disallowed_STD3_mapped", [ 40, 19968, 41 ] ], [ [ 12833, 12833 ], "disallowed_STD3_mapped", [ 40, 20108, 41 ] ], [ [ 12834, 12834 ], "disallowed_STD3_mapped", [ 40, 19977, 41 ] ], [ [ 12835, 12835 ], "disallowed_STD3_mapped", [ 40, 22235, 41 ] ], [ [ 12836, 12836 ], "disallowed_STD3_mapped", [ 40, 20116, 41 ] ], [ [ 12837, 12837 ], "disallowed_STD3_mapped", [ 40, 20845, 41 ] ], [ [ 12838, 12838 ], "disallowed_STD3_mapped", [ 40, 19971, 41 ] ], [ [ 12839, 12839 ], "disallowed_STD3_mapped", [ 40, 20843, 41 ] ], [ [ 12840, 12840 ], "disallowed_STD3_mapped", [ 40, 20061, 41 ] ], [ [ 12841, 12841 ], "disallowed_STD3_mapped", [ 40, 21313, 41 ] ], [ [ 12842, 12842 ], "disallowed_STD3_mapped", [ 40, 26376, 41 ] ], [ [ 12843, 12843 ], "disallowed_STD3_mapped", [ 40, 28779, 41 ] ], [ [ 12844, 12844 ], "disallowed_STD3_mapped", [ 40, 27700, 41 ] ], [ [ 12845, 12845 ], "disallowed_STD3_mapped", [ 40, 26408, 41 ] ], [ [ 12846, 12846 ], "disallowed_STD3_mapped", [ 40, 37329, 41 ] ], [ [ 12847, 12847 ], "disallowed_STD3_mapped", [ 40, 22303, 41 ] ], [ [ 12848, 12848 ], "disallowed_STD3_mapped", [ 40, 26085, 41 ] ], [ [ 12849, 12849 ], "disallowed_STD3_mapped", [ 40, 26666, 41 ] ], [ [ 12850, 12850 ], "disallowed_STD3_mapped", [ 40, 26377, 41 ] ], [ [ 12851, 12851 ], "disallowed_STD3_mapped", [ 40, 31038, 41 ] ], [ [ 12852, 12852 ], "disallowed_STD3_mapped", [ 40, 21517, 41 ] ], [ [ 12853, 12853 ], "disallowed_STD3_mapped", [ 40, 29305, 41 ] ], [ [ 12854, 12854 ], "disallowed_STD3_mapped", [ 40, 36001, 41 ] ], [ [ 12855, 12855 ], "disallowed_STD3_mapped", [ 40, 31069, 41 ] ], [ [ 12856, 12856 ], "disallowed_STD3_mapped", [ 40, 21172, 41 ] ], [ [ 12857, 12857 ], "disallowed_STD3_mapped", [ 40, 20195, 41 ] ], [ [ 12858, 12858 ], "disallowed_STD3_mapped", [ 40, 21628, 41 ] ], [ [ 12859, 12859 ], "disallowed_STD3_mapped", [ 40, 23398, 41 ] ], [ [ 12860, 12860 ], "disallowed_STD3_mapped", [ 40, 30435, 41 ] ], [ [ 12861, 12861 ], "disallowed_STD3_mapped", [ 40, 20225, 41 ] ], [ [ 12862, 12862 ], "disallowed_STD3_mapped", [ 40, 36039, 41 ] ], [ [ 12863, 12863 ], "disallowed_STD3_mapped", [ 40, 21332, 41 ] ], [ [ 12864, 12864 ], "disallowed_STD3_mapped", [ 40, 31085, 41 ] ], [ [ 12865, 12865 ], "disallowed_STD3_mapped", [ 40, 20241, 41 ] ], [ [ 12866, 12866 ], "disallowed_STD3_mapped", [ 40, 33258, 41 ] ], [ [ 12867, 12867 ], "disallowed_STD3_mapped", [ 40, 33267, 41 ] ], [ [ 12868, 12868 ], "mapped", [ 21839 ] ], [ [ 12869, 12869 ], "mapped", [ 24188 ] ], [ [ 12870, 12870 ], "mapped", [ 25991 ] ], [ [ 12871, 12871 ], "mapped", [ 31631 ] ], [ [ 12872, 12879 ], "valid", [], "NV8" ], [ [ 12880, 12880 ], "mapped", [ 112, 116, 101 ] ], [ [ 12881, 12881 ], "mapped", [ 50, 49 ] ], [ [ 12882, 12882 ], "mapped", [ 50, 50 ] ], [ [ 12883, 12883 ], "mapped", [ 50, 51 ] ], [ [ 12884, 12884 ], "mapped", [ 50, 52 ] ], [ [ 12885, 12885 ], "mapped", [ 50, 53 ] ], [ [ 12886, 12886 ], "mapped", [ 50, 54 ] ], [ [ 12887, 12887 ], "mapped", [ 50, 55 ] ], [ [ 12888, 12888 ], "mapped", [ 50, 56 ] ], [ [ 12889, 12889 ], "mapped", [ 50, 57 ] ], [ [ 12890, 12890 ], "mapped", [ 51, 48 ] ], [ [ 12891, 12891 ], "mapped", [ 51, 49 ] ], [ [ 12892, 12892 ], "mapped", [ 51, 50 ] ], [ [ 12893, 12893 ], "mapped", [ 51, 51 ] ], [ [ 12894, 12894 ], "mapped", [ 51, 52 ] ], [ [ 12895, 12895 ], "mapped", [ 51, 53 ] ], [ [ 12896, 12896 ], "mapped", [ 4352 ] ], [ [ 12897, 12897 ], "mapped", [ 4354 ] ], [ [ 12898, 12898 ], "mapped", [ 4355 ] ], [ [ 12899, 12899 ], "mapped", [ 4357 ] ], [ [ 12900, 12900 ], "mapped", [ 4358 ] ], [ [ 12901, 12901 ], "mapped", [ 4359 ] ], [ [ 12902, 12902 ], "mapped", [ 4361 ] ], [ [ 12903, 12903 ], "mapped", [ 4363 ] ], [ [ 12904, 12904 ], "mapped", [ 4364 ] ], [ [ 12905, 12905 ], "mapped", [ 4366 ] ], [ [ 12906, 12906 ], "mapped", [ 4367 ] ], [ [ 12907, 12907 ], "mapped", [ 4368 ] ], [ [ 12908, 12908 ], "mapped", [ 4369 ] ], [ [ 12909, 12909 ], "mapped", [ 4370 ] ], [ [ 12910, 12910 ], "mapped", [ 44032 ] ], [ [ 12911, 12911 ], "mapped", [ 45208 ] ], [ [ 12912, 12912 ], "mapped", [ 45796 ] ], [ [ 12913, 12913 ], "mapped", [ 46972 ] ], [ [ 12914, 12914 ], "mapped", [ 47560 ] ], [ [ 12915, 12915 ], "mapped", [ 48148 ] ], [ [ 12916, 12916 ], "mapped", [ 49324 ] ], [ [ 12917, 12917 ], "mapped", [ 50500 ] ], [ [ 12918, 12918 ], "mapped", [ 51088 ] ], [ [ 12919, 12919 ], "mapped", [ 52264 ] ], [ [ 12920, 12920 ], "mapped", [ 52852 ] ], [ [ 12921, 12921 ], "mapped", [ 53440 ] ], [ [ 12922, 12922 ], "mapped", [ 54028 ] ], [ [ 12923, 12923 ], "mapped", [ 54616 ] ], [ [ 12924, 12924 ], "mapped", [ 52280, 44256 ] ], [ [ 12925, 12925 ], "mapped", [ 51452, 51032 ] ], [ [ 12926, 12926 ], "mapped", [ 50864 ] ], [ [ 12927, 12927 ], "valid", [], "NV8" ], [ [ 12928, 12928 ], "mapped", [ 19968 ] ], [ [ 12929, 12929 ], "mapped", [ 20108 ] ], [ [ 12930, 12930 ], "mapped", [ 19977 ] ], [ [ 12931, 12931 ], "mapped", [ 22235 ] ], [ [ 12932, 12932 ], "mapped", [ 20116 ] ], [ [ 12933, 12933 ], "mapped", [ 20845 ] ], [ [ 12934, 12934 ], "mapped", [ 19971 ] ], [ [ 12935, 12935 ], "mapped", [ 20843 ] ], [ [ 12936, 12936 ], "mapped", [ 20061 ] ], [ [ 12937, 12937 ], "mapped", [ 21313 ] ], [ [ 12938, 12938 ], "mapped", [ 26376 ] ], [ [ 12939, 12939 ], "mapped", [ 28779 ] ], [ [ 12940, 12940 ], "mapped", [ 27700 ] ], [ [ 12941, 12941 ], "mapped", [ 26408 ] ], [ [ 12942, 12942 ], "mapped", [ 37329 ] ], [ [ 12943, 12943 ], "mapped", [ 22303 ] ], [ [ 12944, 12944 ], "mapped", [ 26085 ] ], [ [ 12945, 12945 ], "mapped", [ 26666 ] ], [ [ 12946, 12946 ], "mapped", [ 26377 ] ], [ [ 12947, 12947 ], "mapped", [ 31038 ] ], [ [ 12948, 12948 ], "mapped", [ 21517 ] ], [ [ 12949, 12949 ], "mapped", [ 29305 ] ], [ [ 12950, 12950 ], "mapped", [ 36001 ] ], [ [ 12951, 12951 ], "mapped", [ 31069 ] ], [ [ 12952, 12952 ], "mapped", [ 21172 ] ], [ [ 12953, 12953 ], "mapped", [ 31192 ] ], [ [ 12954, 12954 ], "mapped", [ 30007 ] ], [ [ 12955, 12955 ], "mapped", [ 22899 ] ], [ [ 12956, 12956 ], "mapped", [ 36969 ] ], [ [ 12957, 12957 ], "mapped", [ 20778 ] ], [ [ 12958, 12958 ], "mapped", [ 21360 ] ], [ [ 12959, 12959 ], "mapped", [ 27880 ] ], [ [ 12960, 12960 ], "mapped", [ 38917 ] ], [ [ 12961, 12961 ], "mapped", [ 20241 ] ], [ [ 12962, 12962 ], "mapped", [ 20889 ] ], [ [ 12963, 12963 ], "mapped", [ 27491 ] ], [ [ 12964, 12964 ], "mapped", [ 19978 ] ], [ [ 12965, 12965 ], "mapped", [ 20013 ] ], [ [ 12966, 12966 ], "mapped", [ 19979 ] ], [ [ 12967, 12967 ], "mapped", [ 24038 ] ], [ [ 12968, 12968 ], "mapped", [ 21491 ] ], [ [ 12969, 12969 ], "mapped", [ 21307 ] ], [ [ 12970, 12970 ], "mapped", [ 23447 ] ], [ [ 12971, 12971 ], "mapped", [ 23398 ] ], [ [ 12972, 12972 ], "mapped", [ 30435 ] ], [ [ 12973, 12973 ], "mapped", [ 20225 ] ], [ [ 12974, 12974 ], "mapped", [ 36039 ] ], [ [ 12975, 12975 ], "mapped", [ 21332 ] ], [ [ 12976, 12976 ], "mapped", [ 22812 ] ], [ [ 12977, 12977 ], "mapped", [ 51, 54 ] ], [ [ 12978, 12978 ], "mapped", [ 51, 55 ] ], [ [ 12979, 12979 ], "mapped", [ 51, 56 ] ], [ [ 12980, 12980 ], "mapped", [ 51, 57 ] ], [ [ 12981, 12981 ], "mapped", [ 52, 48 ] ], [ [ 12982, 12982 ], "mapped", [ 52, 49 ] ], [ [ 12983, 12983 ], "mapped", [ 52, 50 ] ], [ [ 12984, 12984 ], "mapped", [ 52, 51 ] ], [ [ 12985, 12985 ], "mapped", [ 52, 52 ] ], [ [ 12986, 12986 ], "mapped", [ 52, 53 ] ], [ [ 12987, 12987 ], "mapped", [ 52, 54 ] ], [ [ 12988, 12988 ], "mapped", [ 52, 55 ] ], [ [ 12989, 12989 ], "mapped", [ 52, 56 ] ], [ [ 12990, 12990 ], "mapped", [ 52, 57 ] ], [ [ 12991, 12991 ], "mapped", [ 53, 48 ] ], [ [ 12992, 12992 ], "mapped", [ 49, 26376 ] ], [ [ 12993, 12993 ], "mapped", [ 50, 26376 ] ], [ [ 12994, 12994 ], "mapped", [ 51, 26376 ] ], [ [ 12995, 12995 ], "mapped", [ 52, 26376 ] ], [ [ 12996, 12996 ], "mapped", [ 53, 26376 ] ], [ [ 12997, 12997 ], "mapped", [ 54, 26376 ] ], [ [ 12998, 12998 ], "mapped", [ 55, 26376 ] ], [ [ 12999, 12999 ], "mapped", [ 56, 26376 ] ], [ [ 13e3, 13e3 ], "mapped", [ 57, 26376 ] ], [ [ 13001, 13001 ], "mapped", [ 49, 48, 26376 ] ], [ [ 13002, 13002 ], "mapped", [ 49, 49, 26376 ] ], [ [ 13003, 13003 ], "mapped", [ 49, 50, 26376 ] ], [ [ 13004, 13004 ], "mapped", [ 104, 103 ] ], [ [ 13005, 13005 ], "mapped", [ 101, 114, 103 ] ], [ [ 13006, 13006 ], "mapped", [ 101, 118 ] ], [ [ 13007, 13007 ], "mapped", [ 108, 116, 100 ] ], [ [ 13008, 13008 ], "mapped", [ 12450 ] ], [ [ 13009, 13009 ], "mapped", [ 12452 ] ], [ [ 13010, 13010 ], "mapped", [ 12454 ] ], [ [ 13011, 13011 ], "mapped", [ 12456 ] ], [ [ 13012, 13012 ], "mapped", [ 12458 ] ], [ [ 13013, 13013 ], "mapped", [ 12459 ] ], [ [ 13014, 13014 ], "mapped", [ 12461 ] ], [ [ 13015, 13015 ], "mapped", [ 12463 ] ], [ [ 13016, 13016 ], "mapped", [ 12465 ] ], [ [ 13017, 13017 ], "mapped", [ 12467 ] ], [ [ 13018, 13018 ], "mapped", [ 12469 ] ], [ [ 13019, 13019 ], "mapped", [ 12471 ] ], [ [ 13020, 13020 ], "mapped", [ 12473 ] ], [ [ 13021, 13021 ], "mapped", [ 12475 ] ], [ [ 13022, 13022 ], "mapped", [ 12477 ] ], [ [ 13023, 13023 ], "mapped", [ 12479 ] ], [ [ 13024, 13024 ], "mapped", [ 12481 ] ], [ [ 13025, 13025 ], "mapped", [ 12484 ] ], [ [ 13026, 13026 ], "mapped", [ 12486 ] ], [ [ 13027, 13027 ], "mapped", [ 12488 ] ], [ [ 13028, 13028 ], "mapped", [ 12490 ] ], [ [ 13029, 13029 ], "mapped", [ 12491 ] ], [ [ 13030, 13030 ], "mapped", [ 12492 ] ], [ [ 13031, 13031 ], "mapped", [ 12493 ] ], [ [ 13032, 13032 ], "mapped", [ 12494 ] ], [ [ 13033, 13033 ], "mapped", [ 12495 ] ], [ [ 13034, 13034 ], "mapped", [ 12498 ] ], [ [ 13035, 13035 ], "mapped", [ 12501 ] ], [ [ 13036, 13036 ], "mapped", [ 12504 ] ], [ [ 13037, 13037 ], "mapped", [ 12507 ] ], [ [ 13038, 13038 ], "mapped", [ 12510 ] ], [ [ 13039, 13039 ], "mapped", [ 12511 ] ], [ [ 13040, 13040 ], "mapped", [ 12512 ] ], [ [ 13041, 13041 ], "mapped", [ 12513 ] ], [ [ 13042, 13042 ], "mapped", [ 12514 ] ], [ [ 13043, 13043 ], "mapped", [ 12516 ] ], [ [ 13044, 13044 ], "mapped", [ 12518 ] ], [ [ 13045, 13045 ], "mapped", [ 12520 ] ], [ [ 13046, 13046 ], "mapped", [ 12521 ] ], [ [ 13047, 13047 ], "mapped", [ 12522 ] ], [ [ 13048, 13048 ], "mapped", [ 12523 ] ], [ [ 13049, 13049 ], "mapped", [ 12524 ] ], [ [ 13050, 13050 ], "mapped", [ 12525 ] ], [ [ 13051, 13051 ], "mapped", [ 12527 ] ], [ [ 13052, 13052 ], "mapped", [ 12528 ] ], [ [ 13053, 13053 ], "mapped", [ 12529 ] ], [ [ 13054, 13054 ], "mapped", [ 12530 ] ], [ [ 13055, 13055 ], "disallowed" ], [ [ 13056, 13056 ], "mapped", [ 12450, 12497, 12540, 12488 ] ], [ [ 13057, 13057 ], "mapped", [ 12450, 12523, 12501, 12449 ] ], [ [ 13058, 13058 ], "mapped", [ 12450, 12531, 12506, 12450 ] ], [ [ 13059, 13059 ], "mapped", [ 12450, 12540, 12523 ] ], [ [ 13060, 13060 ], "mapped", [ 12452, 12491, 12531, 12464 ] ], [ [ 13061, 13061 ], "mapped", [ 12452, 12531, 12481 ] ], [ [ 13062, 13062 ], "mapped", [ 12454, 12457, 12531 ] ], [ [ 13063, 13063 ], "mapped", [ 12456, 12473, 12463, 12540, 12489 ] ], [ [ 13064, 13064 ], "mapped", [ 12456, 12540, 12459, 12540 ] ], [ [ 13065, 13065 ], "mapped", [ 12458, 12531, 12473 ] ], [ [ 13066, 13066 ], "mapped", [ 12458, 12540, 12512 ] ], [ [ 13067, 13067 ], "mapped", [ 12459, 12452, 12522 ] ], [ [ 13068, 13068 ], "mapped", [ 12459, 12521, 12483, 12488 ] ], [ [ 13069, 13069 ], "mapped", [ 12459, 12525, 12522, 12540 ] ], [ [ 13070, 13070 ], "mapped", [ 12460, 12525, 12531 ] ], [ [ 13071, 13071 ], "mapped", [ 12460, 12531, 12510 ] ], [ [ 13072, 13072 ], "mapped", [ 12462, 12460 ] ], [ [ 13073, 13073 ], "mapped", [ 12462, 12491, 12540 ] ], [ [ 13074, 13074 ], "mapped", [ 12461, 12517, 12522, 12540 ] ], [ [ 13075, 13075 ], "mapped", [ 12462, 12523, 12480, 12540 ] ], [ [ 13076, 13076 ], "mapped", [ 12461, 12525 ] ], [ [ 13077, 13077 ], "mapped", [ 12461, 12525, 12464, 12521, 12512 ] ], [ [ 13078, 13078 ], "mapped", [ 12461, 12525, 12513, 12540, 12488, 12523 ] ], [ [ 13079, 13079 ], "mapped", [ 12461, 12525, 12527, 12483, 12488 ] ], [ [ 13080, 13080 ], "mapped", [ 12464, 12521, 12512 ] ], [ [ 13081, 13081 ], "mapped", [ 12464, 12521, 12512, 12488, 12531 ] ], [ [ 13082, 13082 ], "mapped", [ 12463, 12523, 12476, 12452, 12525 ] ], [ [ 13083, 13083 ], "mapped", [ 12463, 12525, 12540, 12493 ] ], [ [ 13084, 13084 ], "mapped", [ 12465, 12540, 12473 ] ], [ [ 13085, 13085 ], "mapped", [ 12467, 12523, 12490 ] ], [ [ 13086, 13086 ], "mapped", [ 12467, 12540, 12509 ] ], [ [ 13087, 13087 ], "mapped", [ 12469, 12452, 12463, 12523 ] ], [ [ 13088, 13088 ], "mapped", [ 12469, 12531, 12481, 12540, 12512 ] ], [ [ 13089, 13089 ], "mapped", [ 12471, 12522, 12531, 12464 ] ], [ [ 13090, 13090 ], "mapped", [ 12475, 12531, 12481 ] ], [ [ 13091, 13091 ], "mapped", [ 12475, 12531, 12488 ] ], [ [ 13092, 13092 ], "mapped", [ 12480, 12540, 12473 ] ], [ [ 13093, 13093 ], "mapped", [ 12487, 12471 ] ], [ [ 13094, 13094 ], "mapped", [ 12489, 12523 ] ], [ [ 13095, 13095 ], "mapped", [ 12488, 12531 ] ], [ [ 13096, 13096 ], "mapped", [ 12490, 12494 ] ], [ [ 13097, 13097 ], "mapped", [ 12494, 12483, 12488 ] ], [ [ 13098, 13098 ], "mapped", [ 12495, 12452, 12484 ] ], [ [ 13099, 13099 ], "mapped", [ 12497, 12540, 12475, 12531, 12488 ] ], [ [ 13100, 13100 ], "mapped", [ 12497, 12540, 12484 ] ], [ [ 13101, 13101 ], "mapped", [ 12496, 12540, 12524, 12523 ] ], [ [ 13102, 13102 ], "mapped", [ 12500, 12450, 12473, 12488, 12523 ] ], [ [ 13103, 13103 ], "mapped", [ 12500, 12463, 12523 ] ], [ [ 13104, 13104 ], "mapped", [ 12500, 12467 ] ], [ [ 13105, 13105 ], "mapped", [ 12499, 12523 ] ], [ [ 13106, 13106 ], "mapped", [ 12501, 12449, 12521, 12483, 12489 ] ], [ [ 13107, 13107 ], "mapped", [ 12501, 12451, 12540, 12488 ] ], [ [ 13108, 13108 ], "mapped", [ 12502, 12483, 12471, 12455, 12523 ] ], [ [ 13109, 13109 ], "mapped", [ 12501, 12521, 12531 ] ], [ [ 13110, 13110 ], "mapped", [ 12504, 12463, 12479, 12540, 12523 ] ], [ [ 13111, 13111 ], "mapped", [ 12506, 12477 ] ], [ [ 13112, 13112 ], "mapped", [ 12506, 12491, 12498 ] ], [ [ 13113, 13113 ], "mapped", [ 12504, 12523, 12484 ] ], [ [ 13114, 13114 ], "mapped", [ 12506, 12531, 12473 ] ], [ [ 13115, 13115 ], "mapped", [ 12506, 12540, 12472 ] ], [ [ 13116, 13116 ], "mapped", [ 12505, 12540, 12479 ] ], [ [ 13117, 13117 ], "mapped", [ 12509, 12452, 12531, 12488 ] ], [ [ 13118, 13118 ], "mapped", [ 12508, 12523, 12488 ] ], [ [ 13119, 13119 ], "mapped", [ 12507, 12531 ] ], [ [ 13120, 13120 ], "mapped", [ 12509, 12531, 12489 ] ], [ [ 13121, 13121 ], "mapped", [ 12507, 12540, 12523 ] ], [ [ 13122, 13122 ], "mapped", [ 12507, 12540, 12531 ] ], [ [ 13123, 13123 ], "mapped", [ 12510, 12452, 12463, 12525 ] ], [ [ 13124, 13124 ], "mapped", [ 12510, 12452, 12523 ] ], [ [ 13125, 13125 ], "mapped", [ 12510, 12483, 12495 ] ], [ [ 13126, 13126 ], "mapped", [ 12510, 12523, 12463 ] ], [ [ 13127, 13127 ], "mapped", [ 12510, 12531, 12471, 12519, 12531 ] ], [ [ 13128, 13128 ], "mapped", [ 12511, 12463, 12525, 12531 ] ], [ [ 13129, 13129 ], "mapped", [ 12511, 12522 ] ], [ [ 13130, 13130 ], "mapped", [ 12511, 12522, 12496, 12540, 12523 ] ], [ [ 13131, 13131 ], "mapped", [ 12513, 12460 ] ], [ [ 13132, 13132 ], "mapped", [ 12513, 12460, 12488, 12531 ] ], [ [ 13133, 13133 ], "mapped", [ 12513, 12540, 12488, 12523 ] ], [ [ 13134, 13134 ], "mapped", [ 12516, 12540, 12489 ] ], [ [ 13135, 13135 ], "mapped", [ 12516, 12540, 12523 ] ], [ [ 13136, 13136 ], "mapped", [ 12518, 12450, 12531 ] ], [ [ 13137, 13137 ], "mapped", [ 12522, 12483, 12488, 12523 ] ], [ [ 13138, 13138 ], "mapped", [ 12522, 12521 ] ], [ [ 13139, 13139 ], "mapped", [ 12523, 12500, 12540 ] ], [ [ 13140, 13140 ], "mapped", [ 12523, 12540, 12502, 12523 ] ], [ [ 13141, 13141 ], "mapped", [ 12524, 12512 ] ], [ [ 13142, 13142 ], "mapped", [ 12524, 12531, 12488, 12466, 12531 ] ], [ [ 13143, 13143 ], "mapped", [ 12527, 12483, 12488 ] ], [ [ 13144, 13144 ], "mapped", [ 48, 28857 ] ], [ [ 13145, 13145 ], "mapped", [ 49, 28857 ] ], [ [ 13146, 13146 ], "mapped", [ 50, 28857 ] ], [ [ 13147, 13147 ], "mapped", [ 51, 28857 ] ], [ [ 13148, 13148 ], "mapped", [ 52, 28857 ] ], [ [ 13149, 13149 ], "mapped", [ 53, 28857 ] ], [ [ 13150, 13150 ], "mapped", [ 54, 28857 ] ], [ [ 13151, 13151 ], "mapped", [ 55, 28857 ] ], [ [ 13152, 13152 ], "mapped", [ 56, 28857 ] ], [ [ 13153, 13153 ], "mapped", [ 57, 28857 ] ], [ [ 13154, 13154 ], "mapped", [ 49, 48, 28857 ] ], [ [ 13155, 13155 ], "mapped", [ 49, 49, 28857 ] ], [ [ 13156, 13156 ], "mapped", [ 49, 50, 28857 ] ], [ [ 13157, 13157 ], "mapped", [ 49, 51, 28857 ] ], [ [ 13158, 13158 ], "mapped", [ 49, 52, 28857 ] ], [ [ 13159, 13159 ], "mapped", [ 49, 53, 28857 ] ], [ [ 13160, 13160 ], "mapped", [ 49, 54, 28857 ] ], [ [ 13161, 13161 ], "mapped", [ 49, 55, 28857 ] ], [ [ 13162, 13162 ], "mapped", [ 49, 56, 28857 ] ], [ [ 13163, 13163 ], "mapped", [ 49, 57, 28857 ] ], [ [ 13164, 13164 ], "mapped", [ 50, 48, 28857 ] ], [ [ 13165, 13165 ], "mapped", [ 50, 49, 28857 ] ], [ [ 13166, 13166 ], "mapped", [ 50, 50, 28857 ] ], [ [ 13167, 13167 ], "mapped", [ 50, 51, 28857 ] ], [ [ 13168, 13168 ], "mapped", [ 50, 52, 28857 ] ], [ [ 13169, 13169 ], "mapped", [ 104, 112, 97 ] ], [ [ 13170, 13170 ], "mapped", [ 100, 97 ] ], [ [ 13171, 13171 ], "mapped", [ 97, 117 ] ], [ [ 13172, 13172 ], "mapped", [ 98, 97, 114 ] ], [ [ 13173, 13173 ], "mapped", [ 111, 118 ] ], [ [ 13174, 13174 ], "mapped", [ 112, 99 ] ], [ [ 13175, 13175 ], "mapped", [ 100, 109 ] ], [ [ 13176, 13176 ], "mapped", [ 100, 109, 50 ] ], [ [ 13177, 13177 ], "mapped", [ 100, 109, 51 ] ], [ [ 13178, 13178 ], "mapped", [ 105, 117 ] ], [ [ 13179, 13179 ], "mapped", [ 24179, 25104 ] ], [ [ 13180, 13180 ], "mapped", [ 26157, 21644 ] ], [ [ 13181, 13181 ], "mapped", [ 22823, 27491 ] ], [ [ 13182, 13182 ], "mapped", [ 26126, 27835 ] ], [ [ 13183, 13183 ], "mapped", [ 26666, 24335, 20250, 31038 ] ], [ [ 13184, 13184 ], "mapped", [ 112, 97 ] ], [ [ 13185, 13185 ], "mapped", [ 110, 97 ] ], [ [ 13186, 13186 ], "mapped", [ 956, 97 ] ], [ [ 13187, 13187 ], "mapped", [ 109, 97 ] ], [ [ 13188, 13188 ], "mapped", [ 107, 97 ] ], [ [ 13189, 13189 ], "mapped", [ 107, 98 ] ], [ [ 13190, 13190 ], "mapped", [ 109, 98 ] ], [ [ 13191, 13191 ], "mapped", [ 103, 98 ] ], [ [ 13192, 13192 ], "mapped", [ 99, 97, 108 ] ], [ [ 13193, 13193 ], "mapped", [ 107, 99, 97, 108 ] ], [ [ 13194, 13194 ], "mapped", [ 112, 102 ] ], [ [ 13195, 13195 ], "mapped", [ 110, 102 ] ], [ [ 13196, 13196 ], "mapped", [ 956, 102 ] ], [ [ 13197, 13197 ], "mapped", [ 956, 103 ] ], [ [ 13198, 13198 ], "mapped", [ 109, 103 ] ], [ [ 13199, 13199 ], "mapped", [ 107, 103 ] ], [ [ 13200, 13200 ], "mapped", [ 104, 122 ] ], [ [ 13201, 13201 ], "mapped", [ 107, 104, 122 ] ], [ [ 13202, 13202 ], "mapped", [ 109, 104, 122 ] ], [ [ 13203, 13203 ], "mapped", [ 103, 104, 122 ] ], [ [ 13204, 13204 ], "mapped", [ 116, 104, 122 ] ], [ [ 13205, 13205 ], "mapped", [ 956, 108 ] ], [ [ 13206, 13206 ], "mapped", [ 109, 108 ] ], [ [ 13207, 13207 ], "mapped", [ 100, 108 ] ], [ [ 13208, 13208 ], "mapped", [ 107, 108 ] ], [ [ 13209, 13209 ], "mapped", [ 102, 109 ] ], [ [ 13210, 13210 ], "mapped", [ 110, 109 ] ], [ [ 13211, 13211 ], "mapped", [ 956, 109 ] ], [ [ 13212, 13212 ], "mapped", [ 109, 109 ] ], [ [ 13213, 13213 ], "mapped", [ 99, 109 ] ], [ [ 13214, 13214 ], "mapped", [ 107, 109 ] ], [ [ 13215, 13215 ], "mapped", [ 109, 109, 50 ] ], [ [ 13216, 13216 ], "mapped", [ 99, 109, 50 ] ], [ [ 13217, 13217 ], "mapped", [ 109, 50 ] ], [ [ 13218, 13218 ], "mapped", [ 107, 109, 50 ] ], [ [ 13219, 13219 ], "mapped", [ 109, 109, 51 ] ], [ [ 13220, 13220 ], "mapped", [ 99, 109, 51 ] ], [ [ 13221, 13221 ], "mapped", [ 109, 51 ] ], [ [ 13222, 13222 ], "mapped", [ 107, 109, 51 ] ], [ [ 13223, 13223 ], "mapped", [ 109, 8725, 115 ] ], [ [ 13224, 13224 ], "mapped", [ 109, 8725, 115, 50 ] ], [ [ 13225, 13225 ], "mapped", [ 112, 97 ] ], [ [ 13226, 13226 ], "mapped", [ 107, 112, 97 ] ], [ [ 13227, 13227 ], "mapped", [ 109, 112, 97 ] ], [ [ 13228, 13228 ], "mapped", [ 103, 112, 97 ] ], [ [ 13229, 13229 ], "mapped", [ 114, 97, 100 ] ], [ [ 13230, 13230 ], "mapped", [ 114, 97, 100, 8725, 115 ] ], [ [ 13231, 13231 ], "mapped", [ 114, 97, 100, 8725, 115, 50 ] ], [ [ 13232, 13232 ], "mapped", [ 112, 115 ] ], [ [ 13233, 13233 ], "mapped", [ 110, 115 ] ], [ [ 13234, 13234 ], "mapped", [ 956, 115 ] ], [ [ 13235, 13235 ], "mapped", [ 109, 115 ] ], [ [ 13236, 13236 ], "mapped", [ 112, 118 ] ], [ [ 13237, 13237 ], "mapped", [ 110, 118 ] ], [ [ 13238, 13238 ], "mapped", [ 956, 118 ] ], [ [ 13239, 13239 ], "mapped", [ 109, 118 ] ], [ [ 13240, 13240 ], "mapped", [ 107, 118 ] ], [ [ 13241, 13241 ], "mapped", [ 109, 118 ] ], [ [ 13242, 13242 ], "mapped", [ 112, 119 ] ], [ [ 13243, 13243 ], "mapped", [ 110, 119 ] ], [ [ 13244, 13244 ], "mapped", [ 956, 119 ] ], [ [ 13245, 13245 ], "mapped", [ 109, 119 ] ], [ [ 13246, 13246 ], "mapped", [ 107, 119 ] ], [ [ 13247, 13247 ], "mapped", [ 109, 119 ] ], [ [ 13248, 13248 ], "mapped", [ 107, 969 ] ], [ [ 13249, 13249 ], "mapped", [ 109, 969 ] ], [ [ 13250, 13250 ], "disallowed" ], [ [ 13251, 13251 ], "mapped", [ 98, 113 ] ], [ [ 13252, 13252 ], "mapped", [ 99, 99 ] ], [ [ 13253, 13253 ], "mapped", [ 99, 100 ] ], [ [ 13254, 13254 ], "mapped", [ 99, 8725, 107, 103 ] ], [ [ 13255, 13255 ], "disallowed" ], [ [ 13256, 13256 ], "mapped", [ 100, 98 ] ], [ [ 13257, 13257 ], "mapped", [ 103, 121 ] ], [ [ 13258, 13258 ], "mapped", [ 104, 97 ] ], [ [ 13259, 13259 ], "mapped", [ 104, 112 ] ], [ [ 13260, 13260 ], "mapped", [ 105, 110 ] ], [ [ 13261, 13261 ], "mapped", [ 107, 107 ] ], [ [ 13262, 13262 ], "mapped", [ 107, 109 ] ], [ [ 13263, 13263 ], "mapped", [ 107, 116 ] ], [ [ 13264, 13264 ], "mapped", [ 108, 109 ] ], [ [ 13265, 13265 ], "mapped", [ 108, 110 ] ], [ [ 13266, 13266 ], "mapped", [ 108, 111, 103 ] ], [ [ 13267, 13267 ], "mapped", [ 108, 120 ] ], [ [ 13268, 13268 ], "mapped", [ 109, 98 ] ], [ [ 13269, 13269 ], "mapped", [ 109, 105, 108 ] ], [ [ 13270, 13270 ], "mapped", [ 109, 111, 108 ] ], [ [ 13271, 13271 ], "mapped", [ 112, 104 ] ], [ [ 13272, 13272 ], "disallowed" ], [ [ 13273, 13273 ], "mapped", [ 112, 112, 109 ] ], [ [ 13274, 13274 ], "mapped", [ 112, 114 ] ], [ [ 13275, 13275 ], "mapped", [ 115, 114 ] ], [ [ 13276, 13276 ], "mapped", [ 115, 118 ] ], [ [ 13277, 13277 ], "mapped", [ 119, 98 ] ], [ [ 13278, 13278 ], "mapped", [ 118, 8725, 109 ] ], [ [ 13279, 13279 ], "mapped", [ 97, 8725, 109 ] ], [ [ 13280, 13280 ], "mapped", [ 49, 26085 ] ], [ [ 13281, 13281 ], "mapped", [ 50, 26085 ] ], [ [ 13282, 13282 ], "mapped", [ 51, 26085 ] ], [ [ 13283, 13283 ], "mapped", [ 52, 26085 ] ], [ [ 13284, 13284 ], "mapped", [ 53, 26085 ] ], [ [ 13285, 13285 ], "mapped", [ 54, 26085 ] ], [ [ 13286, 13286 ], "mapped", [ 55, 26085 ] ], [ [ 13287, 13287 ], "mapped", [ 56, 26085 ] ], [ [ 13288, 13288 ], "mapped", [ 57, 26085 ] ], [ [ 13289, 13289 ], "mapped", [ 49, 48, 26085 ] ], [ [ 13290, 13290 ], "mapped", [ 49, 49, 26085 ] ], [ [ 13291, 13291 ], "mapped", [ 49, 50, 26085 ] ], [ [ 13292, 13292 ], "mapped", [ 49, 51, 26085 ] ], [ [ 13293, 13293 ], "mapped", [ 49, 52, 26085 ] ], [ [ 13294, 13294 ], "mapped", [ 49, 53, 26085 ] ], [ [ 13295, 13295 ], "mapped", [ 49, 54, 26085 ] ], [ [ 13296, 13296 ], "mapped", [ 49, 55, 26085 ] ], [ [ 13297, 13297 ], "mapped", [ 49, 56, 26085 ] ], [ [ 13298, 13298 ], "mapped", [ 49, 57, 26085 ] ], [ [ 13299, 13299 ], "mapped", [ 50, 48, 26085 ] ], [ [ 13300, 13300 ], "mapped", [ 50, 49, 26085 ] ], [ [ 13301, 13301 ], "mapped", [ 50, 50, 26085 ] ], [ [ 13302, 13302 ], "mapped", [ 50, 51, 26085 ] ], [ [ 13303, 13303 ], "mapped", [ 50, 52, 26085 ] ], [ [ 13304, 13304 ], "mapped", [ 50, 53, 26085 ] ], [ [ 13305, 13305 ], "mapped", [ 50, 54, 26085 ] ], [ [ 13306, 13306 ], "mapped", [ 50, 55, 26085 ] ], [ [ 13307, 13307 ], "mapped", [ 50, 56, 26085 ] ], [ [ 13308, 13308 ], "mapped", [ 50, 57, 26085 ] ], [ [ 13309, 13309 ], "mapped", [ 51, 48, 26085 ] ], [ [ 13310, 13310 ], "mapped", [ 51, 49, 26085 ] ], [ [ 13311, 13311 ], "mapped", [ 103, 97, 108 ] ], [ [ 13312, 19893 ], "valid" ], [ [ 19894, 19903 ], "disallowed" ], [ [ 19904, 19967 ], "valid", [], "NV8" ], [ [ 19968, 40869 ], "valid" ], [ [ 40870, 40891 ], "valid" ], [ [ 40892, 40899 ], "valid" ], [ [ 40900, 40907 ], "valid" ], [ [ 40908, 40908 ], "valid" ], [ [ 40909, 40917 ], "valid" ], [ [ 40918, 40959 ], "disallowed" ], [ [ 40960, 42124 ], "valid" ], [ [ 42125, 42127 ], "disallowed" ], [ [ 42128, 42145 ], "valid", [], "NV8" ], [ [ 42146, 42147 ], "valid", [], "NV8" ], [ [ 42148, 42163 ], "valid", [], "NV8" ], [ [ 42164, 42164 ], "valid", [], "NV8" ], [ [ 42165, 42176 ], "valid", [], "NV8" ], [ [ 42177, 42177 ], "valid", [], "NV8" ], [ [ 42178, 42180 ], "valid", [], "NV8" ], [ [ 42181, 42181 ], "valid", [], "NV8" ], [ [ 42182, 42182 ], "valid", [], "NV8" ], [ [ 42183, 42191 ], "disallowed" ], [ [ 42192, 42237 ], "valid" ], [ [ 42238, 42239 ], "valid", [], "NV8" ], [ [ 42240, 42508 ], "valid" ], [ [ 42509, 42511 ], "valid", [], "NV8" ], [ [ 42512, 42539 ], "valid" ], [ [ 42540, 42559 ], "disallowed" ], [ [ 42560, 42560 ], "mapped", [ 42561 ] ], [ [ 42561, 42561 ], "valid" ], [ [ 42562, 42562 ], "mapped", [ 42563 ] ], [ [ 42563, 42563 ], "valid" ], [ [ 42564, 42564 ], "mapped", [ 42565 ] ], [ [ 42565, 42565 ], "valid" ], [ [ 42566, 42566 ], "mapped", [ 42567 ] ], [ [ 42567, 42567 ], "valid" ], [ [ 42568, 42568 ], "mapped", [ 42569 ] ], [ [ 42569, 42569 ], "valid" ], [ [ 42570, 42570 ], "mapped", [ 42571 ] ], [ [ 42571, 42571 ], "valid" ], [ [ 42572, 42572 ], "mapped", [ 42573 ] ], [ [ 42573, 42573 ], "valid" ], [ [ 42574, 42574 ], "mapped", [ 42575 ] ], [ [ 42575, 42575 ], "valid" ], [ [ 42576, 42576 ], "mapped", [ 42577 ] ], [ [ 42577, 42577 ], "valid" ], [ [ 42578, 42578 ], "mapped", [ 42579 ] ], [ [ 42579, 42579 ], "valid" ], [ [ 42580, 42580 ], "mapped", [ 42581 ] ], [ [ 42581, 42581 ], "valid" ], [ [ 42582, 42582 ], "mapped", [ 42583 ] ], [ [ 42583, 42583 ], "valid" ], [ [ 42584, 42584 ], "mapped", [ 42585 ] ], [ [ 42585, 42585 ], "valid" ], [ [ 42586, 42586 ], "mapped", [ 42587 ] ], [ [ 42587, 42587 ], "valid" ], [ [ 42588, 42588 ], "mapped", [ 42589 ] ], [ [ 42589, 42589 ], "valid" ], [ [ 42590, 42590 ], "mapped", [ 42591 ] ], [ [ 42591, 42591 ], "valid" ], [ [ 42592, 42592 ], "mapped", [ 42593 ] ], [ [ 42593, 42593 ], "valid" ], [ [ 42594, 42594 ], "mapped", [ 42595 ] ], [ [ 42595, 42595 ], "valid" ], [ [ 42596, 42596 ], "mapped", [ 42597 ] ], [ [ 42597, 42597 ], "valid" ], [ [ 42598, 42598 ], "mapped", [ 42599 ] ], [ [ 42599, 42599 ], "valid" ], [ [ 42600, 42600 ], "mapped", [ 42601 ] ], [ [ 42601, 42601 ], "valid" ], [ [ 42602, 42602 ], "mapped", [ 42603 ] ], [ [ 42603, 42603 ], "valid" ], [ [ 42604, 42604 ], "mapped", [ 42605 ] ], [ [ 42605, 42607 ], "valid" ], [ [ 42608, 42611 ], "valid", [], "NV8" ], [ [ 42612, 42619 ], "valid" ], [ [ 42620, 42621 ], "valid" ], [ [ 42622, 42622 ], "valid", [], "NV8" ], [ [ 42623, 42623 ], "valid" ], [ [ 42624, 42624 ], "mapped", [ 42625 ] ], [ [ 42625, 42625 ], "valid" ], [ [ 42626, 42626 ], "mapped", [ 42627 ] ], [ [ 42627, 42627 ], "valid" ], [ [ 42628, 42628 ], "mapped", [ 42629 ] ], [ [ 42629, 42629 ], "valid" ], [ [ 42630, 42630 ], "mapped", [ 42631 ] ], [ [ 42631, 42631 ], "valid" ], [ [ 42632, 42632 ], "mapped", [ 42633 ] ], [ [ 42633, 42633 ], "valid" ], [ [ 42634, 42634 ], "mapped", [ 42635 ] ], [ [ 42635, 42635 ], "valid" ], [ [ 42636, 42636 ], "mapped", [ 42637 ] ], [ [ 42637, 42637 ], "valid" ], [ [ 42638, 42638 ], "mapped", [ 42639 ] ], [ [ 42639, 42639 ], "valid" ], [ [ 42640, 42640 ], "mapped", [ 42641 ] ], [ [ 42641, 42641 ], "valid" ], [ [ 42642, 42642 ], "mapped", [ 42643 ] ], [ [ 42643, 42643 ], "valid" ], [ [ 42644, 42644 ], "mapped", [ 42645 ] ], [ [ 42645, 42645 ], "valid" ], [ [ 42646, 42646 ], "mapped", [ 42647 ] ], [ [ 42647, 42647 ], "valid" ], [ [ 42648, 42648 ], "mapped", [ 42649 ] ], [ [ 42649, 42649 ], "valid" ], [ [ 42650, 42650 ], "mapped", [ 42651 ] ], [ [ 42651, 42651 ], "valid" ], [ [ 42652, 42652 ], "mapped", [ 1098 ] ], [ [ 42653, 42653 ], "mapped", [ 1100 ] ], [ [ 42654, 42654 ], "valid" ], [ [ 42655, 42655 ], "valid" ], [ [ 42656, 42725 ], "valid" ], [ [ 42726, 42735 ], "valid", [], "NV8" ], [ [ 42736, 42737 ], "valid" ], [ [ 42738, 42743 ], "valid", [], "NV8" ], [ [ 42744, 42751 ], "disallowed" ], [ [ 42752, 42774 ], "valid", [], "NV8" ], [ [ 42775, 42778 ], "valid" ], [ [ 42779, 42783 ], "valid" ], [ [ 42784, 42785 ], "valid", [], "NV8" ], [ [ 42786, 42786 ], "mapped", [ 42787 ] ], [ [ 42787, 42787 ], "valid" ], [ [ 42788, 42788 ], "mapped", [ 42789 ] ], [ [ 42789, 42789 ], "valid" ], [ [ 42790, 42790 ], "mapped", [ 42791 ] ], [ [ 42791, 42791 ], "valid" ], [ [ 42792, 42792 ], "mapped", [ 42793 ] ], [ [ 42793, 42793 ], "valid" ], [ [ 42794, 42794 ], "mapped", [ 42795 ] ], [ [ 42795, 42795 ], "valid" ], [ [ 42796, 42796 ], "mapped", [ 42797 ] ], [ [ 42797, 42797 ], "valid" ], [ [ 42798, 42798 ], "mapped", [ 42799 ] ], [ [ 42799, 42801 ], "valid" ], [ [ 42802, 42802 ], "mapped", [ 42803 ] ], [ [ 42803, 42803 ], "valid" ], [ [ 42804, 42804 ], "mapped", [ 42805 ] ], [ [ 42805, 42805 ], "valid" ], [ [ 42806, 42806 ], "mapped", [ 42807 ] ], [ [ 42807, 42807 ], "valid" ], [ [ 42808, 42808 ], "mapped", [ 42809 ] ], [ [ 42809, 42809 ], "valid" ], [ [ 42810, 42810 ], "mapped", [ 42811 ] ], [ [ 42811, 42811 ], "valid" ], [ [ 42812, 42812 ], "mapped", [ 42813 ] ], [ [ 42813, 42813 ], "valid" ], [ [ 42814, 42814 ], "mapped", [ 42815 ] ], [ [ 42815, 42815 ], "valid" ], [ [ 42816, 42816 ], "mapped", [ 42817 ] ], [ [ 42817, 42817 ], "valid" ], [ [ 42818, 42818 ], "mapped", [ 42819 ] ], [ [ 42819, 42819 ], "valid" ], [ [ 42820, 42820 ], "mapped", [ 42821 ] ], [ [ 42821, 42821 ], "valid" ], [ [ 42822, 42822 ], "mapped", [ 42823 ] ], [ [ 42823, 42823 ], "valid" ], [ [ 42824, 42824 ], "mapped", [ 42825 ] ], [ [ 42825, 42825 ], "valid" ], [ [ 42826, 42826 ], "mapped", [ 42827 ] ], [ [ 42827, 42827 ], "valid" ], [ [ 42828, 42828 ], "mapped", [ 42829 ] ], [ [ 42829, 42829 ], "valid" ], [ [ 42830, 42830 ], "mapped", [ 42831 ] ], [ [ 42831, 42831 ], "valid" ], [ [ 42832, 42832 ], "mapped", [ 42833 ] ], [ [ 42833, 42833 ], "valid" ], [ [ 42834, 42834 ], "mapped", [ 42835 ] ], [ [ 42835, 42835 ], "valid" ], [ [ 42836, 42836 ], "mapped", [ 42837 ] ], [ [ 42837, 42837 ], "valid" ], [ [ 42838, 42838 ], "mapped", [ 42839 ] ], [ [ 42839, 42839 ], "valid" ], [ [ 42840, 42840 ], "mapped", [ 42841 ] ], [ [ 42841, 42841 ], "valid" ], [ [ 42842, 42842 ], "mapped", [ 42843 ] ], [ [ 42843, 42843 ], "valid" ], [ [ 42844, 42844 ], "mapped", [ 42845 ] ], [ [ 42845, 42845 ], "valid" ], [ [ 42846, 42846 ], "mapped", [ 42847 ] ], [ [ 42847, 42847 ], "valid" ], [ [ 42848, 42848 ], "mapped", [ 42849 ] ], [ [ 42849, 42849 ], "valid" ], [ [ 42850, 42850 ], "mapped", [ 42851 ] ], [ [ 42851, 42851 ], "valid" ], [ [ 42852, 42852 ], "mapped", [ 42853 ] ], [ [ 42853, 42853 ], "valid" ], [ [ 42854, 42854 ], "mapped", [ 42855 ] ], [ [ 42855, 42855 ], "valid" ], [ [ 42856, 42856 ], "mapped", [ 42857 ] ], [ [ 42857, 42857 ], "valid" ], [ [ 42858, 42858 ], "mapped", [ 42859 ] ], [ [ 42859, 42859 ], "valid" ], [ [ 42860, 42860 ], "mapped", [ 42861 ] ], [ [ 42861, 42861 ], "valid" ], [ [ 42862, 42862 ], "mapped", [ 42863 ] ], [ [ 42863, 42863 ], "valid" ], [ [ 42864, 42864 ], "mapped", [ 42863 ] ], [ [ 42865, 42872 ], "valid" ], [ [ 42873, 42873 ], "mapped", [ 42874 ] ], [ [ 42874, 42874 ], "valid" ], [ [ 42875, 42875 ], "mapped", [ 42876 ] ], [ [ 42876, 42876 ], "valid" ], [ [ 42877, 42877 ], "mapped", [ 7545 ] ], [ [ 42878, 42878 ], "mapped", [ 42879 ] ], [ [ 42879, 42879 ], "valid" ], [ [ 42880, 42880 ], "mapped", [ 42881 ] ], [ [ 42881, 42881 ], "valid" ], [ [ 42882, 42882 ], "mapped", [ 42883 ] ], [ [ 42883, 42883 ], "valid" ], [ [ 42884, 42884 ], "mapped", [ 42885 ] ], [ [ 42885, 42885 ], "valid" ], [ [ 42886, 42886 ], "mapped", [ 42887 ] ], [ [ 42887, 42888 ], "valid" ], [ [ 42889, 42890 ], "valid", [], "NV8" ], [ [ 42891, 42891 ], "mapped", [ 42892 ] ], [ [ 42892, 42892 ], "valid" ], [ [ 42893, 42893 ], "mapped", [ 613 ] ], [ [ 42894, 42894 ], "valid" ], [ [ 42895, 42895 ], "valid" ], [ [ 42896, 42896 ], "mapped", [ 42897 ] ], [ [ 42897, 42897 ], "valid" ], [ [ 42898, 42898 ], "mapped", [ 42899 ] ], [ [ 42899, 42899 ], "valid" ], [ [ 42900, 42901 ], "valid" ], [ [ 42902, 42902 ], "mapped", [ 42903 ] ], [ [ 42903, 42903 ], "valid" ], [ [ 42904, 42904 ], "mapped", [ 42905 ] ], [ [ 42905, 42905 ], "valid" ], [ [ 42906, 42906 ], "mapped", [ 42907 ] ], [ [ 42907, 42907 ], "valid" ], [ [ 42908, 42908 ], "mapped", [ 42909 ] ], [ [ 42909, 42909 ], "valid" ], [ [ 42910, 42910 ], "mapped", [ 42911 ] ], [ [ 42911, 42911 ], "valid" ], [ [ 42912, 42912 ], "mapped", [ 42913 ] ], [ [ 42913, 42913 ], "valid" ], [ [ 42914, 42914 ], "mapped", [ 42915 ] ], [ [ 42915, 42915 ], "valid" ], [ [ 42916, 42916 ], "mapped", [ 42917 ] ], [ [ 42917, 42917 ], "valid" ], [ [ 42918, 42918 ], "mapped", [ 42919 ] ], [ [ 42919, 42919 ], "valid" ], [ [ 42920, 42920 ], "mapped", [ 42921 ] ], [ [ 42921, 42921 ], "valid" ], [ [ 42922, 42922 ], "mapped", [ 614 ] ], [ [ 42923, 42923 ], "mapped", [ 604 ] ], [ [ 42924, 42924 ], "mapped", [ 609 ] ], [ [ 42925, 42925 ], "mapped", [ 620 ] ], [ [ 42926, 42927 ], "disallowed" ], [ [ 42928, 42928 ], "mapped", [ 670 ] ], [ [ 42929, 42929 ], "mapped", [ 647 ] ], [ [ 42930, 42930 ], "mapped", [ 669 ] ], [ [ 42931, 42931 ], "mapped", [ 43859 ] ], [ [ 42932, 42932 ], "mapped", [ 42933 ] ], [ [ 42933, 42933 ], "valid" ], [ [ 42934, 42934 ], "mapped", [ 42935 ] ], [ [ 42935, 42935 ], "valid" ], [ [ 42936, 42998 ], "disallowed" ], [ [ 42999, 42999 ], "valid" ], [ [ 43e3, 43e3 ], "mapped", [ 295 ] ], [ [ 43001, 43001 ], "mapped", [ 339 ] ], [ [ 43002, 43002 ], "valid" ], [ [ 43003, 43007 ], "valid" ], [ [ 43008, 43047 ], "valid" ], [ [ 43048, 43051 ], "valid", [], "NV8" ], [ [ 43052, 43055 ], "disallowed" ], [ [ 43056, 43065 ], "valid", [], "NV8" ], [ [ 43066, 43071 ], "disallowed" ], [ [ 43072, 43123 ], "valid" ], [ [ 43124, 43127 ], "valid", [], "NV8" ], [ [ 43128, 43135 ], "disallowed" ], [ [ 43136, 43204 ], "valid" ], [ [ 43205, 43213 ], "disallowed" ], [ [ 43214, 43215 ], "valid", [], "NV8" ], [ [ 43216, 43225 ], "valid" ], [ [ 43226, 43231 ], "disallowed" ], [ [ 43232, 43255 ], "valid" ], [ [ 43256, 43258 ], "valid", [], "NV8" ], [ [ 43259, 43259 ], "valid" ], [ [ 43260, 43260 ], "valid", [], "NV8" ], [ [ 43261, 43261 ], "valid" ], [ [ 43262, 43263 ], "disallowed" ], [ [ 43264, 43309 ], "valid" ], [ [ 43310, 43311 ], "valid", [], "NV8" ], [ [ 43312, 43347 ], "valid" ], [ [ 43348, 43358 ], "disallowed" ], [ [ 43359, 43359 ], "valid", [], "NV8" ], [ [ 43360, 43388 ], "valid", [], "NV8" ], [ [ 43389, 43391 ], "disallowed" ], [ [ 43392, 43456 ], "valid" ], [ [ 43457, 43469 ], "valid", [], "NV8" ], [ [ 43470, 43470 ], "disallowed" ], [ [ 43471, 43481 ], "valid" ], [ [ 43482, 43485 ], "disallowed" ], [ [ 43486, 43487 ], "valid", [], "NV8" ], [ [ 43488, 43518 ], "valid" ], [ [ 43519, 43519 ], "disallowed" ], [ [ 43520, 43574 ], "valid" ], [ [ 43575, 43583 ], "disallowed" ], [ [ 43584, 43597 ], "valid" ], [ [ 43598, 43599 ], "disallowed" ], [ [ 43600, 43609 ], "valid" ], [ [ 43610, 43611 ], "disallowed" ], [ [ 43612, 43615 ], "valid", [], "NV8" ], [ [ 43616, 43638 ], "valid" ], [ [ 43639, 43641 ], "valid", [], "NV8" ], [ [ 43642, 43643 ], "valid" ], [ [ 43644, 43647 ], "valid" ], [ [ 43648, 43714 ], "valid" ], [ [ 43715, 43738 ], "disallowed" ], [ [ 43739, 43741 ], "valid" ], [ [ 43742, 43743 ], "valid", [], "NV8" ], [ [ 43744, 43759 ], "valid" ], [ [ 43760, 43761 ], "valid", [], "NV8" ], [ [ 43762, 43766 ], "valid" ], [ [ 43767, 43776 ], "disallowed" ], [ [ 43777, 43782 ], "valid" ], [ [ 43783, 43784 ], "disallowed" ], [ [ 43785, 43790 ], "valid" ], [ [ 43791, 43792 ], "disallowed" ], [ [ 43793, 43798 ], "valid" ], [ [ 43799, 43807 ], "disallowed" ], [ [ 43808, 43814 ], "valid" ], [ [ 43815, 43815 ], "disallowed" ], [ [ 43816, 43822 ], "valid" ], [ [ 43823, 43823 ], "disallowed" ], [ [ 43824, 43866 ], "valid" ], [ [ 43867, 43867 ], "valid", [], "NV8" ], [ [ 43868, 43868 ], "mapped", [ 42791 ] ], [ [ 43869, 43869 ], "mapped", [ 43831 ] ], [ [ 43870, 43870 ], "mapped", [ 619 ] ], [ [ 43871, 43871 ], "mapped", [ 43858 ] ], [ [ 43872, 43875 ], "valid" ], [ [ 43876, 43877 ], "valid" ], [ [ 43878, 43887 ], "disallowed" ], [ [ 43888, 43888 ], "mapped", [ 5024 ] ], [ [ 43889, 43889 ], "mapped", [ 5025 ] ], [ [ 43890, 43890 ], "mapped", [ 5026 ] ], [ [ 43891, 43891 ], "mapped", [ 5027 ] ], [ [ 43892, 43892 ], "mapped", [ 5028 ] ], [ [ 43893, 43893 ], "mapped", [ 5029 ] ], [ [ 43894, 43894 ], "mapped", [ 5030 ] ], [ [ 43895, 43895 ], "mapped", [ 5031 ] ], [ [ 43896, 43896 ], "mapped", [ 5032 ] ], [ [ 43897, 43897 ], "mapped", [ 5033 ] ], [ [ 43898, 43898 ], "mapped", [ 5034 ] ], [ [ 43899, 43899 ], "mapped", [ 5035 ] ], [ [ 43900, 43900 ], "mapped", [ 5036 ] ], [ [ 43901, 43901 ], "mapped", [ 5037 ] ], [ [ 43902, 43902 ], "mapped", [ 5038 ] ], [ [ 43903, 43903 ], "mapped", [ 5039 ] ], [ [ 43904, 43904 ], "mapped", [ 5040 ] ], [ [ 43905, 43905 ], "mapped", [ 5041 ] ], [ [ 43906, 43906 ], "mapped", [ 5042 ] ], [ [ 43907, 43907 ], "mapped", [ 5043 ] ], [ [ 43908, 43908 ], "mapped", [ 5044 ] ], [ [ 43909, 43909 ], "mapped", [ 5045 ] ], [ [ 43910, 43910 ], "mapped", [ 5046 ] ], [ [ 43911, 43911 ], "mapped", [ 5047 ] ], [ [ 43912, 43912 ], "mapped", [ 5048 ] ], [ [ 43913, 43913 ], "mapped", [ 5049 ] ], [ [ 43914, 43914 ], "mapped", [ 5050 ] ], [ [ 43915, 43915 ], "mapped", [ 5051 ] ], [ [ 43916, 43916 ], "mapped", [ 5052 ] ], [ [ 43917, 43917 ], "mapped", [ 5053 ] ], [ [ 43918, 43918 ], "mapped", [ 5054 ] ], [ [ 43919, 43919 ], "mapped", [ 5055 ] ], [ [ 43920, 43920 ], "mapped", [ 5056 ] ], [ [ 43921, 43921 ], "mapped", [ 5057 ] ], [ [ 43922, 43922 ], "mapped", [ 5058 ] ], [ [ 43923, 43923 ], "mapped", [ 5059 ] ], [ [ 43924, 43924 ], "mapped", [ 5060 ] ], [ [ 43925, 43925 ], "mapped", [ 5061 ] ], [ [ 43926, 43926 ], "mapped", [ 5062 ] ], [ [ 43927, 43927 ], "mapped", [ 5063 ] ], [ [ 43928, 43928 ], "mapped", [ 5064 ] ], [ [ 43929, 43929 ], "mapped", [ 5065 ] ], [ [ 43930, 43930 ], "mapped", [ 5066 ] ], [ [ 43931, 43931 ], "mapped", [ 5067 ] ], [ [ 43932, 43932 ], "mapped", [ 5068 ] ], [ [ 43933, 43933 ], "mapped", [ 5069 ] ], [ [ 43934, 43934 ], "mapped", [ 5070 ] ], [ [ 43935, 43935 ], "mapped", [ 5071 ] ], [ [ 43936, 43936 ], "mapped", [ 5072 ] ], [ [ 43937, 43937 ], "mapped", [ 5073 ] ], [ [ 43938, 43938 ], "mapped", [ 5074 ] ], [ [ 43939, 43939 ], "mapped", [ 5075 ] ], [ [ 43940, 43940 ], "mapped", [ 5076 ] ], [ [ 43941, 43941 ], "mapped", [ 5077 ] ], [ [ 43942, 43942 ], "mapped", [ 5078 ] ], [ [ 43943, 43943 ], "mapped", [ 5079 ] ], [ [ 43944, 43944 ], "mapped", [ 5080 ] ], [ [ 43945, 43945 ], "mapped", [ 5081 ] ], [ [ 43946, 43946 ], "mapped", [ 5082 ] ], [ [ 43947, 43947 ], "mapped", [ 5083 ] ], [ [ 43948, 43948 ], "mapped", [ 5084 ] ], [ [ 43949, 43949 ], "mapped", [ 5085 ] ], [ [ 43950, 43950 ], "mapped", [ 5086 ] ], [ [ 43951, 43951 ], "mapped", [ 5087 ] ], [ [ 43952, 43952 ], "mapped", [ 5088 ] ], [ [ 43953, 43953 ], "mapped", [ 5089 ] ], [ [ 43954, 43954 ], "mapped", [ 5090 ] ], [ [ 43955, 43955 ], "mapped", [ 5091 ] ], [ [ 43956, 43956 ], "mapped", [ 5092 ] ], [ [ 43957, 43957 ], "mapped", [ 5093 ] ], [ [ 43958, 43958 ], "mapped", [ 5094 ] ], [ [ 43959, 43959 ], "mapped", [ 5095 ] ], [ [ 43960, 43960 ], "mapped", [ 5096 ] ], [ [ 43961, 43961 ], "mapped", [ 5097 ] ], [ [ 43962, 43962 ], "mapped", [ 5098 ] ], [ [ 43963, 43963 ], "mapped", [ 5099 ] ], [ [ 43964, 43964 ], "mapped", [ 5100 ] ], [ [ 43965, 43965 ], "mapped", [ 5101 ] ], [ [ 43966, 43966 ], "mapped", [ 5102 ] ], [ [ 43967, 43967 ], "mapped", [ 5103 ] ], [ [ 43968, 44010 ], "valid" ], [ [ 44011, 44011 ], "valid", [], "NV8" ], [ [ 44012, 44013 ], "valid" ], [ [ 44014, 44015 ], "disallowed" ], [ [ 44016, 44025 ], "valid" ], [ [ 44026, 44031 ], "disallowed" ], [ [ 44032, 55203 ], "valid" ], [ [ 55204, 55215 ], "disallowed" ], [ [ 55216, 55238 ], "valid", [], "NV8" ], [ [ 55239, 55242 ], "disallowed" ], [ [ 55243, 55291 ], "valid", [], "NV8" ], [ [ 55292, 55295 ], "disallowed" ], [ [ 55296, 57343 ], "disallowed" ], [ [ 57344, 63743 ], "disallowed" ], [ [ 63744, 63744 ], "mapped", [ 35912 ] ], [ [ 63745, 63745 ], "mapped", [ 26356 ] ], [ [ 63746, 63746 ], "mapped", [ 36554 ] ], [ [ 63747, 63747 ], "mapped", [ 36040 ] ], [ [ 63748, 63748 ], "mapped", [ 28369 ] ], [ [ 63749, 63749 ], "mapped", [ 20018 ] ], [ [ 63750, 63750 ], "mapped", [ 21477 ] ], [ [ 63751, 63752 ], "mapped", [ 40860 ] ], [ [ 63753, 63753 ], "mapped", [ 22865 ] ], [ [ 63754, 63754 ], "mapped", [ 37329 ] ], [ [ 63755, 63755 ], "mapped", [ 21895 ] ], [ [ 63756, 63756 ], "mapped", [ 22856 ] ], [ [ 63757, 63757 ], "mapped", [ 25078 ] ], [ [ 63758, 63758 ], "mapped", [ 30313 ] ], [ [ 63759, 63759 ], "mapped", [ 32645 ] ], [ [ 63760, 63760 ], "mapped", [ 34367 ] ], [ [ 63761, 63761 ], "mapped", [ 34746 ] ], [ [ 63762, 63762 ], "mapped", [ 35064 ] ], [ [ 63763, 63763 ], "mapped", [ 37007 ] ], [ [ 63764, 63764 ], "mapped", [ 27138 ] ], [ [ 63765, 63765 ], "mapped", [ 27931 ] ], [ [ 63766, 63766 ], "mapped", [ 28889 ] ], [ [ 63767, 63767 ], "mapped", [ 29662 ] ], [ [ 63768, 63768 ], "mapped", [ 33853 ] ], [ [ 63769, 63769 ], "mapped", [ 37226 ] ], [ [ 63770, 63770 ], "mapped", [ 39409 ] ], [ [ 63771, 63771 ], "mapped", [ 20098 ] ], [ [ 63772, 63772 ], "mapped", [ 21365 ] ], [ [ 63773, 63773 ], "mapped", [ 27396 ] ], [ [ 63774, 63774 ], "mapped", [ 29211 ] ], [ [ 63775, 63775 ], "mapped", [ 34349 ] ], [ [ 63776, 63776 ], "mapped", [ 40478 ] ], [ [ 63777, 63777 ], "mapped", [ 23888 ] ], [ [ 63778, 63778 ], "mapped", [ 28651 ] ], [ [ 63779, 63779 ], "mapped", [ 34253 ] ], [ [ 63780, 63780 ], "mapped", [ 35172 ] ], [ [ 63781, 63781 ], "mapped", [ 25289 ] ], [ [ 63782, 63782 ], "mapped", [ 33240 ] ], [ [ 63783, 63783 ], "mapped", [ 34847 ] ], [ [ 63784, 63784 ], "mapped", [ 24266 ] ], [ [ 63785, 63785 ], "mapped", [ 26391 ] ], [ [ 63786, 63786 ], "mapped", [ 28010 ] ], [ [ 63787, 63787 ], "mapped", [ 29436 ] ], [ [ 63788, 63788 ], "mapped", [ 37070 ] ], [ [ 63789, 63789 ], "mapped", [ 20358 ] ], [ [ 63790, 63790 ], "mapped", [ 20919 ] ], [ [ 63791, 63791 ], "mapped", [ 21214 ] ], [ [ 63792, 63792 ], "mapped", [ 25796 ] ], [ [ 63793, 63793 ], "mapped", [ 27347 ] ], [ [ 63794, 63794 ], "mapped", [ 29200 ] ], [ [ 63795, 63795 ], "mapped", [ 30439 ] ], [ [ 63796, 63796 ], "mapped", [ 32769 ] ], [ [ 63797, 63797 ], "mapped", [ 34310 ] ], [ [ 63798, 63798 ], "mapped", [ 34396 ] ], [ [ 63799, 63799 ], "mapped", [ 36335 ] ], [ [ 63800, 63800 ], "mapped", [ 38706 ] ], [ [ 63801, 63801 ], "mapped", [ 39791 ] ], [ [ 63802, 63802 ], "mapped", [ 40442 ] ], [ [ 63803, 63803 ], "mapped", [ 30860 ] ], [ [ 63804, 63804 ], "mapped", [ 31103 ] ], [ [ 63805, 63805 ], "mapped", [ 32160 ] ], [ [ 63806, 63806 ], "mapped", [ 33737 ] ], [ [ 63807, 63807 ], "mapped", [ 37636 ] ], [ [ 63808, 63808 ], "mapped", [ 40575 ] ], [ [ 63809, 63809 ], "mapped", [ 35542 ] ], [ [ 63810, 63810 ], "mapped", [ 22751 ] ], [ [ 63811, 63811 ], "mapped", [ 24324 ] ], [ [ 63812, 63812 ], "mapped", [ 31840 ] ], [ [ 63813, 63813 ], "mapped", [ 32894 ] ], [ [ 63814, 63814 ], "mapped", [ 29282 ] ], [ [ 63815, 63815 ], "mapped", [ 30922 ] ], [ [ 63816, 63816 ], "mapped", [ 36034 ] ], [ [ 63817, 63817 ], "mapped", [ 38647 ] ], [ [ 63818, 63818 ], "mapped", [ 22744 ] ], [ [ 63819, 63819 ], "mapped", [ 23650 ] ], [ [ 63820, 63820 ], "mapped", [ 27155 ] ], [ [ 63821, 63821 ], "mapped", [ 28122 ] ], [ [ 63822, 63822 ], "mapped", [ 28431 ] ], [ [ 63823, 63823 ], "mapped", [ 32047 ] ], [ [ 63824, 63824 ], "mapped", [ 32311 ] ], [ [ 63825, 63825 ], "mapped", [ 38475 ] ], [ [ 63826, 63826 ], "mapped", [ 21202 ] ], [ [ 63827, 63827 ], "mapped", [ 32907 ] ], [ [ 63828, 63828 ], "mapped", [ 20956 ] ], [ [ 63829, 63829 ], "mapped", [ 20940 ] ], [ [ 63830, 63830 ], "mapped", [ 31260 ] ], [ [ 63831, 63831 ], "mapped", [ 32190 ] ], [ [ 63832, 63832 ], "mapped", [ 33777 ] ], [ [ 63833, 63833 ], "mapped", [ 38517 ] ], [ [ 63834, 63834 ], "mapped", [ 35712 ] ], [ [ 63835, 63835 ], "mapped", [ 25295 ] ], [ [ 63836, 63836 ], "mapped", [ 27138 ] ], [ [ 63837, 63837 ], "mapped", [ 35582 ] ], [ [ 63838, 63838 ], "mapped", [ 20025 ] ], [ [ 63839, 63839 ], "mapped", [ 23527 ] ], [ [ 63840, 63840 ], "mapped", [ 24594 ] ], [ [ 63841, 63841 ], "mapped", [ 29575 ] ], [ [ 63842, 63842 ], "mapped", [ 30064 ] ], [ [ 63843, 63843 ], "mapped", [ 21271 ] ], [ [ 63844, 63844 ], "mapped", [ 30971 ] ], [ [ 63845, 63845 ], "mapped", [ 20415 ] ], [ [ 63846, 63846 ], "mapped", [ 24489 ] ], [ [ 63847, 63847 ], "mapped", [ 19981 ] ], [ [ 63848, 63848 ], "mapped", [ 27852 ] ], [ [ 63849, 63849 ], "mapped", [ 25976 ] ], [ [ 63850, 63850 ], "mapped", [ 32034 ] ], [ [ 63851, 63851 ], "mapped", [ 21443 ] ], [ [ 63852, 63852 ], "mapped", [ 22622 ] ], [ [ 63853, 63853 ], "mapped", [ 30465 ] ], [ [ 63854, 63854 ], "mapped", [ 33865 ] ], [ [ 63855, 63855 ], "mapped", [ 35498 ] ], [ [ 63856, 63856 ], "mapped", [ 27578 ] ], [ [ 63857, 63857 ], "mapped", [ 36784 ] ], [ [ 63858, 63858 ], "mapped", [ 27784 ] ], [ [ 63859, 63859 ], "mapped", [ 25342 ] ], [ [ 63860, 63860 ], "mapped", [ 33509 ] ], [ [ 63861, 63861 ], "mapped", [ 25504 ] ], [ [ 63862, 63862 ], "mapped", [ 30053 ] ], [ [ 63863, 63863 ], "mapped", [ 20142 ] ], [ [ 63864, 63864 ], "mapped", [ 20841 ] ], [ [ 63865, 63865 ], "mapped", [ 20937 ] ], [ [ 63866, 63866 ], "mapped", [ 26753 ] ], [ [ 63867, 63867 ], "mapped", [ 31975 ] ], [ [ 63868, 63868 ], "mapped", [ 33391 ] ], [ [ 63869, 63869 ], "mapped", [ 35538 ] ], [ [ 63870, 63870 ], "mapped", [ 37327 ] ], [ [ 63871, 63871 ], "mapped", [ 21237 ] ], [ [ 63872, 63872 ], "mapped", [ 21570 ] ], [ [ 63873, 63873 ], "mapped", [ 22899 ] ], [ [ 63874, 63874 ], "mapped", [ 24300 ] ], [ [ 63875, 63875 ], "mapped", [ 26053 ] ], [ [ 63876, 63876 ], "mapped", [ 28670 ] ], [ [ 63877, 63877 ], "mapped", [ 31018 ] ], [ [ 63878, 63878 ], "mapped", [ 38317 ] ], [ [ 63879, 63879 ], "mapped", [ 39530 ] ], [ [ 63880, 63880 ], "mapped", [ 40599 ] ], [ [ 63881, 63881 ], "mapped", [ 40654 ] ], [ [ 63882, 63882 ], "mapped", [ 21147 ] ], [ [ 63883, 63883 ], "mapped", [ 26310 ] ], [ [ 63884, 63884 ], "mapped", [ 27511 ] ], [ [ 63885, 63885 ], "mapped", [ 36706 ] ], [ [ 63886, 63886 ], "mapped", [ 24180 ] ], [ [ 63887, 63887 ], "mapped", [ 24976 ] ], [ [ 63888, 63888 ], "mapped", [ 25088 ] ], [ [ 63889, 63889 ], "mapped", [ 25754 ] ], [ [ 63890, 63890 ], "mapped", [ 28451 ] ], [ [ 63891, 63891 ], "mapped", [ 29001 ] ], [ [ 63892, 63892 ], "mapped", [ 29833 ] ], [ [ 63893, 63893 ], "mapped", [ 31178 ] ], [ [ 63894, 63894 ], "mapped", [ 32244 ] ], [ [ 63895, 63895 ], "mapped", [ 32879 ] ], [ [ 63896, 63896 ], "mapped", [ 36646 ] ], [ [ 63897, 63897 ], "mapped", [ 34030 ] ], [ [ 63898, 63898 ], "mapped", [ 36899 ] ], [ [ 63899, 63899 ], "mapped", [ 37706 ] ], [ [ 63900, 63900 ], "mapped", [ 21015 ] ], [ [ 63901, 63901 ], "mapped", [ 21155 ] ], [ [ 63902, 63902 ], "mapped", [ 21693 ] ], [ [ 63903, 63903 ], "mapped", [ 28872 ] ], [ [ 63904, 63904 ], "mapped", [ 35010 ] ], [ [ 63905, 63905 ], "mapped", [ 35498 ] ], [ [ 63906, 63906 ], "mapped", [ 24265 ] ], [ [ 63907, 63907 ], "mapped", [ 24565 ] ], [ [ 63908, 63908 ], "mapped", [ 25467 ] ], [ [ 63909, 63909 ], "mapped", [ 27566 ] ], [ [ 63910, 63910 ], "mapped", [ 31806 ] ], [ [ 63911, 63911 ], "mapped", [ 29557 ] ], [ [ 63912, 63912 ], "mapped", [ 20196 ] ], [ [ 63913, 63913 ], "mapped", [ 22265 ] ], [ [ 63914, 63914 ], "mapped", [ 23527 ] ], [ [ 63915, 63915 ], "mapped", [ 23994 ] ], [ [ 63916, 63916 ], "mapped", [ 24604 ] ], [ [ 63917, 63917 ], "mapped", [ 29618 ] ], [ [ 63918, 63918 ], "mapped", [ 29801 ] ], [ [ 63919, 63919 ], "mapped", [ 32666 ] ], [ [ 63920, 63920 ], "mapped", [ 32838 ] ], [ [ 63921, 63921 ], "mapped", [ 37428 ] ], [ [ 63922, 63922 ], "mapped", [ 38646 ] ], [ [ 63923, 63923 ], "mapped", [ 38728 ] ], [ [ 63924, 63924 ], "mapped", [ 38936 ] ], [ [ 63925, 63925 ], "mapped", [ 20363 ] ], [ [ 63926, 63926 ], "mapped", [ 31150 ] ], [ [ 63927, 63927 ], "mapped", [ 37300 ] ], [ [ 63928, 63928 ], "mapped", [ 38584 ] ], [ [ 63929, 63929 ], "mapped", [ 24801 ] ], [ [ 63930, 63930 ], "mapped", [ 20102 ] ], [ [ 63931, 63931 ], "mapped", [ 20698 ] ], [ [ 63932, 63932 ], "mapped", [ 23534 ] ], [ [ 63933, 63933 ], "mapped", [ 23615 ] ], [ [ 63934, 63934 ], "mapped", [ 26009 ] ], [ [ 63935, 63935 ], "mapped", [ 27138 ] ], [ [ 63936, 63936 ], "mapped", [ 29134 ] ], [ [ 63937, 63937 ], "mapped", [ 30274 ] ], [ [ 63938, 63938 ], "mapped", [ 34044 ] ], [ [ 63939, 63939 ], "mapped", [ 36988 ] ], [ [ 63940, 63940 ], "mapped", [ 40845 ] ], [ [ 63941, 63941 ], "mapped", [ 26248 ] ], [ [ 63942, 63942 ], "mapped", [ 38446 ] ], [ [ 63943, 63943 ], "mapped", [ 21129 ] ], [ [ 63944, 63944 ], "mapped", [ 26491 ] ], [ [ 63945, 63945 ], "mapped", [ 26611 ] ], [ [ 63946, 63946 ], "mapped", [ 27969 ] ], [ [ 63947, 63947 ], "mapped", [ 28316 ] ], [ [ 63948, 63948 ], "mapped", [ 29705 ] ], [ [ 63949, 63949 ], "mapped", [ 30041 ] ], [ [ 63950, 63950 ], "mapped", [ 30827 ] ], [ [ 63951, 63951 ], "mapped", [ 32016 ] ], [ [ 63952, 63952 ], "mapped", [ 39006 ] ], [ [ 63953, 63953 ], "mapped", [ 20845 ] ], [ [ 63954, 63954 ], "mapped", [ 25134 ] ], [ [ 63955, 63955 ], "mapped", [ 38520 ] ], [ [ 63956, 63956 ], "mapped", [ 20523 ] ], [ [ 63957, 63957 ], "mapped", [ 23833 ] ], [ [ 63958, 63958 ], "mapped", [ 28138 ] ], [ [ 63959, 63959 ], "mapped", [ 36650 ] ], [ [ 63960, 63960 ], "mapped", [ 24459 ] ], [ [ 63961, 63961 ], "mapped", [ 24900 ] ], [ [ 63962, 63962 ], "mapped", [ 26647 ] ], [ [ 63963, 63963 ], "mapped", [ 29575 ] ], [ [ 63964, 63964 ], "mapped", [ 38534 ] ], [ [ 63965, 63965 ], "mapped", [ 21033 ] ], [ [ 63966, 63966 ], "mapped", [ 21519 ] ], [ [ 63967, 63967 ], "mapped", [ 23653 ] ], [ [ 63968, 63968 ], "mapped", [ 26131 ] ], [ [ 63969, 63969 ], "mapped", [ 26446 ] ], [ [ 63970, 63970 ], "mapped", [ 26792 ] ], [ [ 63971, 63971 ], "mapped", [ 27877 ] ], [ [ 63972, 63972 ], "mapped", [ 29702 ] ], [ [ 63973, 63973 ], "mapped", [ 30178 ] ], [ [ 63974, 63974 ], "mapped", [ 32633 ] ], [ [ 63975, 63975 ], "mapped", [ 35023 ] ], [ [ 63976, 63976 ], "mapped", [ 35041 ] ], [ [ 63977, 63977 ], "mapped", [ 37324 ] ], [ [ 63978, 63978 ], "mapped", [ 38626 ] ], [ [ 63979, 63979 ], "mapped", [ 21311 ] ], [ [ 63980, 63980 ], "mapped", [ 28346 ] ], [ [ 63981, 63981 ], "mapped", [ 21533 ] ], [ [ 63982, 63982 ], "mapped", [ 29136 ] ], [ [ 63983, 63983 ], "mapped", [ 29848 ] ], [ [ 63984, 63984 ], "mapped", [ 34298 ] ], [ [ 63985, 63985 ], "mapped", [ 38563 ] ], [ [ 63986, 63986 ], "mapped", [ 40023 ] ], [ [ 63987, 63987 ], "mapped", [ 40607 ] ], [ [ 63988, 63988 ], "mapped", [ 26519 ] ], [ [ 63989, 63989 ], "mapped", [ 28107 ] ], [ [ 63990, 63990 ], "mapped", [ 33256 ] ], [ [ 63991, 63991 ], "mapped", [ 31435 ] ], [ [ 63992, 63992 ], "mapped", [ 31520 ] ], [ [ 63993, 63993 ], "mapped", [ 31890 ] ], [ [ 63994, 63994 ], "mapped", [ 29376 ] ], [ [ 63995, 63995 ], "mapped", [ 28825 ] ], [ [ 63996, 63996 ], "mapped", [ 35672 ] ], [ [ 63997, 63997 ], "mapped", [ 20160 ] ], [ [ 63998, 63998 ], "mapped", [ 33590 ] ], [ [ 63999, 63999 ], "mapped", [ 21050 ] ], [ [ 64e3, 64e3 ], "mapped", [ 20999 ] ], [ [ 64001, 64001 ], "mapped", [ 24230 ] ], [ [ 64002, 64002 ], "mapped", [ 25299 ] ], [ [ 64003, 64003 ], "mapped", [ 31958 ] ], [ [ 64004, 64004 ], "mapped", [ 23429 ] ], [ [ 64005, 64005 ], "mapped", [ 27934 ] ], [ [ 64006, 64006 ], "mapped", [ 26292 ] ], [ [ 64007, 64007 ], "mapped", [ 36667 ] ], [ [ 64008, 64008 ], "mapped", [ 34892 ] ], [ [ 64009, 64009 ], "mapped", [ 38477 ] ], [ [ 64010, 64010 ], "mapped", [ 35211 ] ], [ [ 64011, 64011 ], "mapped", [ 24275 ] ], [ [ 64012, 64012 ], "mapped", [ 20800 ] ], [ [ 64013, 64013 ], "mapped", [ 21952 ] ], [ [ 64014, 64015 ], "valid" ], [ [ 64016, 64016 ], "mapped", [ 22618 ] ], [ [ 64017, 64017 ], "valid" ], [ [ 64018, 64018 ], "mapped", [ 26228 ] ], [ [ 64019, 64020 ], "valid" ], [ [ 64021, 64021 ], "mapped", [ 20958 ] ], [ [ 64022, 64022 ], "mapped", [ 29482 ] ], [ [ 64023, 64023 ], "mapped", [ 30410 ] ], [ [ 64024, 64024 ], "mapped", [ 31036 ] ], [ [ 64025, 64025 ], "mapped", [ 31070 ] ], [ [ 64026, 64026 ], "mapped", [ 31077 ] ], [ [ 64027, 64027 ], "mapped", [ 31119 ] ], [ [ 64028, 64028 ], "mapped", [ 38742 ] ], [ [ 64029, 64029 ], "mapped", [ 31934 ] ], [ [ 64030, 64030 ], "mapped", [ 32701 ] ], [ [ 64031, 64031 ], "valid" ], [ [ 64032, 64032 ], "mapped", [ 34322 ] ], [ [ 64033, 64033 ], "valid" ], [ [ 64034, 64034 ], "mapped", [ 35576 ] ], [ [ 64035, 64036 ], "valid" ], [ [ 64037, 64037 ], "mapped", [ 36920 ] ], [ [ 64038, 64038 ], "mapped", [ 37117 ] ], [ [ 64039, 64041 ], "valid" ], [ [ 64042, 64042 ], "mapped", [ 39151 ] ], [ [ 64043, 64043 ], "mapped", [ 39164 ] ], [ [ 64044, 64044 ], "mapped", [ 39208 ] ], [ [ 64045, 64045 ], "mapped", [ 40372 ] ], [ [ 64046, 64046 ], "mapped", [ 37086 ] ], [ [ 64047, 64047 ], "mapped", [ 38583 ] ], [ [ 64048, 64048 ], "mapped", [ 20398 ] ], [ [ 64049, 64049 ], "mapped", [ 20711 ] ], [ [ 64050, 64050 ], "mapped", [ 20813 ] ], [ [ 64051, 64051 ], "mapped", [ 21193 ] ], [ [ 64052, 64052 ], "mapped", [ 21220 ] ], [ [ 64053, 64053 ], "mapped", [ 21329 ] ], [ [ 64054, 64054 ], "mapped", [ 21917 ] ], [ [ 64055, 64055 ], "mapped", [ 22022 ] ], [ [ 64056, 64056 ], "mapped", [ 22120 ] ], [ [ 64057, 64057 ], "mapped", [ 22592 ] ], [ [ 64058, 64058 ], "mapped", [ 22696 ] ], [ [ 64059, 64059 ], "mapped", [ 23652 ] ], [ [ 64060, 64060 ], "mapped", [ 23662 ] ], [ [ 64061, 64061 ], "mapped", [ 24724 ] ], [ [ 64062, 64062 ], "mapped", [ 24936 ] ], [ [ 64063, 64063 ], "mapped", [ 24974 ] ], [ [ 64064, 64064 ], "mapped", [ 25074 ] ], [ [ 64065, 64065 ], "mapped", [ 25935 ] ], [ [ 64066, 64066 ], "mapped", [ 26082 ] ], [ [ 64067, 64067 ], "mapped", [ 26257 ] ], [ [ 64068, 64068 ], "mapped", [ 26757 ] ], [ [ 64069, 64069 ], "mapped", [ 28023 ] ], [ [ 64070, 64070 ], "mapped", [ 28186 ] ], [ [ 64071, 64071 ], "mapped", [ 28450 ] ], [ [ 64072, 64072 ], "mapped", [ 29038 ] ], [ [ 64073, 64073 ], "mapped", [ 29227 ] ], [ [ 64074, 64074 ], "mapped", [ 29730 ] ], [ [ 64075, 64075 ], "mapped", [ 30865 ] ], [ [ 64076, 64076 ], "mapped", [ 31038 ] ], [ [ 64077, 64077 ], "mapped", [ 31049 ] ], [ [ 64078, 64078 ], "mapped", [ 31048 ] ], [ [ 64079, 64079 ], "mapped", [ 31056 ] ], [ [ 64080, 64080 ], "mapped", [ 31062 ] ], [ [ 64081, 64081 ], "mapped", [ 31069 ] ], [ [ 64082, 64082 ], "mapped", [ 31117 ] ], [ [ 64083, 64083 ], "mapped", [ 31118 ] ], [ [ 64084, 64084 ], "mapped", [ 31296 ] ], [ [ 64085, 64085 ], "mapped", [ 31361 ] ], [ [ 64086, 64086 ], "mapped", [ 31680 ] ], [ [ 64087, 64087 ], "mapped", [ 32244 ] ], [ [ 64088, 64088 ], "mapped", [ 32265 ] ], [ [ 64089, 64089 ], "mapped", [ 32321 ] ], [ [ 64090, 64090 ], "mapped", [ 32626 ] ], [ [ 64091, 64091 ], "mapped", [ 32773 ] ], [ [ 64092, 64092 ], "mapped", [ 33261 ] ], [ [ 64093, 64094 ], "mapped", [ 33401 ] ], [ [ 64095, 64095 ], "mapped", [ 33879 ] ], [ [ 64096, 64096 ], "mapped", [ 35088 ] ], [ [ 64097, 64097 ], "mapped", [ 35222 ] ], [ [ 64098, 64098 ], "mapped", [ 35585 ] ], [ [ 64099, 64099 ], "mapped", [ 35641 ] ], [ [ 64100, 64100 ], "mapped", [ 36051 ] ], [ [ 64101, 64101 ], "mapped", [ 36104 ] ], [ [ 64102, 64102 ], "mapped", [ 36790 ] ], [ [ 64103, 64103 ], "mapped", [ 36920 ] ], [ [ 64104, 64104 ], "mapped", [ 38627 ] ], [ [ 64105, 64105 ], "mapped", [ 38911 ] ], [ [ 64106, 64106 ], "mapped", [ 38971 ] ], [ [ 64107, 64107 ], "mapped", [ 24693 ] ], [ [ 64108, 64108 ], "mapped", [ 148206 ] ], [ [ 64109, 64109 ], "mapped", [ 33304 ] ], [ [ 64110, 64111 ], "disallowed" ], [ [ 64112, 64112 ], "mapped", [ 20006 ] ], [ [ 64113, 64113 ], "mapped", [ 20917 ] ], [ [ 64114, 64114 ], "mapped", [ 20840 ] ], [ [ 64115, 64115 ], "mapped", [ 20352 ] ], [ [ 64116, 64116 ], "mapped", [ 20805 ] ], [ [ 64117, 64117 ], "mapped", [ 20864 ] ], [ [ 64118, 64118 ], "mapped", [ 21191 ] ], [ [ 64119, 64119 ], "mapped", [ 21242 ] ], [ [ 64120, 64120 ], "mapped", [ 21917 ] ], [ [ 64121, 64121 ], "mapped", [ 21845 ] ], [ [ 64122, 64122 ], "mapped", [ 21913 ] ], [ [ 64123, 64123 ], "mapped", [ 21986 ] ], [ [ 64124, 64124 ], "mapped", [ 22618 ] ], [ [ 64125, 64125 ], "mapped", [ 22707 ] ], [ [ 64126, 64126 ], "mapped", [ 22852 ] ], [ [ 64127, 64127 ], "mapped", [ 22868 ] ], [ [ 64128, 64128 ], "mapped", [ 23138 ] ], [ [ 64129, 64129 ], "mapped", [ 23336 ] ], [ [ 64130, 64130 ], "mapped", [ 24274 ] ], [ [ 64131, 64131 ], "mapped", [ 24281 ] ], [ [ 64132, 64132 ], "mapped", [ 24425 ] ], [ [ 64133, 64133 ], "mapped", [ 24493 ] ], [ [ 64134, 64134 ], "mapped", [ 24792 ] ], [ [ 64135, 64135 ], "mapped", [ 24910 ] ], [ [ 64136, 64136 ], "mapped", [ 24840 ] ], [ [ 64137, 64137 ], "mapped", [ 24974 ] ], [ [ 64138, 64138 ], "mapped", [ 24928 ] ], [ [ 64139, 64139 ], "mapped", [ 25074 ] ], [ [ 64140, 64140 ], "mapped", [ 25140 ] ], [ [ 64141, 64141 ], "mapped", [ 25540 ] ], [ [ 64142, 64142 ], "mapped", [ 25628 ] ], [ [ 64143, 64143 ], "mapped", [ 25682 ] ], [ [ 64144, 64144 ], "mapped", [ 25942 ] ], [ [ 64145, 64145 ], "mapped", [ 26228 ] ], [ [ 64146, 64146 ], "mapped", [ 26391 ] ], [ [ 64147, 64147 ], "mapped", [ 26395 ] ], [ [ 64148, 64148 ], "mapped", [ 26454 ] ], [ [ 64149, 64149 ], "mapped", [ 27513 ] ], [ [ 64150, 64150 ], "mapped", [ 27578 ] ], [ [ 64151, 64151 ], "mapped", [ 27969 ] ], [ [ 64152, 64152 ], "mapped", [ 28379 ] ], [ [ 64153, 64153 ], "mapped", [ 28363 ] ], [ [ 64154, 64154 ], "mapped", [ 28450 ] ], [ [ 64155, 64155 ], "mapped", [ 28702 ] ], [ [ 64156, 64156 ], "mapped", [ 29038 ] ], [ [ 64157, 64157 ], "mapped", [ 30631 ] ], [ [ 64158, 64158 ], "mapped", [ 29237 ] ], [ [ 64159, 64159 ], "mapped", [ 29359 ] ], [ [ 64160, 64160 ], "mapped", [ 29482 ] ], [ [ 64161, 64161 ], "mapped", [ 29809 ] ], [ [ 64162, 64162 ], "mapped", [ 29958 ] ], [ [ 64163, 64163 ], "mapped", [ 30011 ] ], [ [ 64164, 64164 ], "mapped", [ 30237 ] ], [ [ 64165, 64165 ], "mapped", [ 30239 ] ], [ [ 64166, 64166 ], "mapped", [ 30410 ] ], [ [ 64167, 64167 ], "mapped", [ 30427 ] ], [ [ 64168, 64168 ], "mapped", [ 30452 ] ], [ [ 64169, 64169 ], "mapped", [ 30538 ] ], [ [ 64170, 64170 ], "mapped", [ 30528 ] ], [ [ 64171, 64171 ], "mapped", [ 30924 ] ], [ [ 64172, 64172 ], "mapped", [ 31409 ] ], [ [ 64173, 64173 ], "mapped", [ 31680 ] ], [ [ 64174, 64174 ], "mapped", [ 31867 ] ], [ [ 64175, 64175 ], "mapped", [ 32091 ] ], [ [ 64176, 64176 ], "mapped", [ 32244 ] ], [ [ 64177, 64177 ], "mapped", [ 32574 ] ], [ [ 64178, 64178 ], "mapped", [ 32773 ] ], [ [ 64179, 64179 ], "mapped", [ 33618 ] ], [ [ 64180, 64180 ], "mapped", [ 33775 ] ], [ [ 64181, 64181 ], "mapped", [ 34681 ] ], [ [ 64182, 64182 ], "mapped", [ 35137 ] ], [ [ 64183, 64183 ], "mapped", [ 35206 ] ], [ [ 64184, 64184 ], "mapped", [ 35222 ] ], [ [ 64185, 64185 ], "mapped", [ 35519 ] ], [ [ 64186, 64186 ], "mapped", [ 35576 ] ], [ [ 64187, 64187 ], "mapped", [ 35531 ] ], [ [ 64188, 64188 ], "mapped", [ 35585 ] ], [ [ 64189, 64189 ], "mapped", [ 35582 ] ], [ [ 64190, 64190 ], "mapped", [ 35565 ] ], [ [ 64191, 64191 ], "mapped", [ 35641 ] ], [ [ 64192, 64192 ], "mapped", [ 35722 ] ], [ [ 64193, 64193 ], "mapped", [ 36104 ] ], [ [ 64194, 64194 ], "mapped", [ 36664 ] ], [ [ 64195, 64195 ], "mapped", [ 36978 ] ], [ [ 64196, 64196 ], "mapped", [ 37273 ] ], [ [ 64197, 64197 ], "mapped", [ 37494 ] ], [ [ 64198, 64198 ], "mapped", [ 38524 ] ], [ [ 64199, 64199 ], "mapped", [ 38627 ] ], [ [ 64200, 64200 ], "mapped", [ 38742 ] ], [ [ 64201, 64201 ], "mapped", [ 38875 ] ], [ [ 64202, 64202 ], "mapped", [ 38911 ] ], [ [ 64203, 64203 ], "mapped", [ 38923 ] ], [ [ 64204, 64204 ], "mapped", [ 38971 ] ], [ [ 64205, 64205 ], "mapped", [ 39698 ] ], [ [ 64206, 64206 ], "mapped", [ 40860 ] ], [ [ 64207, 64207 ], "mapped", [ 141386 ] ], [ [ 64208, 64208 ], "mapped", [ 141380 ] ], [ [ 64209, 64209 ], "mapped", [ 144341 ] ], [ [ 64210, 64210 ], "mapped", [ 15261 ] ], [ [ 64211, 64211 ], "mapped", [ 16408 ] ], [ [ 64212, 64212 ], "mapped", [ 16441 ] ], [ [ 64213, 64213 ], "mapped", [ 152137 ] ], [ [ 64214, 64214 ], "mapped", [ 154832 ] ], [ [ 64215, 64215 ], "mapped", [ 163539 ] ], [ [ 64216, 64216 ], "mapped", [ 40771 ] ], [ [ 64217, 64217 ], "mapped", [ 40846 ] ], [ [ 64218, 64255 ], "disallowed" ], [ [ 64256, 64256 ], "mapped", [ 102, 102 ] ], [ [ 64257, 64257 ], "mapped", [ 102, 105 ] ], [ [ 64258, 64258 ], "mapped", [ 102, 108 ] ], [ [ 64259, 64259 ], "mapped", [ 102, 102, 105 ] ], [ [ 64260, 64260 ], "mapped", [ 102, 102, 108 ] ], [ [ 64261, 64262 ], "mapped", [ 115, 116 ] ], [ [ 64263, 64274 ], "disallowed" ], [ [ 64275, 64275 ], "mapped", [ 1396, 1398 ] ], [ [ 64276, 64276 ], "mapped", [ 1396, 1381 ] ], [ [ 64277, 64277 ], "mapped", [ 1396, 1387 ] ], [ [ 64278, 64278 ], "mapped", [ 1406, 1398 ] ], [ [ 64279, 64279 ], "mapped", [ 1396, 1389 ] ], [ [ 64280, 64284 ], "disallowed" ], [ [ 64285, 64285 ], "mapped", [ 1497, 1460 ] ], [ [ 64286, 64286 ], "valid" ], [ [ 64287, 64287 ], "mapped", [ 1522, 1463 ] ], [ [ 64288, 64288 ], "mapped", [ 1506 ] ], [ [ 64289, 64289 ], "mapped", [ 1488 ] ], [ [ 64290, 64290 ], "mapped", [ 1491 ] ], [ [ 64291, 64291 ], "mapped", [ 1492 ] ], [ [ 64292, 64292 ], "mapped", [ 1499 ] ], [ [ 64293, 64293 ], "mapped", [ 1500 ] ], [ [ 64294, 64294 ], "mapped", [ 1501 ] ], [ [ 64295, 64295 ], "mapped", [ 1512 ] ], [ [ 64296, 64296 ], "mapped", [ 1514 ] ], [ [ 64297, 64297 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 64298, 64298 ], "mapped", [ 1513, 1473 ] ], [ [ 64299, 64299 ], "mapped", [ 1513, 1474 ] ], [ [ 64300, 64300 ], "mapped", [ 1513, 1468, 1473 ] ], [ [ 64301, 64301 ], "mapped", [ 1513, 1468, 1474 ] ], [ [ 64302, 64302 ], "mapped", [ 1488, 1463 ] ], [ [ 64303, 64303 ], "mapped", [ 1488, 1464 ] ], [ [ 64304, 64304 ], "mapped", [ 1488, 1468 ] ], [ [ 64305, 64305 ], "mapped", [ 1489, 1468 ] ], [ [ 64306, 64306 ], "mapped", [ 1490, 1468 ] ], [ [ 64307, 64307 ], "mapped", [ 1491, 1468 ] ], [ [ 64308, 64308 ], "mapped", [ 1492, 1468 ] ], [ [ 64309, 64309 ], "mapped", [ 1493, 1468 ] ], [ [ 64310, 64310 ], "mapped", [ 1494, 1468 ] ], [ [ 64311, 64311 ], "disallowed" ], [ [ 64312, 64312 ], "mapped", [ 1496, 1468 ] ], [ [ 64313, 64313 ], "mapped", [ 1497, 1468 ] ], [ [ 64314, 64314 ], "mapped", [ 1498, 1468 ] ], [ [ 64315, 64315 ], "mapped", [ 1499, 1468 ] ], [ [ 64316, 64316 ], "mapped", [ 1500, 1468 ] ], [ [ 64317, 64317 ], "disallowed" ], [ [ 64318, 64318 ], "mapped", [ 1502, 1468 ] ], [ [ 64319, 64319 ], "disallowed" ], [ [ 64320, 64320 ], "mapped", [ 1504, 1468 ] ], [ [ 64321, 64321 ], "mapped", [ 1505, 1468 ] ], [ [ 64322, 64322 ], "disallowed" ], [ [ 64323, 64323 ], "mapped", [ 1507, 1468 ] ], [ [ 64324, 64324 ], "mapped", [ 1508, 1468 ] ], [ [ 64325, 64325 ], "disallowed" ], [ [ 64326, 64326 ], "mapped", [ 1510, 1468 ] ], [ [ 64327, 64327 ], "mapped", [ 1511, 1468 ] ], [ [ 64328, 64328 ], "mapped", [ 1512, 1468 ] ], [ [ 64329, 64329 ], "mapped", [ 1513, 1468 ] ], [ [ 64330, 64330 ], "mapped", [ 1514, 1468 ] ], [ [ 64331, 64331 ], "mapped", [ 1493, 1465 ] ], [ [ 64332, 64332 ], "mapped", [ 1489, 1471 ] ], [ [ 64333, 64333 ], "mapped", [ 1499, 1471 ] ], [ [ 64334, 64334 ], "mapped", [ 1508, 1471 ] ], [ [ 64335, 64335 ], "mapped", [ 1488, 1500 ] ], [ [ 64336, 64337 ], "mapped", [ 1649 ] ], [ [ 64338, 64341 ], "mapped", [ 1659 ] ], [ [ 64342, 64345 ], "mapped", [ 1662 ] ], [ [ 64346, 64349 ], "mapped", [ 1664 ] ], [ [ 64350, 64353 ], "mapped", [ 1658 ] ], [ [ 64354, 64357 ], "mapped", [ 1663 ] ], [ [ 64358, 64361 ], "mapped", [ 1657 ] ], [ [ 64362, 64365 ], "mapped", [ 1700 ] ], [ [ 64366, 64369 ], "mapped", [ 1702 ] ], [ [ 64370, 64373 ], "mapped", [ 1668 ] ], [ [ 64374, 64377 ], "mapped", [ 1667 ] ], [ [ 64378, 64381 ], "mapped", [ 1670 ] ], [ [ 64382, 64385 ], "mapped", [ 1671 ] ], [ [ 64386, 64387 ], "mapped", [ 1677 ] ], [ [ 64388, 64389 ], "mapped", [ 1676 ] ], [ [ 64390, 64391 ], "mapped", [ 1678 ] ], [ [ 64392, 64393 ], "mapped", [ 1672 ] ], [ [ 64394, 64395 ], "mapped", [ 1688 ] ], [ [ 64396, 64397 ], "mapped", [ 1681 ] ], [ [ 64398, 64401 ], "mapped", [ 1705 ] ], [ [ 64402, 64405 ], "mapped", [ 1711 ] ], [ [ 64406, 64409 ], "mapped", [ 1715 ] ], [ [ 64410, 64413 ], "mapped", [ 1713 ] ], [ [ 64414, 64415 ], "mapped", [ 1722 ] ], [ [ 64416, 64419 ], "mapped", [ 1723 ] ], [ [ 64420, 64421 ], "mapped", [ 1728 ] ], [ [ 64422, 64425 ], "mapped", [ 1729 ] ], [ [ 64426, 64429 ], "mapped", [ 1726 ] ], [ [ 64430, 64431 ], "mapped", [ 1746 ] ], [ [ 64432, 64433 ], "mapped", [ 1747 ] ], [ [ 64434, 64449 ], "valid", [], "NV8" ], [ [ 64450, 64466 ], "disallowed" ], [ [ 64467, 64470 ], "mapped", [ 1709 ] ], [ [ 64471, 64472 ], "mapped", [ 1735 ] ], [ [ 64473, 64474 ], "mapped", [ 1734 ] ], [ [ 64475, 64476 ], "mapped", [ 1736 ] ], [ [ 64477, 64477 ], "mapped", [ 1735, 1652 ] ], [ [ 64478, 64479 ], "mapped", [ 1739 ] ], [ [ 64480, 64481 ], "mapped", [ 1733 ] ], [ [ 64482, 64483 ], "mapped", [ 1737 ] ], [ [ 64484, 64487 ], "mapped", [ 1744 ] ], [ [ 64488, 64489 ], "mapped", [ 1609 ] ], [ [ 64490, 64491 ], "mapped", [ 1574, 1575 ] ], [ [ 64492, 64493 ], "mapped", [ 1574, 1749 ] ], [ [ 64494, 64495 ], "mapped", [ 1574, 1608 ] ], [ [ 64496, 64497 ], "mapped", [ 1574, 1735 ] ], [ [ 64498, 64499 ], "mapped", [ 1574, 1734 ] ], [ [ 64500, 64501 ], "mapped", [ 1574, 1736 ] ], [ [ 64502, 64504 ], "mapped", [ 1574, 1744 ] ], [ [ 64505, 64507 ], "mapped", [ 1574, 1609 ] ], [ [ 64508, 64511 ], "mapped", [ 1740 ] ], [ [ 64512, 64512 ], "mapped", [ 1574, 1580 ] ], [ [ 64513, 64513 ], "mapped", [ 1574, 1581 ] ], [ [ 64514, 64514 ], "mapped", [ 1574, 1605 ] ], [ [ 64515, 64515 ], "mapped", [ 1574, 1609 ] ], [ [ 64516, 64516 ], "mapped", [ 1574, 1610 ] ], [ [ 64517, 64517 ], "mapped", [ 1576, 1580 ] ], [ [ 64518, 64518 ], "mapped", [ 1576, 1581 ] ], [ [ 64519, 64519 ], "mapped", [ 1576, 1582 ] ], [ [ 64520, 64520 ], "mapped", [ 1576, 1605 ] ], [ [ 64521, 64521 ], "mapped", [ 1576, 1609 ] ], [ [ 64522, 64522 ], "mapped", [ 1576, 1610 ] ], [ [ 64523, 64523 ], "mapped", [ 1578, 1580 ] ], [ [ 64524, 64524 ], "mapped", [ 1578, 1581 ] ], [ [ 64525, 64525 ], "mapped", [ 1578, 1582 ] ], [ [ 64526, 64526 ], "mapped", [ 1578, 1605 ] ], [ [ 64527, 64527 ], "mapped", [ 1578, 1609 ] ], [ [ 64528, 64528 ], "mapped", [ 1578, 1610 ] ], [ [ 64529, 64529 ], "mapped", [ 1579, 1580 ] ], [ [ 64530, 64530 ], "mapped", [ 1579, 1605 ] ], [ [ 64531, 64531 ], "mapped", [ 1579, 1609 ] ], [ [ 64532, 64532 ], "mapped", [ 1579, 1610 ] ], [ [ 64533, 64533 ], "mapped", [ 1580, 1581 ] ], [ [ 64534, 64534 ], "mapped", [ 1580, 1605 ] ], [ [ 64535, 64535 ], "mapped", [ 1581, 1580 ] ], [ [ 64536, 64536 ], "mapped", [ 1581, 1605 ] ], [ [ 64537, 64537 ], "mapped", [ 1582, 1580 ] ], [ [ 64538, 64538 ], "mapped", [ 1582, 1581 ] ], [ [ 64539, 64539 ], "mapped", [ 1582, 1605 ] ], [ [ 64540, 64540 ], "mapped", [ 1587, 1580 ] ], [ [ 64541, 64541 ], "mapped", [ 1587, 1581 ] ], [ [ 64542, 64542 ], "mapped", [ 1587, 1582 ] ], [ [ 64543, 64543 ], "mapped", [ 1587, 1605 ] ], [ [ 64544, 64544 ], "mapped", [ 1589, 1581 ] ], [ [ 64545, 64545 ], "mapped", [ 1589, 1605 ] ], [ [ 64546, 64546 ], "mapped", [ 1590, 1580 ] ], [ [ 64547, 64547 ], "mapped", [ 1590, 1581 ] ], [ [ 64548, 64548 ], "mapped", [ 1590, 1582 ] ], [ [ 64549, 64549 ], "mapped", [ 1590, 1605 ] ], [ [ 64550, 64550 ], "mapped", [ 1591, 1581 ] ], [ [ 64551, 64551 ], "mapped", [ 1591, 1605 ] ], [ [ 64552, 64552 ], "mapped", [ 1592, 1605 ] ], [ [ 64553, 64553 ], "mapped", [ 1593, 1580 ] ], [ [ 64554, 64554 ], "mapped", [ 1593, 1605 ] ], [ [ 64555, 64555 ], "mapped", [ 1594, 1580 ] ], [ [ 64556, 64556 ], "mapped", [ 1594, 1605 ] ], [ [ 64557, 64557 ], "mapped", [ 1601, 1580 ] ], [ [ 64558, 64558 ], "mapped", [ 1601, 1581 ] ], [ [ 64559, 64559 ], "mapped", [ 1601, 1582 ] ], [ [ 64560, 64560 ], "mapped", [ 1601, 1605 ] ], [ [ 64561, 64561 ], "mapped", [ 1601, 1609 ] ], [ [ 64562, 64562 ], "mapped", [ 1601, 1610 ] ], [ [ 64563, 64563 ], "mapped", [ 1602, 1581 ] ], [ [ 64564, 64564 ], "mapped", [ 1602, 1605 ] ], [ [ 64565, 64565 ], "mapped", [ 1602, 1609 ] ], [ [ 64566, 64566 ], "mapped", [ 1602, 1610 ] ], [ [ 64567, 64567 ], "mapped", [ 1603, 1575 ] ], [ [ 64568, 64568 ], "mapped", [ 1603, 1580 ] ], [ [ 64569, 64569 ], "mapped", [ 1603, 1581 ] ], [ [ 64570, 64570 ], "mapped", [ 1603, 1582 ] ], [ [ 64571, 64571 ], "mapped", [ 1603, 1604 ] ], [ [ 64572, 64572 ], "mapped", [ 1603, 1605 ] ], [ [ 64573, 64573 ], "mapped", [ 1603, 1609 ] ], [ [ 64574, 64574 ], "mapped", [ 1603, 1610 ] ], [ [ 64575, 64575 ], "mapped", [ 1604, 1580 ] ], [ [ 64576, 64576 ], "mapped", [ 1604, 1581 ] ], [ [ 64577, 64577 ], "mapped", [ 1604, 1582 ] ], [ [ 64578, 64578 ], "mapped", [ 1604, 1605 ] ], [ [ 64579, 64579 ], "mapped", [ 1604, 1609 ] ], [ [ 64580, 64580 ], "mapped", [ 1604, 1610 ] ], [ [ 64581, 64581 ], "mapped", [ 1605, 1580 ] ], [ [ 64582, 64582 ], "mapped", [ 1605, 1581 ] ], [ [ 64583, 64583 ], "mapped", [ 1605, 1582 ] ], [ [ 64584, 64584 ], "mapped", [ 1605, 1605 ] ], [ [ 64585, 64585 ], "mapped", [ 1605, 1609 ] ], [ [ 64586, 64586 ], "mapped", [ 1605, 1610 ] ], [ [ 64587, 64587 ], "mapped", [ 1606, 1580 ] ], [ [ 64588, 64588 ], "mapped", [ 1606, 1581 ] ], [ [ 64589, 64589 ], "mapped", [ 1606, 1582 ] ], [ [ 64590, 64590 ], "mapped", [ 1606, 1605 ] ], [ [ 64591, 64591 ], "mapped", [ 1606, 1609 ] ], [ [ 64592, 64592 ], "mapped", [ 1606, 1610 ] ], [ [ 64593, 64593 ], "mapped", [ 1607, 1580 ] ], [ [ 64594, 64594 ], "mapped", [ 1607, 1605 ] ], [ [ 64595, 64595 ], "mapped", [ 1607, 1609 ] ], [ [ 64596, 64596 ], "mapped", [ 1607, 1610 ] ], [ [ 64597, 64597 ], "mapped", [ 1610, 1580 ] ], [ [ 64598, 64598 ], "mapped", [ 1610, 1581 ] ], [ [ 64599, 64599 ], "mapped", [ 1610, 1582 ] ], [ [ 64600, 64600 ], "mapped", [ 1610, 1605 ] ], [ [ 64601, 64601 ], "mapped", [ 1610, 1609 ] ], [ [ 64602, 64602 ], "mapped", [ 1610, 1610 ] ], [ [ 64603, 64603 ], "mapped", [ 1584, 1648 ] ], [ [ 64604, 64604 ], "mapped", [ 1585, 1648 ] ], [ [ 64605, 64605 ], "mapped", [ 1609, 1648 ] ], [ [ 64606, 64606 ], "disallowed_STD3_mapped", [ 32, 1612, 1617 ] ], [ [ 64607, 64607 ], "disallowed_STD3_mapped", [ 32, 1613, 1617 ] ], [ [ 64608, 64608 ], "disallowed_STD3_mapped", [ 32, 1614, 1617 ] ], [ [ 64609, 64609 ], "disallowed_STD3_mapped", [ 32, 1615, 1617 ] ], [ [ 64610, 64610 ], "disallowed_STD3_mapped", [ 32, 1616, 1617 ] ], [ [ 64611, 64611 ], "disallowed_STD3_mapped", [ 32, 1617, 1648 ] ], [ [ 64612, 64612 ], "mapped", [ 1574, 1585 ] ], [ [ 64613, 64613 ], "mapped", [ 1574, 1586 ] ], [ [ 64614, 64614 ], "mapped", [ 1574, 1605 ] ], [ [ 64615, 64615 ], "mapped", [ 1574, 1606 ] ], [ [ 64616, 64616 ], "mapped", [ 1574, 1609 ] ], [ [ 64617, 64617 ], "mapped", [ 1574, 1610 ] ], [ [ 64618, 64618 ], "mapped", [ 1576, 1585 ] ], [ [ 64619, 64619 ], "mapped", [ 1576, 1586 ] ], [ [ 64620, 64620 ], "mapped", [ 1576, 1605 ] ], [ [ 64621, 64621 ], "mapped", [ 1576, 1606 ] ], [ [ 64622, 64622 ], "mapped", [ 1576, 1609 ] ], [ [ 64623, 64623 ], "mapped", [ 1576, 1610 ] ], [ [ 64624, 64624 ], "mapped", [ 1578, 1585 ] ], [ [ 64625, 64625 ], "mapped", [ 1578, 1586 ] ], [ [ 64626, 64626 ], "mapped", [ 1578, 1605 ] ], [ [ 64627, 64627 ], "mapped", [ 1578, 1606 ] ], [ [ 64628, 64628 ], "mapped", [ 1578, 1609 ] ], [ [ 64629, 64629 ], "mapped", [ 1578, 1610 ] ], [ [ 64630, 64630 ], "mapped", [ 1579, 1585 ] ], [ [ 64631, 64631 ], "mapped", [ 1579, 1586 ] ], [ [ 64632, 64632 ], "mapped", [ 1579, 1605 ] ], [ [ 64633, 64633 ], "mapped", [ 1579, 1606 ] ], [ [ 64634, 64634 ], "mapped", [ 1579, 1609 ] ], [ [ 64635, 64635 ], "mapped", [ 1579, 1610 ] ], [ [ 64636, 64636 ], "mapped", [ 1601, 1609 ] ], [ [ 64637, 64637 ], "mapped", [ 1601, 1610 ] ], [ [ 64638, 64638 ], "mapped", [ 1602, 1609 ] ], [ [ 64639, 64639 ], "mapped", [ 1602, 1610 ] ], [ [ 64640, 64640 ], "mapped", [ 1603, 1575 ] ], [ [ 64641, 64641 ], "mapped", [ 1603, 1604 ] ], [ [ 64642, 64642 ], "mapped", [ 1603, 1605 ] ], [ [ 64643, 64643 ], "mapped", [ 1603, 1609 ] ], [ [ 64644, 64644 ], "mapped", [ 1603, 1610 ] ], [ [ 64645, 64645 ], "mapped", [ 1604, 1605 ] ], [ [ 64646, 64646 ], "mapped", [ 1604, 1609 ] ], [ [ 64647, 64647 ], "mapped", [ 1604, 1610 ] ], [ [ 64648, 64648 ], "mapped", [ 1605, 1575 ] ], [ [ 64649, 64649 ], "mapped", [ 1605, 1605 ] ], [ [ 64650, 64650 ], "mapped", [ 1606, 1585 ] ], [ [ 64651, 64651 ], "mapped", [ 1606, 1586 ] ], [ [ 64652, 64652 ], "mapped", [ 1606, 1605 ] ], [ [ 64653, 64653 ], "mapped", [ 1606, 1606 ] ], [ [ 64654, 64654 ], "mapped", [ 1606, 1609 ] ], [ [ 64655, 64655 ], "mapped", [ 1606, 1610 ] ], [ [ 64656, 64656 ], "mapped", [ 1609, 1648 ] ], [ [ 64657, 64657 ], "mapped", [ 1610, 1585 ] ], [ [ 64658, 64658 ], "mapped", [ 1610, 1586 ] ], [ [ 64659, 64659 ], "mapped", [ 1610, 1605 ] ], [ [ 64660, 64660 ], "mapped", [ 1610, 1606 ] ], [ [ 64661, 64661 ], "mapped", [ 1610, 1609 ] ], [ [ 64662, 64662 ], "mapped", [ 1610, 1610 ] ], [ [ 64663, 64663 ], "mapped", [ 1574, 1580 ] ], [ [ 64664, 64664 ], "mapped", [ 1574, 1581 ] ], [ [ 64665, 64665 ], "mapped", [ 1574, 1582 ] ], [ [ 64666, 64666 ], "mapped", [ 1574, 1605 ] ], [ [ 64667, 64667 ], "mapped", [ 1574, 1607 ] ], [ [ 64668, 64668 ], "mapped", [ 1576, 1580 ] ], [ [ 64669, 64669 ], "mapped", [ 1576, 1581 ] ], [ [ 64670, 64670 ], "mapped", [ 1576, 1582 ] ], [ [ 64671, 64671 ], "mapped", [ 1576, 1605 ] ], [ [ 64672, 64672 ], "mapped", [ 1576, 1607 ] ], [ [ 64673, 64673 ], "mapped", [ 1578, 1580 ] ], [ [ 64674, 64674 ], "mapped", [ 1578, 1581 ] ], [ [ 64675, 64675 ], "mapped", [ 1578, 1582 ] ], [ [ 64676, 64676 ], "mapped", [ 1578, 1605 ] ], [ [ 64677, 64677 ], "mapped", [ 1578, 1607 ] ], [ [ 64678, 64678 ], "mapped", [ 1579, 1605 ] ], [ [ 64679, 64679 ], "mapped", [ 1580, 1581 ] ], [ [ 64680, 64680 ], "mapped", [ 1580, 1605 ] ], [ [ 64681, 64681 ], "mapped", [ 1581, 1580 ] ], [ [ 64682, 64682 ], "mapped", [ 1581, 1605 ] ], [ [ 64683, 64683 ], "mapped", [ 1582, 1580 ] ], [ [ 64684, 64684 ], "mapped", [ 1582, 1605 ] ], [ [ 64685, 64685 ], "mapped", [ 1587, 1580 ] ], [ [ 64686, 64686 ], "mapped", [ 1587, 1581 ] ], [ [ 64687, 64687 ], "mapped", [ 1587, 1582 ] ], [ [ 64688, 64688 ], "mapped", [ 1587, 1605 ] ], [ [ 64689, 64689 ], "mapped", [ 1589, 1581 ] ], [ [ 64690, 64690 ], "mapped", [ 1589, 1582 ] ], [ [ 64691, 64691 ], "mapped", [ 1589, 1605 ] ], [ [ 64692, 64692 ], "mapped", [ 1590, 1580 ] ], [ [ 64693, 64693 ], "mapped", [ 1590, 1581 ] ], [ [ 64694, 64694 ], "mapped", [ 1590, 1582 ] ], [ [ 64695, 64695 ], "mapped", [ 1590, 1605 ] ], [ [ 64696, 64696 ], "mapped", [ 1591, 1581 ] ], [ [ 64697, 64697 ], "mapped", [ 1592, 1605 ] ], [ [ 64698, 64698 ], "mapped", [ 1593, 1580 ] ], [ [ 64699, 64699 ], "mapped", [ 1593, 1605 ] ], [ [ 64700, 64700 ], "mapped", [ 1594, 1580 ] ], [ [ 64701, 64701 ], "mapped", [ 1594, 1605 ] ], [ [ 64702, 64702 ], "mapped", [ 1601, 1580 ] ], [ [ 64703, 64703 ], "mapped", [ 1601, 1581 ] ], [ [ 64704, 64704 ], "mapped", [ 1601, 1582 ] ], [ [ 64705, 64705 ], "mapped", [ 1601, 1605 ] ], [ [ 64706, 64706 ], "mapped", [ 1602, 1581 ] ], [ [ 64707, 64707 ], "mapped", [ 1602, 1605 ] ], [ [ 64708, 64708 ], "mapped", [ 1603, 1580 ] ], [ [ 64709, 64709 ], "mapped", [ 1603, 1581 ] ], [ [ 64710, 64710 ], "mapped", [ 1603, 1582 ] ], [ [ 64711, 64711 ], "mapped", [ 1603, 1604 ] ], [ [ 64712, 64712 ], "mapped", [ 1603, 1605 ] ], [ [ 64713, 64713 ], "mapped", [ 1604, 1580 ] ], [ [ 64714, 64714 ], "mapped", [ 1604, 1581 ] ], [ [ 64715, 64715 ], "mapped", [ 1604, 1582 ] ], [ [ 64716, 64716 ], "mapped", [ 1604, 1605 ] ], [ [ 64717, 64717 ], "mapped", [ 1604, 1607 ] ], [ [ 64718, 64718 ], "mapped", [ 1605, 1580 ] ], [ [ 64719, 64719 ], "mapped", [ 1605, 1581 ] ], [ [ 64720, 64720 ], "mapped", [ 1605, 1582 ] ], [ [ 64721, 64721 ], "mapped", [ 1605, 1605 ] ], [ [ 64722, 64722 ], "mapped", [ 1606, 1580 ] ], [ [ 64723, 64723 ], "mapped", [ 1606, 1581 ] ], [ [ 64724, 64724 ], "mapped", [ 1606, 1582 ] ], [ [ 64725, 64725 ], "mapped", [ 1606, 1605 ] ], [ [ 64726, 64726 ], "mapped", [ 1606, 1607 ] ], [ [ 64727, 64727 ], "mapped", [ 1607, 1580 ] ], [ [ 64728, 64728 ], "mapped", [ 1607, 1605 ] ], [ [ 64729, 64729 ], "mapped", [ 1607, 1648 ] ], [ [ 64730, 64730 ], "mapped", [ 1610, 1580 ] ], [ [ 64731, 64731 ], "mapped", [ 1610, 1581 ] ], [ [ 64732, 64732 ], "mapped", [ 1610, 1582 ] ], [ [ 64733, 64733 ], "mapped", [ 1610, 1605 ] ], [ [ 64734, 64734 ], "mapped", [ 1610, 1607 ] ], [ [ 64735, 64735 ], "mapped", [ 1574, 1605 ] ], [ [ 64736, 64736 ], "mapped", [ 1574, 1607 ] ], [ [ 64737, 64737 ], "mapped", [ 1576, 1605 ] ], [ [ 64738, 64738 ], "mapped", [ 1576, 1607 ] ], [ [ 64739, 64739 ], "mapped", [ 1578, 1605 ] ], [ [ 64740, 64740 ], "mapped", [ 1578, 1607 ] ], [ [ 64741, 64741 ], "mapped", [ 1579, 1605 ] ], [ [ 64742, 64742 ], "mapped", [ 1579, 1607 ] ], [ [ 64743, 64743 ], "mapped", [ 1587, 1605 ] ], [ [ 64744, 64744 ], "mapped", [ 1587, 1607 ] ], [ [ 64745, 64745 ], "mapped", [ 1588, 1605 ] ], [ [ 64746, 64746 ], "mapped", [ 1588, 1607 ] ], [ [ 64747, 64747 ], "mapped", [ 1603, 1604 ] ], [ [ 64748, 64748 ], "mapped", [ 1603, 1605 ] ], [ [ 64749, 64749 ], "mapped", [ 1604, 1605 ] ], [ [ 64750, 64750 ], "mapped", [ 1606, 1605 ] ], [ [ 64751, 64751 ], "mapped", [ 1606, 1607 ] ], [ [ 64752, 64752 ], "mapped", [ 1610, 1605 ] ], [ [ 64753, 64753 ], "mapped", [ 1610, 1607 ] ], [ [ 64754, 64754 ], "mapped", [ 1600, 1614, 1617 ] ], [ [ 64755, 64755 ], "mapped", [ 1600, 1615, 1617 ] ], [ [ 64756, 64756 ], "mapped", [ 1600, 1616, 1617 ] ], [ [ 64757, 64757 ], "mapped", [ 1591, 1609 ] ], [ [ 64758, 64758 ], "mapped", [ 1591, 1610 ] ], [ [ 64759, 64759 ], "mapped", [ 1593, 1609 ] ], [ [ 64760, 64760 ], "mapped", [ 1593, 1610 ] ], [ [ 64761, 64761 ], "mapped", [ 1594, 1609 ] ], [ [ 64762, 64762 ], "mapped", [ 1594, 1610 ] ], [ [ 64763, 64763 ], "mapped", [ 1587, 1609 ] ], [ [ 64764, 64764 ], "mapped", [ 1587, 1610 ] ], [ [ 64765, 64765 ], "mapped", [ 1588, 1609 ] ], [ [ 64766, 64766 ], "mapped", [ 1588, 1610 ] ], [ [ 64767, 64767 ], "mapped", [ 1581, 1609 ] ], [ [ 64768, 64768 ], "mapped", [ 1581, 1610 ] ], [ [ 64769, 64769 ], "mapped", [ 1580, 1609 ] ], [ [ 64770, 64770 ], "mapped", [ 1580, 1610 ] ], [ [ 64771, 64771 ], "mapped", [ 1582, 1609 ] ], [ [ 64772, 64772 ], "mapped", [ 1582, 1610 ] ], [ [ 64773, 64773 ], "mapped", [ 1589, 1609 ] ], [ [ 64774, 64774 ], "mapped", [ 1589, 1610 ] ], [ [ 64775, 64775 ], "mapped", [ 1590, 1609 ] ], [ [ 64776, 64776 ], "mapped", [ 1590, 1610 ] ], [ [ 64777, 64777 ], "mapped", [ 1588, 1580 ] ], [ [ 64778, 64778 ], "mapped", [ 1588, 1581 ] ], [ [ 64779, 64779 ], "mapped", [ 1588, 1582 ] ], [ [ 64780, 64780 ], "mapped", [ 1588, 1605 ] ], [ [ 64781, 64781 ], "mapped", [ 1588, 1585 ] ], [ [ 64782, 64782 ], "mapped", [ 1587, 1585 ] ], [ [ 64783, 64783 ], "mapped", [ 1589, 1585 ] ], [ [ 64784, 64784 ], "mapped", [ 1590, 1585 ] ], [ [ 64785, 64785 ], "mapped", [ 1591, 1609 ] ], [ [ 64786, 64786 ], "mapped", [ 1591, 1610 ] ], [ [ 64787, 64787 ], "mapped", [ 1593, 1609 ] ], [ [ 64788, 64788 ], "mapped", [ 1593, 1610 ] ], [ [ 64789, 64789 ], "mapped", [ 1594, 1609 ] ], [ [ 64790, 64790 ], "mapped", [ 1594, 1610 ] ], [ [ 64791, 64791 ], "mapped", [ 1587, 1609 ] ], [ [ 64792, 64792 ], "mapped", [ 1587, 1610 ] ], [ [ 64793, 64793 ], "mapped", [ 1588, 1609 ] ], [ [ 64794, 64794 ], "mapped", [ 1588, 1610 ] ], [ [ 64795, 64795 ], "mapped", [ 1581, 1609 ] ], [ [ 64796, 64796 ], "mapped", [ 1581, 1610 ] ], [ [ 64797, 64797 ], "mapped", [ 1580, 1609 ] ], [ [ 64798, 64798 ], "mapped", [ 1580, 1610 ] ], [ [ 64799, 64799 ], "mapped", [ 1582, 1609 ] ], [ [ 64800, 64800 ], "mapped", [ 1582, 1610 ] ], [ [ 64801, 64801 ], "mapped", [ 1589, 1609 ] ], [ [ 64802, 64802 ], "mapped", [ 1589, 1610 ] ], [ [ 64803, 64803 ], "mapped", [ 1590, 1609 ] ], [ [ 64804, 64804 ], "mapped", [ 1590, 1610 ] ], [ [ 64805, 64805 ], "mapped", [ 1588, 1580 ] ], [ [ 64806, 64806 ], "mapped", [ 1588, 1581 ] ], [ [ 64807, 64807 ], "mapped", [ 1588, 1582 ] ], [ [ 64808, 64808 ], "mapped", [ 1588, 1605 ] ], [ [ 64809, 64809 ], "mapped", [ 1588, 1585 ] ], [ [ 64810, 64810 ], "mapped", [ 1587, 1585 ] ], [ [ 64811, 64811 ], "mapped", [ 1589, 1585 ] ], [ [ 64812, 64812 ], "mapped", [ 1590, 1585 ] ], [ [ 64813, 64813 ], "mapped", [ 1588, 1580 ] ], [ [ 64814, 64814 ], "mapped", [ 1588, 1581 ] ], [ [ 64815, 64815 ], "mapped", [ 1588, 1582 ] ], [ [ 64816, 64816 ], "mapped", [ 1588, 1605 ] ], [ [ 64817, 64817 ], "mapped", [ 1587, 1607 ] ], [ [ 64818, 64818 ], "mapped", [ 1588, 1607 ] ], [ [ 64819, 64819 ], "mapped", [ 1591, 1605 ] ], [ [ 64820, 64820 ], "mapped", [ 1587, 1580 ] ], [ [ 64821, 64821 ], "mapped", [ 1587, 1581 ] ], [ [ 64822, 64822 ], "mapped", [ 1587, 1582 ] ], [ [ 64823, 64823 ], "mapped", [ 1588, 1580 ] ], [ [ 64824, 64824 ], "mapped", [ 1588, 1581 ] ], [ [ 64825, 64825 ], "mapped", [ 1588, 1582 ] ], [ [ 64826, 64826 ], "mapped", [ 1591, 1605 ] ], [ [ 64827, 64827 ], "mapped", [ 1592, 1605 ] ], [ [ 64828, 64829 ], "mapped", [ 1575, 1611 ] ], [ [ 64830, 64831 ], "valid", [], "NV8" ], [ [ 64832, 64847 ], "disallowed" ], [ [ 64848, 64848 ], "mapped", [ 1578, 1580, 1605 ] ], [ [ 64849, 64850 ], "mapped", [ 1578, 1581, 1580 ] ], [ [ 64851, 64851 ], "mapped", [ 1578, 1581, 1605 ] ], [ [ 64852, 64852 ], "mapped", [ 1578, 1582, 1605 ] ], [ [ 64853, 64853 ], "mapped", [ 1578, 1605, 1580 ] ], [ [ 64854, 64854 ], "mapped", [ 1578, 1605, 1581 ] ], [ [ 64855, 64855 ], "mapped", [ 1578, 1605, 1582 ] ], [ [ 64856, 64857 ], "mapped", [ 1580, 1605, 1581 ] ], [ [ 64858, 64858 ], "mapped", [ 1581, 1605, 1610 ] ], [ [ 64859, 64859 ], "mapped", [ 1581, 1605, 1609 ] ], [ [ 64860, 64860 ], "mapped", [ 1587, 1581, 1580 ] ], [ [ 64861, 64861 ], "mapped", [ 1587, 1580, 1581 ] ], [ [ 64862, 64862 ], "mapped", [ 1587, 1580, 1609 ] ], [ [ 64863, 64864 ], "mapped", [ 1587, 1605, 1581 ] ], [ [ 64865, 64865 ], "mapped", [ 1587, 1605, 1580 ] ], [ [ 64866, 64867 ], "mapped", [ 1587, 1605, 1605 ] ], [ [ 64868, 64869 ], "mapped", [ 1589, 1581, 1581 ] ], [ [ 64870, 64870 ], "mapped", [ 1589, 1605, 1605 ] ], [ [ 64871, 64872 ], "mapped", [ 1588, 1581, 1605 ] ], [ [ 64873, 64873 ], "mapped", [ 1588, 1580, 1610 ] ], [ [ 64874, 64875 ], "mapped", [ 1588, 1605, 1582 ] ], [ [ 64876, 64877 ], "mapped", [ 1588, 1605, 1605 ] ], [ [ 64878, 64878 ], "mapped", [ 1590, 1581, 1609 ] ], [ [ 64879, 64880 ], "mapped", [ 1590, 1582, 1605 ] ], [ [ 64881, 64882 ], "mapped", [ 1591, 1605, 1581 ] ], [ [ 64883, 64883 ], "mapped", [ 1591, 1605, 1605 ] ], [ [ 64884, 64884 ], "mapped", [ 1591, 1605, 1610 ] ], [ [ 64885, 64885 ], "mapped", [ 1593, 1580, 1605 ] ], [ [ 64886, 64887 ], "mapped", [ 1593, 1605, 1605 ] ], [ [ 64888, 64888 ], "mapped", [ 1593, 1605, 1609 ] ], [ [ 64889, 64889 ], "mapped", [ 1594, 1605, 1605 ] ], [ [ 64890, 64890 ], "mapped", [ 1594, 1605, 1610 ] ], [ [ 64891, 64891 ], "mapped", [ 1594, 1605, 1609 ] ], [ [ 64892, 64893 ], "mapped", [ 1601, 1582, 1605 ] ], [ [ 64894, 64894 ], "mapped", [ 1602, 1605, 1581 ] ], [ [ 64895, 64895 ], "mapped", [ 1602, 1605, 1605 ] ], [ [ 64896, 64896 ], "mapped", [ 1604, 1581, 1605 ] ], [ [ 64897, 64897 ], "mapped", [ 1604, 1581, 1610 ] ], [ [ 64898, 64898 ], "mapped", [ 1604, 1581, 1609 ] ], [ [ 64899, 64900 ], "mapped", [ 1604, 1580, 1580 ] ], [ [ 64901, 64902 ], "mapped", [ 1604, 1582, 1605 ] ], [ [ 64903, 64904 ], "mapped", [ 1604, 1605, 1581 ] ], [ [ 64905, 64905 ], "mapped", [ 1605, 1581, 1580 ] ], [ [ 64906, 64906 ], "mapped", [ 1605, 1581, 1605 ] ], [ [ 64907, 64907 ], "mapped", [ 1605, 1581, 1610 ] ], [ [ 64908, 64908 ], "mapped", [ 1605, 1580, 1581 ] ], [ [ 64909, 64909 ], "mapped", [ 1605, 1580, 1605 ] ], [ [ 64910, 64910 ], "mapped", [ 1605, 1582, 1580 ] ], [ [ 64911, 64911 ], "mapped", [ 1605, 1582, 1605 ] ], [ [ 64912, 64913 ], "disallowed" ], [ [ 64914, 64914 ], "mapped", [ 1605, 1580, 1582 ] ], [ [ 64915, 64915 ], "mapped", [ 1607, 1605, 1580 ] ], [ [ 64916, 64916 ], "mapped", [ 1607, 1605, 1605 ] ], [ [ 64917, 64917 ], "mapped", [ 1606, 1581, 1605 ] ], [ [ 64918, 64918 ], "mapped", [ 1606, 1581, 1609 ] ], [ [ 64919, 64920 ], "mapped", [ 1606, 1580, 1605 ] ], [ [ 64921, 64921 ], "mapped", [ 1606, 1580, 1609 ] ], [ [ 64922, 64922 ], "mapped", [ 1606, 1605, 1610 ] ], [ [ 64923, 64923 ], "mapped", [ 1606, 1605, 1609 ] ], [ [ 64924, 64925 ], "mapped", [ 1610, 1605, 1605 ] ], [ [ 64926, 64926 ], "mapped", [ 1576, 1582, 1610 ] ], [ [ 64927, 64927 ], "mapped", [ 1578, 1580, 1610 ] ], [ [ 64928, 64928 ], "mapped", [ 1578, 1580, 1609 ] ], [ [ 64929, 64929 ], "mapped", [ 1578, 1582, 1610 ] ], [ [ 64930, 64930 ], "mapped", [ 1578, 1582, 1609 ] ], [ [ 64931, 64931 ], "mapped", [ 1578, 1605, 1610 ] ], [ [ 64932, 64932 ], "mapped", [ 1578, 1605, 1609 ] ], [ [ 64933, 64933 ], "mapped", [ 1580, 1605, 1610 ] ], [ [ 64934, 64934 ], "mapped", [ 1580, 1581, 1609 ] ], [ [ 64935, 64935 ], "mapped", [ 1580, 1605, 1609 ] ], [ [ 64936, 64936 ], "mapped", [ 1587, 1582, 1609 ] ], [ [ 64937, 64937 ], "mapped", [ 1589, 1581, 1610 ] ], [ [ 64938, 64938 ], "mapped", [ 1588, 1581, 1610 ] ], [ [ 64939, 64939 ], "mapped", [ 1590, 1581, 1610 ] ], [ [ 64940, 64940 ], "mapped", [ 1604, 1580, 1610 ] ], [ [ 64941, 64941 ], "mapped", [ 1604, 1605, 1610 ] ], [ [ 64942, 64942 ], "mapped", [ 1610, 1581, 1610 ] ], [ [ 64943, 64943 ], "mapped", [ 1610, 1580, 1610 ] ], [ [ 64944, 64944 ], "mapped", [ 1610, 1605, 1610 ] ], [ [ 64945, 64945 ], "mapped", [ 1605, 1605, 1610 ] ], [ [ 64946, 64946 ], "mapped", [ 1602, 1605, 1610 ] ], [ [ 64947, 64947 ], "mapped", [ 1606, 1581, 1610 ] ], [ [ 64948, 64948 ], "mapped", [ 1602, 1605, 1581 ] ], [ [ 64949, 64949 ], "mapped", [ 1604, 1581, 1605 ] ], [ [ 64950, 64950 ], "mapped", [ 1593, 1605, 1610 ] ], [ [ 64951, 64951 ], "mapped", [ 1603, 1605, 1610 ] ], [ [ 64952, 64952 ], "mapped", [ 1606, 1580, 1581 ] ], [ [ 64953, 64953 ], "mapped", [ 1605, 1582, 1610 ] ], [ [ 64954, 64954 ], "mapped", [ 1604, 1580, 1605 ] ], [ [ 64955, 64955 ], "mapped", [ 1603, 1605, 1605 ] ], [ [ 64956, 64956 ], "mapped", [ 1604, 1580, 1605 ] ], [ [ 64957, 64957 ], "mapped", [ 1606, 1580, 1581 ] ], [ [ 64958, 64958 ], "mapped", [ 1580, 1581, 1610 ] ], [ [ 64959, 64959 ], "mapped", [ 1581, 1580, 1610 ] ], [ [ 64960, 64960 ], "mapped", [ 1605, 1580, 1610 ] ], [ [ 64961, 64961 ], "mapped", [ 1601, 1605, 1610 ] ], [ [ 64962, 64962 ], "mapped", [ 1576, 1581, 1610 ] ], [ [ 64963, 64963 ], "mapped", [ 1603, 1605, 1605 ] ], [ [ 64964, 64964 ], "mapped", [ 1593, 1580, 1605 ] ], [ [ 64965, 64965 ], "mapped", [ 1589, 1605, 1605 ] ], [ [ 64966, 64966 ], "mapped", [ 1587, 1582, 1610 ] ], [ [ 64967, 64967 ], "mapped", [ 1606, 1580, 1610 ] ], [ [ 64968, 64975 ], "disallowed" ], [ [ 64976, 65007 ], "disallowed" ], [ [ 65008, 65008 ], "mapped", [ 1589, 1604, 1746 ] ], [ [ 65009, 65009 ], "mapped", [ 1602, 1604, 1746 ] ], [ [ 65010, 65010 ], "mapped", [ 1575, 1604, 1604, 1607 ] ], [ [ 65011, 65011 ], "mapped", [ 1575, 1603, 1576, 1585 ] ], [ [ 65012, 65012 ], "mapped", [ 1605, 1581, 1605, 1583 ] ], [ [ 65013, 65013 ], "mapped", [ 1589, 1604, 1593, 1605 ] ], [ [ 65014, 65014 ], "mapped", [ 1585, 1587, 1608, 1604 ] ], [ [ 65015, 65015 ], "mapped", [ 1593, 1604, 1610, 1607 ] ], [ [ 65016, 65016 ], "mapped", [ 1608, 1587, 1604, 1605 ] ], [ [ 65017, 65017 ], "mapped", [ 1589, 1604, 1609 ] ], [ [ 65018, 65018 ], "disallowed_STD3_mapped", [ 1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605 ] ], [ [ 65019, 65019 ], "disallowed_STD3_mapped", [ 1580, 1604, 32, 1580, 1604, 1575, 1604, 1607 ] ], [ [ 65020, 65020 ], "mapped", [ 1585, 1740, 1575, 1604 ] ], [ [ 65021, 65021 ], "valid", [], "NV8" ], [ [ 65022, 65023 ], "disallowed" ], [ [ 65024, 65039 ], "ignored" ], [ [ 65040, 65040 ], "disallowed_STD3_mapped", [ 44 ] ], [ [ 65041, 65041 ], "mapped", [ 12289 ] ], [ [ 65042, 65042 ], "disallowed" ], [ [ 65043, 65043 ], "disallowed_STD3_mapped", [ 58 ] ], [ [ 65044, 65044 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 65045, 65045 ], "disallowed_STD3_mapped", [ 33 ] ], [ [ 65046, 65046 ], "disallowed_STD3_mapped", [ 63 ] ], [ [ 65047, 65047 ], "mapped", [ 12310 ] ], [ [ 65048, 65048 ], "mapped", [ 12311 ] ], [ [ 65049, 65049 ], "disallowed" ], [ [ 65050, 65055 ], "disallowed" ], [ [ 65056, 65059 ], "valid" ], [ [ 65060, 65062 ], "valid" ], [ [ 65063, 65069 ], "valid" ], [ [ 65070, 65071 ], "valid" ], [ [ 65072, 65072 ], "disallowed" ], [ [ 65073, 65073 ], "mapped", [ 8212 ] ], [ [ 65074, 65074 ], "mapped", [ 8211 ] ], [ [ 65075, 65076 ], "disallowed_STD3_mapped", [ 95 ] ], [ [ 65077, 65077 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 65078, 65078 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 65079, 65079 ], "disallowed_STD3_mapped", [ 123 ] ], [ [ 65080, 65080 ], "disallowed_STD3_mapped", [ 125 ] ], [ [ 65081, 65081 ], "mapped", [ 12308 ] ], [ [ 65082, 65082 ], "mapped", [ 12309 ] ], [ [ 65083, 65083 ], "mapped", [ 12304 ] ], [ [ 65084, 65084 ], "mapped", [ 12305 ] ], [ [ 65085, 65085 ], "mapped", [ 12298 ] ], [ [ 65086, 65086 ], "mapped", [ 12299 ] ], [ [ 65087, 65087 ], "mapped", [ 12296 ] ], [ [ 65088, 65088 ], "mapped", [ 12297 ] ], [ [ 65089, 65089 ], "mapped", [ 12300 ] ], [ [ 65090, 65090 ], "mapped", [ 12301 ] ], [ [ 65091, 65091 ], "mapped", [ 12302 ] ], [ [ 65092, 65092 ], "mapped", [ 12303 ] ], [ [ 65093, 65094 ], "valid", [], "NV8" ], [ [ 65095, 65095 ], "disallowed_STD3_mapped", [ 91 ] ], [ [ 65096, 65096 ], "disallowed_STD3_mapped", [ 93 ] ], [ [ 65097, 65100 ], "disallowed_STD3_mapped", [ 32, 773 ] ], [ [ 65101, 65103 ], "disallowed_STD3_mapped", [ 95 ] ], [ [ 65104, 65104 ], "disallowed_STD3_mapped", [ 44 ] ], [ [ 65105, 65105 ], "mapped", [ 12289 ] ], [ [ 65106, 65106 ], "disallowed" ], [ [ 65107, 65107 ], "disallowed" ], [ [ 65108, 65108 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 65109, 65109 ], "disallowed_STD3_mapped", [ 58 ] ], [ [ 65110, 65110 ], "disallowed_STD3_mapped", [ 63 ] ], [ [ 65111, 65111 ], "disallowed_STD3_mapped", [ 33 ] ], [ [ 65112, 65112 ], "mapped", [ 8212 ] ], [ [ 65113, 65113 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 65114, 65114 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 65115, 65115 ], "disallowed_STD3_mapped", [ 123 ] ], [ [ 65116, 65116 ], "disallowed_STD3_mapped", [ 125 ] ], [ [ 65117, 65117 ], "mapped", [ 12308 ] ], [ [ 65118, 65118 ], "mapped", [ 12309 ] ], [ [ 65119, 65119 ], "disallowed_STD3_mapped", [ 35 ] ], [ [ 65120, 65120 ], "disallowed_STD3_mapped", [ 38 ] ], [ [ 65121, 65121 ], "disallowed_STD3_mapped", [ 42 ] ], [ [ 65122, 65122 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 65123, 65123 ], "mapped", [ 45 ] ], [ [ 65124, 65124 ], "disallowed_STD3_mapped", [ 60 ] ], [ [ 65125, 65125 ], "disallowed_STD3_mapped", [ 62 ] ], [ [ 65126, 65126 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 65127, 65127 ], "disallowed" ], [ [ 65128, 65128 ], "disallowed_STD3_mapped", [ 92 ] ], [ [ 65129, 65129 ], "disallowed_STD3_mapped", [ 36 ] ], [ [ 65130, 65130 ], "disallowed_STD3_mapped", [ 37 ] ], [ [ 65131, 65131 ], "disallowed_STD3_mapped", [ 64 ] ], [ [ 65132, 65135 ], "disallowed" ], [ [ 65136, 65136 ], "disallowed_STD3_mapped", [ 32, 1611 ] ], [ [ 65137, 65137 ], "mapped", [ 1600, 1611 ] ], [ [ 65138, 65138 ], "disallowed_STD3_mapped", [ 32, 1612 ] ], [ [ 65139, 65139 ], "valid" ], [ [ 65140, 65140 ], "disallowed_STD3_mapped", [ 32, 1613 ] ], [ [ 65141, 65141 ], "disallowed" ], [ [ 65142, 65142 ], "disallowed_STD3_mapped", [ 32, 1614 ] ], [ [ 65143, 65143 ], "mapped", [ 1600, 1614 ] ], [ [ 65144, 65144 ], "disallowed_STD3_mapped", [ 32, 1615 ] ], [ [ 65145, 65145 ], "mapped", [ 1600, 1615 ] ], [ [ 65146, 65146 ], "disallowed_STD3_mapped", [ 32, 1616 ] ], [ [ 65147, 65147 ], "mapped", [ 1600, 1616 ] ], [ [ 65148, 65148 ], "disallowed_STD3_mapped", [ 32, 1617 ] ], [ [ 65149, 65149 ], "mapped", [ 1600, 1617 ] ], [ [ 65150, 65150 ], "disallowed_STD3_mapped", [ 32, 1618 ] ], [ [ 65151, 65151 ], "mapped", [ 1600, 1618 ] ], [ [ 65152, 65152 ], "mapped", [ 1569 ] ], [ [ 65153, 65154 ], "mapped", [ 1570 ] ], [ [ 65155, 65156 ], "mapped", [ 1571 ] ], [ [ 65157, 65158 ], "mapped", [ 1572 ] ], [ [ 65159, 65160 ], "mapped", [ 1573 ] ], [ [ 65161, 65164 ], "mapped", [ 1574 ] ], [ [ 65165, 65166 ], "mapped", [ 1575 ] ], [ [ 65167, 65170 ], "mapped", [ 1576 ] ], [ [ 65171, 65172 ], "mapped", [ 1577 ] ], [ [ 65173, 65176 ], "mapped", [ 1578 ] ], [ [ 65177, 65180 ], "mapped", [ 1579 ] ], [ [ 65181, 65184 ], "mapped", [ 1580 ] ], [ [ 65185, 65188 ], "mapped", [ 1581 ] ], [ [ 65189, 65192 ], "mapped", [ 1582 ] ], [ [ 65193, 65194 ], "mapped", [ 1583 ] ], [ [ 65195, 65196 ], "mapped", [ 1584 ] ], [ [ 65197, 65198 ], "mapped", [ 1585 ] ], [ [ 65199, 65200 ], "mapped", [ 1586 ] ], [ [ 65201, 65204 ], "mapped", [ 1587 ] ], [ [ 65205, 65208 ], "mapped", [ 1588 ] ], [ [ 65209, 65212 ], "mapped", [ 1589 ] ], [ [ 65213, 65216 ], "mapped", [ 1590 ] ], [ [ 65217, 65220 ], "mapped", [ 1591 ] ], [ [ 65221, 65224 ], "mapped", [ 1592 ] ], [ [ 65225, 65228 ], "mapped", [ 1593 ] ], [ [ 65229, 65232 ], "mapped", [ 1594 ] ], [ [ 65233, 65236 ], "mapped", [ 1601 ] ], [ [ 65237, 65240 ], "mapped", [ 1602 ] ], [ [ 65241, 65244 ], "mapped", [ 1603 ] ], [ [ 65245, 65248 ], "mapped", [ 1604 ] ], [ [ 65249, 65252 ], "mapped", [ 1605 ] ], [ [ 65253, 65256 ], "mapped", [ 1606 ] ], [ [ 65257, 65260 ], "mapped", [ 1607 ] ], [ [ 65261, 65262 ], "mapped", [ 1608 ] ], [ [ 65263, 65264 ], "mapped", [ 1609 ] ], [ [ 65265, 65268 ], "mapped", [ 1610 ] ], [ [ 65269, 65270 ], "mapped", [ 1604, 1570 ] ], [ [ 65271, 65272 ], "mapped", [ 1604, 1571 ] ], [ [ 65273, 65274 ], "mapped", [ 1604, 1573 ] ], [ [ 65275, 65276 ], "mapped", [ 1604, 1575 ] ], [ [ 65277, 65278 ], "disallowed" ], [ [ 65279, 65279 ], "ignored" ], [ [ 65280, 65280 ], "disallowed" ], [ [ 65281, 65281 ], "disallowed_STD3_mapped", [ 33 ] ], [ [ 65282, 65282 ], "disallowed_STD3_mapped", [ 34 ] ], [ [ 65283, 65283 ], "disallowed_STD3_mapped", [ 35 ] ], [ [ 65284, 65284 ], "disallowed_STD3_mapped", [ 36 ] ], [ [ 65285, 65285 ], "disallowed_STD3_mapped", [ 37 ] ], [ [ 65286, 65286 ], "disallowed_STD3_mapped", [ 38 ] ], [ [ 65287, 65287 ], "disallowed_STD3_mapped", [ 39 ] ], [ [ 65288, 65288 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 65289, 65289 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 65290, 65290 ], "disallowed_STD3_mapped", [ 42 ] ], [ [ 65291, 65291 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 65292, 65292 ], "disallowed_STD3_mapped", [ 44 ] ], [ [ 65293, 65293 ], "mapped", [ 45 ] ], [ [ 65294, 65294 ], "mapped", [ 46 ] ], [ [ 65295, 65295 ], "disallowed_STD3_mapped", [ 47 ] ], [ [ 65296, 65296 ], "mapped", [ 48 ] ], [ [ 65297, 65297 ], "mapped", [ 49 ] ], [ [ 65298, 65298 ], "mapped", [ 50 ] ], [ [ 65299, 65299 ], "mapped", [ 51 ] ], [ [ 65300, 65300 ], "mapped", [ 52 ] ], [ [ 65301, 65301 ], "mapped", [ 53 ] ], [ [ 65302, 65302 ], "mapped", [ 54 ] ], [ [ 65303, 65303 ], "mapped", [ 55 ] ], [ [ 65304, 65304 ], "mapped", [ 56 ] ], [ [ 65305, 65305 ], "mapped", [ 57 ] ], [ [ 65306, 65306 ], "disallowed_STD3_mapped", [ 58 ] ], [ [ 65307, 65307 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 65308, 65308 ], "disallowed_STD3_mapped", [ 60 ] ], [ [ 65309, 65309 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 65310, 65310 ], "disallowed_STD3_mapped", [ 62 ] ], [ [ 65311, 65311 ], "disallowed_STD3_mapped", [ 63 ] ], [ [ 65312, 65312 ], "disallowed_STD3_mapped", [ 64 ] ], [ [ 65313, 65313 ], "mapped", [ 97 ] ], [ [ 65314, 65314 ], "mapped", [ 98 ] ], [ [ 65315, 65315 ], "mapped", [ 99 ] ], [ [ 65316, 65316 ], "mapped", [ 100 ] ], [ [ 65317, 65317 ], "mapped", [ 101 ] ], [ [ 65318, 65318 ], "mapped", [ 102 ] ], [ [ 65319, 65319 ], "mapped", [ 103 ] ], [ [ 65320, 65320 ], "mapped", [ 104 ] ], [ [ 65321, 65321 ], "mapped", [ 105 ] ], [ [ 65322, 65322 ], "mapped", [ 106 ] ], [ [ 65323, 65323 ], "mapped", [ 107 ] ], [ [ 65324, 65324 ], "mapped", [ 108 ] ], [ [ 65325, 65325 ], "mapped", [ 109 ] ], [ [ 65326, 65326 ], "mapped", [ 110 ] ], [ [ 65327, 65327 ], "mapped", [ 111 ] ], [ [ 65328, 65328 ], "mapped", [ 112 ] ], [ [ 65329, 65329 ], "mapped", [ 113 ] ], [ [ 65330, 65330 ], "mapped", [ 114 ] ], [ [ 65331, 65331 ], "mapped", [ 115 ] ], [ [ 65332, 65332 ], "mapped", [ 116 ] ], [ [ 65333, 65333 ], "mapped", [ 117 ] ], [ [ 65334, 65334 ], "mapped", [ 118 ] ], [ [ 65335, 65335 ], "mapped", [ 119 ] ], [ [ 65336, 65336 ], "mapped", [ 120 ] ], [ [ 65337, 65337 ], "mapped", [ 121 ] ], [ [ 65338, 65338 ], "mapped", [ 122 ] ], [ [ 65339, 65339 ], "disallowed_STD3_mapped", [ 91 ] ], [ [ 65340, 65340 ], "disallowed_STD3_mapped", [ 92 ] ], [ [ 65341, 65341 ], "disallowed_STD3_mapped", [ 93 ] ], [ [ 65342, 65342 ], "disallowed_STD3_mapped", [ 94 ] ], [ [ 65343, 65343 ], "disallowed_STD3_mapped", [ 95 ] ], [ [ 65344, 65344 ], "disallowed_STD3_mapped", [ 96 ] ], [ [ 65345, 65345 ], "mapped", [ 97 ] ], [ [ 65346, 65346 ], "mapped", [ 98 ] ], [ [ 65347, 65347 ], "mapped", [ 99 ] ], [ [ 65348, 65348 ], "mapped", [ 100 ] ], [ [ 65349, 65349 ], "mapped", [ 101 ] ], [ [ 65350, 65350 ], "mapped", [ 102 ] ], [ [ 65351, 65351 ], "mapped", [ 103 ] ], [ [ 65352, 65352 ], "mapped", [ 104 ] ], [ [ 65353, 65353 ], "mapped", [ 105 ] ], [ [ 65354, 65354 ], "mapped", [ 106 ] ], [ [ 65355, 65355 ], "mapped", [ 107 ] ], [ [ 65356, 65356 ], "mapped", [ 108 ] ], [ [ 65357, 65357 ], "mapped", [ 109 ] ], [ [ 65358, 65358 ], "mapped", [ 110 ] ], [ [ 65359, 65359 ], "mapped", [ 111 ] ], [ [ 65360, 65360 ], "mapped", [ 112 ] ], [ [ 65361, 65361 ], "mapped", [ 113 ] ], [ [ 65362, 65362 ], "mapped", [ 114 ] ], [ [ 65363, 65363 ], "mapped", [ 115 ] ], [ [ 65364, 65364 ], "mapped", [ 116 ] ], [ [ 65365, 65365 ], "mapped", [ 117 ] ], [ [ 65366, 65366 ], "mapped", [ 118 ] ], [ [ 65367, 65367 ], "mapped", [ 119 ] ], [ [ 65368, 65368 ], "mapped", [ 120 ] ], [ [ 65369, 65369 ], "mapped", [ 121 ] ], [ [ 65370, 65370 ], "mapped", [ 122 ] ], [ [ 65371, 65371 ], "disallowed_STD3_mapped", [ 123 ] ], [ [ 65372, 65372 ], "disallowed_STD3_mapped", [ 124 ] ], [ [ 65373, 65373 ], "disallowed_STD3_mapped", [ 125 ] ], [ [ 65374, 65374 ], "disallowed_STD3_mapped", [ 126 ] ], [ [ 65375, 65375 ], "mapped", [ 10629 ] ], [ [ 65376, 65376 ], "mapped", [ 10630 ] ], [ [ 65377, 65377 ], "mapped", [ 46 ] ], [ [ 65378, 65378 ], "mapped", [ 12300 ] ], [ [ 65379, 65379 ], "mapped", [ 12301 ] ], [ [ 65380, 65380 ], "mapped", [ 12289 ] ], [ [ 65381, 65381 ], "mapped", [ 12539 ] ], [ [ 65382, 65382 ], "mapped", [ 12530 ] ], [ [ 65383, 65383 ], "mapped", [ 12449 ] ], [ [ 65384, 65384 ], "mapped", [ 12451 ] ], [ [ 65385, 65385 ], "mapped", [ 12453 ] ], [ [ 65386, 65386 ], "mapped", [ 12455 ] ], [ [ 65387, 65387 ], "mapped", [ 12457 ] ], [ [ 65388, 65388 ], "mapped", [ 12515 ] ], [ [ 65389, 65389 ], "mapped", [ 12517 ] ], [ [ 65390, 65390 ], "mapped", [ 12519 ] ], [ [ 65391, 65391 ], "mapped", [ 12483 ] ], [ [ 65392, 65392 ], "mapped", [ 12540 ] ], [ [ 65393, 65393 ], "mapped", [ 12450 ] ], [ [ 65394, 65394 ], "mapped", [ 12452 ] ], [ [ 65395, 65395 ], "mapped", [ 12454 ] ], [ [ 65396, 65396 ], "mapped", [ 12456 ] ], [ [ 65397, 65397 ], "mapped", [ 12458 ] ], [ [ 65398, 65398 ], "mapped", [ 12459 ] ], [ [ 65399, 65399 ], "mapped", [ 12461 ] ], [ [ 65400, 65400 ], "mapped", [ 12463 ] ], [ [ 65401, 65401 ], "mapped", [ 12465 ] ], [ [ 65402, 65402 ], "mapped", [ 12467 ] ], [ [ 65403, 65403 ], "mapped", [ 12469 ] ], [ [ 65404, 65404 ], "mapped", [ 12471 ] ], [ [ 65405, 65405 ], "mapped", [ 12473 ] ], [ [ 65406, 65406 ], "mapped", [ 12475 ] ], [ [ 65407, 65407 ], "mapped", [ 12477 ] ], [ [ 65408, 65408 ], "mapped", [ 12479 ] ], [ [ 65409, 65409 ], "mapped", [ 12481 ] ], [ [ 65410, 65410 ], "mapped", [ 12484 ] ], [ [ 65411, 65411 ], "mapped", [ 12486 ] ], [ [ 65412, 65412 ], "mapped", [ 12488 ] ], [ [ 65413, 65413 ], "mapped", [ 12490 ] ], [ [ 65414, 65414 ], "mapped", [ 12491 ] ], [ [ 65415, 65415 ], "mapped", [ 12492 ] ], [ [ 65416, 65416 ], "mapped", [ 12493 ] ], [ [ 65417, 65417 ], "mapped", [ 12494 ] ], [ [ 65418, 65418 ], "mapped", [ 12495 ] ], [ [ 65419, 65419 ], "mapped", [ 12498 ] ], [ [ 65420, 65420 ], "mapped", [ 12501 ] ], [ [ 65421, 65421 ], "mapped", [ 12504 ] ], [ [ 65422, 65422 ], "mapped", [ 12507 ] ], [ [ 65423, 65423 ], "mapped", [ 12510 ] ], [ [ 65424, 65424 ], "mapped", [ 12511 ] ], [ [ 65425, 65425 ], "mapped", [ 12512 ] ], [ [ 65426, 65426 ], "mapped", [ 12513 ] ], [ [ 65427, 65427 ], "mapped", [ 12514 ] ], [ [ 65428, 65428 ], "mapped", [ 12516 ] ], [ [ 65429, 65429 ], "mapped", [ 12518 ] ], [ [ 65430, 65430 ], "mapped", [ 12520 ] ], [ [ 65431, 65431 ], "mapped", [ 12521 ] ], [ [ 65432, 65432 ], "mapped", [ 12522 ] ], [ [ 65433, 65433 ], "mapped", [ 12523 ] ], [ [ 65434, 65434 ], "mapped", [ 12524 ] ], [ [ 65435, 65435 ], "mapped", [ 12525 ] ], [ [ 65436, 65436 ], "mapped", [ 12527 ] ], [ [ 65437, 65437 ], "mapped", [ 12531 ] ], [ [ 65438, 65438 ], "mapped", [ 12441 ] ], [ [ 65439, 65439 ], "mapped", [ 12442 ] ], [ [ 65440, 65440 ], "disallowed" ], [ [ 65441, 65441 ], "mapped", [ 4352 ] ], [ [ 65442, 65442 ], "mapped", [ 4353 ] ], [ [ 65443, 65443 ], "mapped", [ 4522 ] ], [ [ 65444, 65444 ], "mapped", [ 4354 ] ], [ [ 65445, 65445 ], "mapped", [ 4524 ] ], [ [ 65446, 65446 ], "mapped", [ 4525 ] ], [ [ 65447, 65447 ], "mapped", [ 4355 ] ], [ [ 65448, 65448 ], "mapped", [ 4356 ] ], [ [ 65449, 65449 ], "mapped", [ 4357 ] ], [ [ 65450, 65450 ], "mapped", [ 4528 ] ], [ [ 65451, 65451 ], "mapped", [ 4529 ] ], [ [ 65452, 65452 ], "mapped", [ 4530 ] ], [ [ 65453, 65453 ], "mapped", [ 4531 ] ], [ [ 65454, 65454 ], "mapped", [ 4532 ] ], [ [ 65455, 65455 ], "mapped", [ 4533 ] ], [ [ 65456, 65456 ], "mapped", [ 4378 ] ], [ [ 65457, 65457 ], "mapped", [ 4358 ] ], [ [ 65458, 65458 ], "mapped", [ 4359 ] ], [ [ 65459, 65459 ], "mapped", [ 4360 ] ], [ [ 65460, 65460 ], "mapped", [ 4385 ] ], [ [ 65461, 65461 ], "mapped", [ 4361 ] ], [ [ 65462, 65462 ], "mapped", [ 4362 ] ], [ [ 65463, 65463 ], "mapped", [ 4363 ] ], [ [ 65464, 65464 ], "mapped", [ 4364 ] ], [ [ 65465, 65465 ], "mapped", [ 4365 ] ], [ [ 65466, 65466 ], "mapped", [ 4366 ] ], [ [ 65467, 65467 ], "mapped", [ 4367 ] ], [ [ 65468, 65468 ], "mapped", [ 4368 ] ], [ [ 65469, 65469 ], "mapped", [ 4369 ] ], [ [ 65470, 65470 ], "mapped", [ 4370 ] ], [ [ 65471, 65473 ], "disallowed" ], [ [ 65474, 65474 ], "mapped", [ 4449 ] ], [ [ 65475, 65475 ], "mapped", [ 4450 ] ], [ [ 65476, 65476 ], "mapped", [ 4451 ] ], [ [ 65477, 65477 ], "mapped", [ 4452 ] ], [ [ 65478, 65478 ], "mapped", [ 4453 ] ], [ [ 65479, 65479 ], "mapped", [ 4454 ] ], [ [ 65480, 65481 ], "disallowed" ], [ [ 65482, 65482 ], "mapped", [ 4455 ] ], [ [ 65483, 65483 ], "mapped", [ 4456 ] ], [ [ 65484, 65484 ], "mapped", [ 4457 ] ], [ [ 65485, 65485 ], "mapped", [ 4458 ] ], [ [ 65486, 65486 ], "mapped", [ 4459 ] ], [ [ 65487, 65487 ], "mapped", [ 4460 ] ], [ [ 65488, 65489 ], "disallowed" ], [ [ 65490, 65490 ], "mapped", [ 4461 ] ], [ [ 65491, 65491 ], "mapped", [ 4462 ] ], [ [ 65492, 65492 ], "mapped", [ 4463 ] ], [ [ 65493, 65493 ], "mapped", [ 4464 ] ], [ [ 65494, 65494 ], "mapped", [ 4465 ] ], [ [ 65495, 65495 ], "mapped", [ 4466 ] ], [ [ 65496, 65497 ], "disallowed" ], [ [ 65498, 65498 ], "mapped", [ 4467 ] ], [ [ 65499, 65499 ], "mapped", [ 4468 ] ], [ [ 65500, 65500 ], "mapped", [ 4469 ] ], [ [ 65501, 65503 ], "disallowed" ], [ [ 65504, 65504 ], "mapped", [ 162 ] ], [ [ 65505, 65505 ], "mapped", [ 163 ] ], [ [ 65506, 65506 ], "mapped", [ 172 ] ], [ [ 65507, 65507 ], "disallowed_STD3_mapped", [ 32, 772 ] ], [ [ 65508, 65508 ], "mapped", [ 166 ] ], [ [ 65509, 65509 ], "mapped", [ 165 ] ], [ [ 65510, 65510 ], "mapped", [ 8361 ] ], [ [ 65511, 65511 ], "disallowed" ], [ [ 65512, 65512 ], "mapped", [ 9474 ] ], [ [ 65513, 65513 ], "mapped", [ 8592 ] ], [ [ 65514, 65514 ], "mapped", [ 8593 ] ], [ [ 65515, 65515 ], "mapped", [ 8594 ] ], [ [ 65516, 65516 ], "mapped", [ 8595 ] ], [ [ 65517, 65517 ], "mapped", [ 9632 ] ], [ [ 65518, 65518 ], "mapped", [ 9675 ] ], [ [ 65519, 65528 ], "disallowed" ], [ [ 65529, 65531 ], "disallowed" ], [ [ 65532, 65532 ], "disallowed" ], [ [ 65533, 65533 ], "disallowed" ], [ [ 65534, 65535 ], "disallowed" ], [ [ 65536, 65547 ], "valid" ], [ [ 65548, 65548 ], "disallowed" ], [ [ 65549, 65574 ], "valid" ], [ [ 65575, 65575 ], "disallowed" ], [ [ 65576, 65594 ], "valid" ], [ [ 65595, 65595 ], "disallowed" ], [ [ 65596, 65597 ], "valid" ], [ [ 65598, 65598 ], "disallowed" ], [ [ 65599, 65613 ], "valid" ], [ [ 65614, 65615 ], "disallowed" ], [ [ 65616, 65629 ], "valid" ], [ [ 65630, 65663 ], "disallowed" ], [ [ 65664, 65786 ], "valid" ], [ [ 65787, 65791 ], "disallowed" ], [ [ 65792, 65794 ], "valid", [], "NV8" ], [ [ 65795, 65798 ], "disallowed" ], [ [ 65799, 65843 ], "valid", [], "NV8" ], [ [ 65844, 65846 ], "disallowed" ], [ [ 65847, 65855 ], "valid", [], "NV8" ], [ [ 65856, 65930 ], "valid", [], "NV8" ], [ [ 65931, 65932 ], "valid", [], "NV8" ], [ [ 65933, 65935 ], "disallowed" ], [ [ 65936, 65947 ], "valid", [], "NV8" ], [ [ 65948, 65951 ], "disallowed" ], [ [ 65952, 65952 ], "valid", [], "NV8" ], [ [ 65953, 65999 ], "disallowed" ], [ [ 66e3, 66044 ], "valid", [], "NV8" ], [ [ 66045, 66045 ], "valid" ], [ [ 66046, 66175 ], "disallowed" ], [ [ 66176, 66204 ], "valid" ], [ [ 66205, 66207 ], "disallowed" ], [ [ 66208, 66256 ], "valid" ], [ [ 66257, 66271 ], "disallowed" ], [ [ 66272, 66272 ], "valid" ], [ [ 66273, 66299 ], "valid", [], "NV8" ], [ [ 66300, 66303 ], "disallowed" ], [ [ 66304, 66334 ], "valid" ], [ [ 66335, 66335 ], "valid" ], [ [ 66336, 66339 ], "valid", [], "NV8" ], [ [ 66340, 66351 ], "disallowed" ], [ [ 66352, 66368 ], "valid" ], [ [ 66369, 66369 ], "valid", [], "NV8" ], [ [ 66370, 66377 ], "valid" ], [ [ 66378, 66378 ], "valid", [], "NV8" ], [ [ 66379, 66383 ], "disallowed" ], [ [ 66384, 66426 ], "valid" ], [ [ 66427, 66431 ], "disallowed" ], [ [ 66432, 66461 ], "valid" ], [ [ 66462, 66462 ], "disallowed" ], [ [ 66463, 66463 ], "valid", [], "NV8" ], [ [ 66464, 66499 ], "valid" ], [ [ 66500, 66503 ], "disallowed" ], [ [ 66504, 66511 ], "valid" ], [ [ 66512, 66517 ], "valid", [], "NV8" ], [ [ 66518, 66559 ], "disallowed" ], [ [ 66560, 66560 ], "mapped", [ 66600 ] ], [ [ 66561, 66561 ], "mapped", [ 66601 ] ], [ [ 66562, 66562 ], "mapped", [ 66602 ] ], [ [ 66563, 66563 ], "mapped", [ 66603 ] ], [ [ 66564, 66564 ], "mapped", [ 66604 ] ], [ [ 66565, 66565 ], "mapped", [ 66605 ] ], [ [ 66566, 66566 ], "mapped", [ 66606 ] ], [ [ 66567, 66567 ], "mapped", [ 66607 ] ], [ [ 66568, 66568 ], "mapped", [ 66608 ] ], [ [ 66569, 66569 ], "mapped", [ 66609 ] ], [ [ 66570, 66570 ], "mapped", [ 66610 ] ], [ [ 66571, 66571 ], "mapped", [ 66611 ] ], [ [ 66572, 66572 ], "mapped", [ 66612 ] ], [ [ 66573, 66573 ], "mapped", [ 66613 ] ], [ [ 66574, 66574 ], "mapped", [ 66614 ] ], [ [ 66575, 66575 ], "mapped", [ 66615 ] ], [ [ 66576, 66576 ], "mapped", [ 66616 ] ], [ [ 66577, 66577 ], "mapped", [ 66617 ] ], [ [ 66578, 66578 ], "mapped", [ 66618 ] ], [ [ 66579, 66579 ], "mapped", [ 66619 ] ], [ [ 66580, 66580 ], "mapped", [ 66620 ] ], [ [ 66581, 66581 ], "mapped", [ 66621 ] ], [ [ 66582, 66582 ], "mapped", [ 66622 ] ], [ [ 66583, 66583 ], "mapped", [ 66623 ] ], [ [ 66584, 66584 ], "mapped", [ 66624 ] ], [ [ 66585, 66585 ], "mapped", [ 66625 ] ], [ [ 66586, 66586 ], "mapped", [ 66626 ] ], [ [ 66587, 66587 ], "mapped", [ 66627 ] ], [ [ 66588, 66588 ], "mapped", [ 66628 ] ], [ [ 66589, 66589 ], "mapped", [ 66629 ] ], [ [ 66590, 66590 ], "mapped", [ 66630 ] ], [ [ 66591, 66591 ], "mapped", [ 66631 ] ], [ [ 66592, 66592 ], "mapped", [ 66632 ] ], [ [ 66593, 66593 ], "mapped", [ 66633 ] ], [ [ 66594, 66594 ], "mapped", [ 66634 ] ], [ [ 66595, 66595 ], "mapped", [ 66635 ] ], [ [ 66596, 66596 ], "mapped", [ 66636 ] ], [ [ 66597, 66597 ], "mapped", [ 66637 ] ], [ [ 66598, 66598 ], "mapped", [ 66638 ] ], [ [ 66599, 66599 ], "mapped", [ 66639 ] ], [ [ 66600, 66637 ], "valid" ], [ [ 66638, 66717 ], "valid" ], [ [ 66718, 66719 ], "disallowed" ], [ [ 66720, 66729 ], "valid" ], [ [ 66730, 66815 ], "disallowed" ], [ [ 66816, 66855 ], "valid" ], [ [ 66856, 66863 ], "disallowed" ], [ [ 66864, 66915 ], "valid" ], [ [ 66916, 66926 ], "disallowed" ], [ [ 66927, 66927 ], "valid", [], "NV8" ], [ [ 66928, 67071 ], "disallowed" ], [ [ 67072, 67382 ], "valid" ], [ [ 67383, 67391 ], "disallowed" ], [ [ 67392, 67413 ], "valid" ], [ [ 67414, 67423 ], "disallowed" ], [ [ 67424, 67431 ], "valid" ], [ [ 67432, 67583 ], "disallowed" ], [ [ 67584, 67589 ], "valid" ], [ [ 67590, 67591 ], "disallowed" ], [ [ 67592, 67592 ], "valid" ], [ [ 67593, 67593 ], "disallowed" ], [ [ 67594, 67637 ], "valid" ], [ [ 67638, 67638 ], "disallowed" ], [ [ 67639, 67640 ], "valid" ], [ [ 67641, 67643 ], "disallowed" ], [ [ 67644, 67644 ], "valid" ], [ [ 67645, 67646 ], "disallowed" ], [ [ 67647, 67647 ], "valid" ], [ [ 67648, 67669 ], "valid" ], [ [ 67670, 67670 ], "disallowed" ], [ [ 67671, 67679 ], "valid", [], "NV8" ], [ [ 67680, 67702 ], "valid" ], [ [ 67703, 67711 ], "valid", [], "NV8" ], [ [ 67712, 67742 ], "valid" ], [ [ 67743, 67750 ], "disallowed" ], [ [ 67751, 67759 ], "valid", [], "NV8" ], [ [ 67760, 67807 ], "disallowed" ], [ [ 67808, 67826 ], "valid" ], [ [ 67827, 67827 ], "disallowed" ], [ [ 67828, 67829 ], "valid" ], [ [ 67830, 67834 ], "disallowed" ], [ [ 67835, 67839 ], "valid", [], "NV8" ], [ [ 67840, 67861 ], "valid" ], [ [ 67862, 67865 ], "valid", [], "NV8" ], [ [ 67866, 67867 ], "valid", [], "NV8" ], [ [ 67868, 67870 ], "disallowed" ], [ [ 67871, 67871 ], "valid", [], "NV8" ], [ [ 67872, 67897 ], "valid" ], [ [ 67898, 67902 ], "disallowed" ], [ [ 67903, 67903 ], "valid", [], "NV8" ], [ [ 67904, 67967 ], "disallowed" ], [ [ 67968, 68023 ], "valid" ], [ [ 68024, 68027 ], "disallowed" ], [ [ 68028, 68029 ], "valid", [], "NV8" ], [ [ 68030, 68031 ], "valid" ], [ [ 68032, 68047 ], "valid", [], "NV8" ], [ [ 68048, 68049 ], "disallowed" ], [ [ 68050, 68095 ], "valid", [], "NV8" ], [ [ 68096, 68099 ], "valid" ], [ [ 68100, 68100 ], "disallowed" ], [ [ 68101, 68102 ], "valid" ], [ [ 68103, 68107 ], "disallowed" ], [ [ 68108, 68115 ], "valid" ], [ [ 68116, 68116 ], "disallowed" ], [ [ 68117, 68119 ], "valid" ], [ [ 68120, 68120 ], "disallowed" ], [ [ 68121, 68147 ], "valid" ], [ [ 68148, 68151 ], "disallowed" ], [ [ 68152, 68154 ], "valid" ], [ [ 68155, 68158 ], "disallowed" ], [ [ 68159, 68159 ], "valid" ], [ [ 68160, 68167 ], "valid", [], "NV8" ], [ [ 68168, 68175 ], "disallowed" ], [ [ 68176, 68184 ], "valid", [], "NV8" ], [ [ 68185, 68191 ], "disallowed" ], [ [ 68192, 68220 ], "valid" ], [ [ 68221, 68223 ], "valid", [], "NV8" ], [ [ 68224, 68252 ], "valid" ], [ [ 68253, 68255 ], "valid", [], "NV8" ], [ [ 68256, 68287 ], "disallowed" ], [ [ 68288, 68295 ], "valid" ], [ [ 68296, 68296 ], "valid", [], "NV8" ], [ [ 68297, 68326 ], "valid" ], [ [ 68327, 68330 ], "disallowed" ], [ [ 68331, 68342 ], "valid", [], "NV8" ], [ [ 68343, 68351 ], "disallowed" ], [ [ 68352, 68405 ], "valid" ], [ [ 68406, 68408 ], "disallowed" ], [ [ 68409, 68415 ], "valid", [], "NV8" ], [ [ 68416, 68437 ], "valid" ], [ [ 68438, 68439 ], "disallowed" ], [ [ 68440, 68447 ], "valid", [], "NV8" ], [ [ 68448, 68466 ], "valid" ], [ [ 68467, 68471 ], "disallowed" ], [ [ 68472, 68479 ], "valid", [], "NV8" ], [ [ 68480, 68497 ], "valid" ], [ [ 68498, 68504 ], "disallowed" ], [ [ 68505, 68508 ], "valid", [], "NV8" ], [ [ 68509, 68520 ], "disallowed" ], [ [ 68521, 68527 ], "valid", [], "NV8" ], [ [ 68528, 68607 ], "disallowed" ], [ [ 68608, 68680 ], "valid" ], [ [ 68681, 68735 ], "disallowed" ], [ [ 68736, 68736 ], "mapped", [ 68800 ] ], [ [ 68737, 68737 ], "mapped", [ 68801 ] ], [ [ 68738, 68738 ], "mapped", [ 68802 ] ], [ [ 68739, 68739 ], "mapped", [ 68803 ] ], [ [ 68740, 68740 ], "mapped", [ 68804 ] ], [ [ 68741, 68741 ], "mapped", [ 68805 ] ], [ [ 68742, 68742 ], "mapped", [ 68806 ] ], [ [ 68743, 68743 ], "mapped", [ 68807 ] ], [ [ 68744, 68744 ], "mapped", [ 68808 ] ], [ [ 68745, 68745 ], "mapped", [ 68809 ] ], [ [ 68746, 68746 ], "mapped", [ 68810 ] ], [ [ 68747, 68747 ], "mapped", [ 68811 ] ], [ [ 68748, 68748 ], "mapped", [ 68812 ] ], [ [ 68749, 68749 ], "mapped", [ 68813 ] ], [ [ 68750, 68750 ], "mapped", [ 68814 ] ], [ [ 68751, 68751 ], "mapped", [ 68815 ] ], [ [ 68752, 68752 ], "mapped", [ 68816 ] ], [ [ 68753, 68753 ], "mapped", [ 68817 ] ], [ [ 68754, 68754 ], "mapped", [ 68818 ] ], [ [ 68755, 68755 ], "mapped", [ 68819 ] ], [ [ 68756, 68756 ], "mapped", [ 68820 ] ], [ [ 68757, 68757 ], "mapped", [ 68821 ] ], [ [ 68758, 68758 ], "mapped", [ 68822 ] ], [ [ 68759, 68759 ], "mapped", [ 68823 ] ], [ [ 68760, 68760 ], "mapped", [ 68824 ] ], [ [ 68761, 68761 ], "mapped", [ 68825 ] ], [ [ 68762, 68762 ], "mapped", [ 68826 ] ], [ [ 68763, 68763 ], "mapped", [ 68827 ] ], [ [ 68764, 68764 ], "mapped", [ 68828 ] ], [ [ 68765, 68765 ], "mapped", [ 68829 ] ], [ [ 68766, 68766 ], "mapped", [ 68830 ] ], [ [ 68767, 68767 ], "mapped", [ 68831 ] ], [ [ 68768, 68768 ], "mapped", [ 68832 ] ], [ [ 68769, 68769 ], "mapped", [ 68833 ] ], [ [ 68770, 68770 ], "mapped", [ 68834 ] ], [ [ 68771, 68771 ], "mapped", [ 68835 ] ], [ [ 68772, 68772 ], "mapped", [ 68836 ] ], [ [ 68773, 68773 ], "mapped", [ 68837 ] ], [ [ 68774, 68774 ], "mapped", [ 68838 ] ], [ [ 68775, 68775 ], "mapped", [ 68839 ] ], [ [ 68776, 68776 ], "mapped", [ 68840 ] ], [ [ 68777, 68777 ], "mapped", [ 68841 ] ], [ [ 68778, 68778 ], "mapped", [ 68842 ] ], [ [ 68779, 68779 ], "mapped", [ 68843 ] ], [ [ 68780, 68780 ], "mapped", [ 68844 ] ], [ [ 68781, 68781 ], "mapped", [ 68845 ] ], [ [ 68782, 68782 ], "mapped", [ 68846 ] ], [ [ 68783, 68783 ], "mapped", [ 68847 ] ], [ [ 68784, 68784 ], "mapped", [ 68848 ] ], [ [ 68785, 68785 ], "mapped", [ 68849 ] ], [ [ 68786, 68786 ], "mapped", [ 68850 ] ], [ [ 68787, 68799 ], "disallowed" ], [ [ 68800, 68850 ], "valid" ], [ [ 68851, 68857 ], "disallowed" ], [ [ 68858, 68863 ], "valid", [], "NV8" ], [ [ 68864, 69215 ], "disallowed" ], [ [ 69216, 69246 ], "valid", [], "NV8" ], [ [ 69247, 69631 ], "disallowed" ], [ [ 69632, 69702 ], "valid" ], [ [ 69703, 69709 ], "valid", [], "NV8" ], [ [ 69710, 69713 ], "disallowed" ], [ [ 69714, 69733 ], "valid", [], "NV8" ], [ [ 69734, 69743 ], "valid" ], [ [ 69744, 69758 ], "disallowed" ], [ [ 69759, 69759 ], "valid" ], [ [ 69760, 69818 ], "valid" ], [ [ 69819, 69820 ], "valid", [], "NV8" ], [ [ 69821, 69821 ], "disallowed" ], [ [ 69822, 69825 ], "valid", [], "NV8" ], [ [ 69826, 69839 ], "disallowed" ], [ [ 69840, 69864 ], "valid" ], [ [ 69865, 69871 ], "disallowed" ], [ [ 69872, 69881 ], "valid" ], [ [ 69882, 69887 ], "disallowed" ], [ [ 69888, 69940 ], "valid" ], [ [ 69941, 69941 ], "disallowed" ], [ [ 69942, 69951 ], "valid" ], [ [ 69952, 69955 ], "valid", [], "NV8" ], [ [ 69956, 69967 ], "disallowed" ], [ [ 69968, 70003 ], "valid" ], [ [ 70004, 70005 ], "valid", [], "NV8" ], [ [ 70006, 70006 ], "valid" ], [ [ 70007, 70015 ], "disallowed" ], [ [ 70016, 70084 ], "valid" ], [ [ 70085, 70088 ], "valid", [], "NV8" ], [ [ 70089, 70089 ], "valid", [], "NV8" ], [ [ 70090, 70092 ], "valid" ], [ [ 70093, 70093 ], "valid", [], "NV8" ], [ [ 70094, 70095 ], "disallowed" ], [ [ 70096, 70105 ], "valid" ], [ [ 70106, 70106 ], "valid" ], [ [ 70107, 70107 ], "valid", [], "NV8" ], [ [ 70108, 70108 ], "valid" ], [ [ 70109, 70111 ], "valid", [], "NV8" ], [ [ 70112, 70112 ], "disallowed" ], [ [ 70113, 70132 ], "valid", [], "NV8" ], [ [ 70133, 70143 ], "disallowed" ], [ [ 70144, 70161 ], "valid" ], [ [ 70162, 70162 ], "disallowed" ], [ [ 70163, 70199 ], "valid" ], [ [ 70200, 70205 ], "valid", [], "NV8" ], [ [ 70206, 70271 ], "disallowed" ], [ [ 70272, 70278 ], "valid" ], [ [ 70279, 70279 ], "disallowed" ], [ [ 70280, 70280 ], "valid" ], [ [ 70281, 70281 ], "disallowed" ], [ [ 70282, 70285 ], "valid" ], [ [ 70286, 70286 ], "disallowed" ], [ [ 70287, 70301 ], "valid" ], [ [ 70302, 70302 ], "disallowed" ], [ [ 70303, 70312 ], "valid" ], [ [ 70313, 70313 ], "valid", [], "NV8" ], [ [ 70314, 70319 ], "disallowed" ], [ [ 70320, 70378 ], "valid" ], [ [ 70379, 70383 ], "disallowed" ], [ [ 70384, 70393 ], "valid" ], [ [ 70394, 70399 ], "disallowed" ], [ [ 70400, 70400 ], "valid" ], [ [ 70401, 70403 ], "valid" ], [ [ 70404, 70404 ], "disallowed" ], [ [ 70405, 70412 ], "valid" ], [ [ 70413, 70414 ], "disallowed" ], [ [ 70415, 70416 ], "valid" ], [ [ 70417, 70418 ], "disallowed" ], [ [ 70419, 70440 ], "valid" ], [ [ 70441, 70441 ], "disallowed" ], [ [ 70442, 70448 ], "valid" ], [ [ 70449, 70449 ], "disallowed" ], [ [ 70450, 70451 ], "valid" ], [ [ 70452, 70452 ], "disallowed" ], [ [ 70453, 70457 ], "valid" ], [ [ 70458, 70459 ], "disallowed" ], [ [ 70460, 70468 ], "valid" ], [ [ 70469, 70470 ], "disallowed" ], [ [ 70471, 70472 ], "valid" ], [ [ 70473, 70474 ], "disallowed" ], [ [ 70475, 70477 ], "valid" ], [ [ 70478, 70479 ], "disallowed" ], [ [ 70480, 70480 ], "valid" ], [ [ 70481, 70486 ], "disallowed" ], [ [ 70487, 70487 ], "valid" ], [ [ 70488, 70492 ], "disallowed" ], [ [ 70493, 70499 ], "valid" ], [ [ 70500, 70501 ], "disallowed" ], [ [ 70502, 70508 ], "valid" ], [ [ 70509, 70511 ], "disallowed" ], [ [ 70512, 70516 ], "valid" ], [ [ 70517, 70783 ], "disallowed" ], [ [ 70784, 70853 ], "valid" ], [ [ 70854, 70854 ], "valid", [], "NV8" ], [ [ 70855, 70855 ], "valid" ], [ [ 70856, 70863 ], "disallowed" ], [ [ 70864, 70873 ], "valid" ], [ [ 70874, 71039 ], "disallowed" ], [ [ 71040, 71093 ], "valid" ], [ [ 71094, 71095 ], "disallowed" ], [ [ 71096, 71104 ], "valid" ], [ [ 71105, 71113 ], "valid", [], "NV8" ], [ [ 71114, 71127 ], "valid", [], "NV8" ], [ [ 71128, 71133 ], "valid" ], [ [ 71134, 71167 ], "disallowed" ], [ [ 71168, 71232 ], "valid" ], [ [ 71233, 71235 ], "valid", [], "NV8" ], [ [ 71236, 71236 ], "valid" ], [ [ 71237, 71247 ], "disallowed" ], [ [ 71248, 71257 ], "valid" ], [ [ 71258, 71295 ], "disallowed" ], [ [ 71296, 71351 ], "valid" ], [ [ 71352, 71359 ], "disallowed" ], [ [ 71360, 71369 ], "valid" ], [ [ 71370, 71423 ], "disallowed" ], [ [ 71424, 71449 ], "valid" ], [ [ 71450, 71452 ], "disallowed" ], [ [ 71453, 71467 ], "valid" ], [ [ 71468, 71471 ], "disallowed" ], [ [ 71472, 71481 ], "valid" ], [ [ 71482, 71487 ], "valid", [], "NV8" ], [ [ 71488, 71839 ], "disallowed" ], [ [ 71840, 71840 ], "mapped", [ 71872 ] ], [ [ 71841, 71841 ], "mapped", [ 71873 ] ], [ [ 71842, 71842 ], "mapped", [ 71874 ] ], [ [ 71843, 71843 ], "mapped", [ 71875 ] ], [ [ 71844, 71844 ], "mapped", [ 71876 ] ], [ [ 71845, 71845 ], "mapped", [ 71877 ] ], [ [ 71846, 71846 ], "mapped", [ 71878 ] ], [ [ 71847, 71847 ], "mapped", [ 71879 ] ], [ [ 71848, 71848 ], "mapped", [ 71880 ] ], [ [ 71849, 71849 ], "mapped", [ 71881 ] ], [ [ 71850, 71850 ], "mapped", [ 71882 ] ], [ [ 71851, 71851 ], "mapped", [ 71883 ] ], [ [ 71852, 71852 ], "mapped", [ 71884 ] ], [ [ 71853, 71853 ], "mapped", [ 71885 ] ], [ [ 71854, 71854 ], "mapped", [ 71886 ] ], [ [ 71855, 71855 ], "mapped", [ 71887 ] ], [ [ 71856, 71856 ], "mapped", [ 71888 ] ], [ [ 71857, 71857 ], "mapped", [ 71889 ] ], [ [ 71858, 71858 ], "mapped", [ 71890 ] ], [ [ 71859, 71859 ], "mapped", [ 71891 ] ], [ [ 71860, 71860 ], "mapped", [ 71892 ] ], [ [ 71861, 71861 ], "mapped", [ 71893 ] ], [ [ 71862, 71862 ], "mapped", [ 71894 ] ], [ [ 71863, 71863 ], "mapped", [ 71895 ] ], [ [ 71864, 71864 ], "mapped", [ 71896 ] ], [ [ 71865, 71865 ], "mapped", [ 71897 ] ], [ [ 71866, 71866 ], "mapped", [ 71898 ] ], [ [ 71867, 71867 ], "mapped", [ 71899 ] ], [ [ 71868, 71868 ], "mapped", [ 71900 ] ], [ [ 71869, 71869 ], "mapped", [ 71901 ] ], [ [ 71870, 71870 ], "mapped", [ 71902 ] ], [ [ 71871, 71871 ], "mapped", [ 71903 ] ], [ [ 71872, 71913 ], "valid" ], [ [ 71914, 71922 ], "valid", [], "NV8" ], [ [ 71923, 71934 ], "disallowed" ], [ [ 71935, 71935 ], "valid" ], [ [ 71936, 72383 ], "disallowed" ], [ [ 72384, 72440 ], "valid" ], [ [ 72441, 73727 ], "disallowed" ], [ [ 73728, 74606 ], "valid" ], [ [ 74607, 74648 ], "valid" ], [ [ 74649, 74649 ], "valid" ], [ [ 74650, 74751 ], "disallowed" ], [ [ 74752, 74850 ], "valid", [], "NV8" ], [ [ 74851, 74862 ], "valid", [], "NV8" ], [ [ 74863, 74863 ], "disallowed" ], [ [ 74864, 74867 ], "valid", [], "NV8" ], [ [ 74868, 74868 ], "valid", [], "NV8" ], [ [ 74869, 74879 ], "disallowed" ], [ [ 74880, 75075 ], "valid" ], [ [ 75076, 77823 ], "disallowed" ], [ [ 77824, 78894 ], "valid" ], [ [ 78895, 82943 ], "disallowed" ], [ [ 82944, 83526 ], "valid" ], [ [ 83527, 92159 ], "disallowed" ], [ [ 92160, 92728 ], "valid" ], [ [ 92729, 92735 ], "disallowed" ], [ [ 92736, 92766 ], "valid" ], [ [ 92767, 92767 ], "disallowed" ], [ [ 92768, 92777 ], "valid" ], [ [ 92778, 92781 ], "disallowed" ], [ [ 92782, 92783 ], "valid", [], "NV8" ], [ [ 92784, 92879 ], "disallowed" ], [ [ 92880, 92909 ], "valid" ], [ [ 92910, 92911 ], "disallowed" ], [ [ 92912, 92916 ], "valid" ], [ [ 92917, 92917 ], "valid", [], "NV8" ], [ [ 92918, 92927 ], "disallowed" ], [ [ 92928, 92982 ], "valid" ], [ [ 92983, 92991 ], "valid", [], "NV8" ], [ [ 92992, 92995 ], "valid" ], [ [ 92996, 92997 ], "valid", [], "NV8" ], [ [ 92998, 93007 ], "disallowed" ], [ [ 93008, 93017 ], "valid" ], [ [ 93018, 93018 ], "disallowed" ], [ [ 93019, 93025 ], "valid", [], "NV8" ], [ [ 93026, 93026 ], "disallowed" ], [ [ 93027, 93047 ], "valid" ], [ [ 93048, 93052 ], "disallowed" ], [ [ 93053, 93071 ], "valid" ], [ [ 93072, 93951 ], "disallowed" ], [ [ 93952, 94020 ], "valid" ], [ [ 94021, 94031 ], "disallowed" ], [ [ 94032, 94078 ], "valid" ], [ [ 94079, 94094 ], "disallowed" ], [ [ 94095, 94111 ], "valid" ], [ [ 94112, 110591 ], "disallowed" ], [ [ 110592, 110593 ], "valid" ], [ [ 110594, 113663 ], "disallowed" ], [ [ 113664, 113770 ], "valid" ], [ [ 113771, 113775 ], "disallowed" ], [ [ 113776, 113788 ], "valid" ], [ [ 113789, 113791 ], "disallowed" ], [ [ 113792, 113800 ], "valid" ], [ [ 113801, 113807 ], "disallowed" ], [ [ 113808, 113817 ], "valid" ], [ [ 113818, 113819 ], "disallowed" ], [ [ 113820, 113820 ], "valid", [], "NV8" ], [ [ 113821, 113822 ], "valid" ], [ [ 113823, 113823 ], "valid", [], "NV8" ], [ [ 113824, 113827 ], "ignored" ], [ [ 113828, 118783 ], "disallowed" ], [ [ 118784, 119029 ], "valid", [], "NV8" ], [ [ 119030, 119039 ], "disallowed" ], [ [ 119040, 119078 ], "valid", [], "NV8" ], [ [ 119079, 119080 ], "disallowed" ], [ [ 119081, 119081 ], "valid", [], "NV8" ], [ [ 119082, 119133 ], "valid", [], "NV8" ], [ [ 119134, 119134 ], "mapped", [ 119127, 119141 ] ], [ [ 119135, 119135 ], "mapped", [ 119128, 119141 ] ], [ [ 119136, 119136 ], "mapped", [ 119128, 119141, 119150 ] ], [ [ 119137, 119137 ], "mapped", [ 119128, 119141, 119151 ] ], [ [ 119138, 119138 ], "mapped", [ 119128, 119141, 119152 ] ], [ [ 119139, 119139 ], "mapped", [ 119128, 119141, 119153 ] ], [ [ 119140, 119140 ], "mapped", [ 119128, 119141, 119154 ] ], [ [ 119141, 119154 ], "valid", [], "NV8" ], [ [ 119155, 119162 ], "disallowed" ], [ [ 119163, 119226 ], "valid", [], "NV8" ], [ [ 119227, 119227 ], "mapped", [ 119225, 119141 ] ], [ [ 119228, 119228 ], "mapped", [ 119226, 119141 ] ], [ [ 119229, 119229 ], "mapped", [ 119225, 119141, 119150 ] ], [ [ 119230, 119230 ], "mapped", [ 119226, 119141, 119150 ] ], [ [ 119231, 119231 ], "mapped", [ 119225, 119141, 119151 ] ], [ [ 119232, 119232 ], "mapped", [ 119226, 119141, 119151 ] ], [ [ 119233, 119261 ], "valid", [], "NV8" ], [ [ 119262, 119272 ], "valid", [], "NV8" ], [ [ 119273, 119295 ], "disallowed" ], [ [ 119296, 119365 ], "valid", [], "NV8" ], [ [ 119366, 119551 ], "disallowed" ], [ [ 119552, 119638 ], "valid", [], "NV8" ], [ [ 119639, 119647 ], "disallowed" ], [ [ 119648, 119665 ], "valid", [], "NV8" ], [ [ 119666, 119807 ], "disallowed" ], [ [ 119808, 119808 ], "mapped", [ 97 ] ], [ [ 119809, 119809 ], "mapped", [ 98 ] ], [ [ 119810, 119810 ], "mapped", [ 99 ] ], [ [ 119811, 119811 ], "mapped", [ 100 ] ], [ [ 119812, 119812 ], "mapped", [ 101 ] ], [ [ 119813, 119813 ], "mapped", [ 102 ] ], [ [ 119814, 119814 ], "mapped", [ 103 ] ], [ [ 119815, 119815 ], "mapped", [ 104 ] ], [ [ 119816, 119816 ], "mapped", [ 105 ] ], [ [ 119817, 119817 ], "mapped", [ 106 ] ], [ [ 119818, 119818 ], "mapped", [ 107 ] ], [ [ 119819, 119819 ], "mapped", [ 108 ] ], [ [ 119820, 119820 ], "mapped", [ 109 ] ], [ [ 119821, 119821 ], "mapped", [ 110 ] ], [ [ 119822, 119822 ], "mapped", [ 111 ] ], [ [ 119823, 119823 ], "mapped", [ 112 ] ], [ [ 119824, 119824 ], "mapped", [ 113 ] ], [ [ 119825, 119825 ], "mapped", [ 114 ] ], [ [ 119826, 119826 ], "mapped", [ 115 ] ], [ [ 119827, 119827 ], "mapped", [ 116 ] ], [ [ 119828, 119828 ], "mapped", [ 117 ] ], [ [ 119829, 119829 ], "mapped", [ 118 ] ], [ [ 119830, 119830 ], "mapped", [ 119 ] ], [ [ 119831, 119831 ], "mapped", [ 120 ] ], [ [ 119832, 119832 ], "mapped", [ 121 ] ], [ [ 119833, 119833 ], "mapped", [ 122 ] ], [ [ 119834, 119834 ], "mapped", [ 97 ] ], [ [ 119835, 119835 ], "mapped", [ 98 ] ], [ [ 119836, 119836 ], "mapped", [ 99 ] ], [ [ 119837, 119837 ], "mapped", [ 100 ] ], [ [ 119838, 119838 ], "mapped", [ 101 ] ], [ [ 119839, 119839 ], "mapped", [ 102 ] ], [ [ 119840, 119840 ], "mapped", [ 103 ] ], [ [ 119841, 119841 ], "mapped", [ 104 ] ], [ [ 119842, 119842 ], "mapped", [ 105 ] ], [ [ 119843, 119843 ], "mapped", [ 106 ] ], [ [ 119844, 119844 ], "mapped", [ 107 ] ], [ [ 119845, 119845 ], "mapped", [ 108 ] ], [ [ 119846, 119846 ], "mapped", [ 109 ] ], [ [ 119847, 119847 ], "mapped", [ 110 ] ], [ [ 119848, 119848 ], "mapped", [ 111 ] ], [ [ 119849, 119849 ], "mapped", [ 112 ] ], [ [ 119850, 119850 ], "mapped", [ 113 ] ], [ [ 119851, 119851 ], "mapped", [ 114 ] ], [ [ 119852, 119852 ], "mapped", [ 115 ] ], [ [ 119853, 119853 ], "mapped", [ 116 ] ], [ [ 119854, 119854 ], "mapped", [ 117 ] ], [ [ 119855, 119855 ], "mapped", [ 118 ] ], [ [ 119856, 119856 ], "mapped", [ 119 ] ], [ [ 119857, 119857 ], "mapped", [ 120 ] ], [ [ 119858, 119858 ], "mapped", [ 121 ] ], [ [ 119859, 119859 ], "mapped", [ 122 ] ], [ [ 119860, 119860 ], "mapped", [ 97 ] ], [ [ 119861, 119861 ], "mapped", [ 98 ] ], [ [ 119862, 119862 ], "mapped", [ 99 ] ], [ [ 119863, 119863 ], "mapped", [ 100 ] ], [ [ 119864, 119864 ], "mapped", [ 101 ] ], [ [ 119865, 119865 ], "mapped", [ 102 ] ], [ [ 119866, 119866 ], "mapped", [ 103 ] ], [ [ 119867, 119867 ], "mapped", [ 104 ] ], [ [ 119868, 119868 ], "mapped", [ 105 ] ], [ [ 119869, 119869 ], "mapped", [ 106 ] ], [ [ 119870, 119870 ], "mapped", [ 107 ] ], [ [ 119871, 119871 ], "mapped", [ 108 ] ], [ [ 119872, 119872 ], "mapped", [ 109 ] ], [ [ 119873, 119873 ], "mapped", [ 110 ] ], [ [ 119874, 119874 ], "mapped", [ 111 ] ], [ [ 119875, 119875 ], "mapped", [ 112 ] ], [ [ 119876, 119876 ], "mapped", [ 113 ] ], [ [ 119877, 119877 ], "mapped", [ 114 ] ], [ [ 119878, 119878 ], "mapped", [ 115 ] ], [ [ 119879, 119879 ], "mapped", [ 116 ] ], [ [ 119880, 119880 ], "mapped", [ 117 ] ], [ [ 119881, 119881 ], "mapped", [ 118 ] ], [ [ 119882, 119882 ], "mapped", [ 119 ] ], [ [ 119883, 119883 ], "mapped", [ 120 ] ], [ [ 119884, 119884 ], "mapped", [ 121 ] ], [ [ 119885, 119885 ], "mapped", [ 122 ] ], [ [ 119886, 119886 ], "mapped", [ 97 ] ], [ [ 119887, 119887 ], "mapped", [ 98 ] ], [ [ 119888, 119888 ], "mapped", [ 99 ] ], [ [ 119889, 119889 ], "mapped", [ 100 ] ], [ [ 119890, 119890 ], "mapped", [ 101 ] ], [ [ 119891, 119891 ], "mapped", [ 102 ] ], [ [ 119892, 119892 ], "mapped", [ 103 ] ], [ [ 119893, 119893 ], "disallowed" ], [ [ 119894, 119894 ], "mapped", [ 105 ] ], [ [ 119895, 119895 ], "mapped", [ 106 ] ], [ [ 119896, 119896 ], "mapped", [ 107 ] ], [ [ 119897, 119897 ], "mapped", [ 108 ] ], [ [ 119898, 119898 ], "mapped", [ 109 ] ], [ [ 119899, 119899 ], "mapped", [ 110 ] ], [ [ 119900, 119900 ], "mapped", [ 111 ] ], [ [ 119901, 119901 ], "mapped", [ 112 ] ], [ [ 119902, 119902 ], "mapped", [ 113 ] ], [ [ 119903, 119903 ], "mapped", [ 114 ] ], [ [ 119904, 119904 ], "mapped", [ 115 ] ], [ [ 119905, 119905 ], "mapped", [ 116 ] ], [ [ 119906, 119906 ], "mapped", [ 117 ] ], [ [ 119907, 119907 ], "mapped", [ 118 ] ], [ [ 119908, 119908 ], "mapped", [ 119 ] ], [ [ 119909, 119909 ], "mapped", [ 120 ] ], [ [ 119910, 119910 ], "mapped", [ 121 ] ], [ [ 119911, 119911 ], "mapped", [ 122 ] ], [ [ 119912, 119912 ], "mapped", [ 97 ] ], [ [ 119913, 119913 ], "mapped", [ 98 ] ], [ [ 119914, 119914 ], "mapped", [ 99 ] ], [ [ 119915, 119915 ], "mapped", [ 100 ] ], [ [ 119916, 119916 ], "mapped", [ 101 ] ], [ [ 119917, 119917 ], "mapped", [ 102 ] ], [ [ 119918, 119918 ], "mapped", [ 103 ] ], [ [ 119919, 119919 ], "mapped", [ 104 ] ], [ [ 119920, 119920 ], "mapped", [ 105 ] ], [ [ 119921, 119921 ], "mapped", [ 106 ] ], [ [ 119922, 119922 ], "mapped", [ 107 ] ], [ [ 119923, 119923 ], "mapped", [ 108 ] ], [ [ 119924, 119924 ], "mapped", [ 109 ] ], [ [ 119925, 119925 ], "mapped", [ 110 ] ], [ [ 119926, 119926 ], "mapped", [ 111 ] ], [ [ 119927, 119927 ], "mapped", [ 112 ] ], [ [ 119928, 119928 ], "mapped", [ 113 ] ], [ [ 119929, 119929 ], "mapped", [ 114 ] ], [ [ 119930, 119930 ], "mapped", [ 115 ] ], [ [ 119931, 119931 ], "mapped", [ 116 ] ], [ [ 119932, 119932 ], "mapped", [ 117 ] ], [ [ 119933, 119933 ], "mapped", [ 118 ] ], [ [ 119934, 119934 ], "mapped", [ 119 ] ], [ [ 119935, 119935 ], "mapped", [ 120 ] ], [ [ 119936, 119936 ], "mapped", [ 121 ] ], [ [ 119937, 119937 ], "mapped", [ 122 ] ], [ [ 119938, 119938 ], "mapped", [ 97 ] ], [ [ 119939, 119939 ], "mapped", [ 98 ] ], [ [ 119940, 119940 ], "mapped", [ 99 ] ], [ [ 119941, 119941 ], "mapped", [ 100 ] ], [ [ 119942, 119942 ], "mapped", [ 101 ] ], [ [ 119943, 119943 ], "mapped", [ 102 ] ], [ [ 119944, 119944 ], "mapped", [ 103 ] ], [ [ 119945, 119945 ], "mapped", [ 104 ] ], [ [ 119946, 119946 ], "mapped", [ 105 ] ], [ [ 119947, 119947 ], "mapped", [ 106 ] ], [ [ 119948, 119948 ], "mapped", [ 107 ] ], [ [ 119949, 119949 ], "mapped", [ 108 ] ], [ [ 119950, 119950 ], "mapped", [ 109 ] ], [ [ 119951, 119951 ], "mapped", [ 110 ] ], [ [ 119952, 119952 ], "mapped", [ 111 ] ], [ [ 119953, 119953 ], "mapped", [ 112 ] ], [ [ 119954, 119954 ], "mapped", [ 113 ] ], [ [ 119955, 119955 ], "mapped", [ 114 ] ], [ [ 119956, 119956 ], "mapped", [ 115 ] ], [ [ 119957, 119957 ], "mapped", [ 116 ] ], [ [ 119958, 119958 ], "mapped", [ 117 ] ], [ [ 119959, 119959 ], "mapped", [ 118 ] ], [ [ 119960, 119960 ], "mapped", [ 119 ] ], [ [ 119961, 119961 ], "mapped", [ 120 ] ], [ [ 119962, 119962 ], "mapped", [ 121 ] ], [ [ 119963, 119963 ], "mapped", [ 122 ] ], [ [ 119964, 119964 ], "mapped", [ 97 ] ], [ [ 119965, 119965 ], "disallowed" ], [ [ 119966, 119966 ], "mapped", [ 99 ] ], [ [ 119967, 119967 ], "mapped", [ 100 ] ], [ [ 119968, 119969 ], "disallowed" ], [ [ 119970, 119970 ], "mapped", [ 103 ] ], [ [ 119971, 119972 ], "disallowed" ], [ [ 119973, 119973 ], "mapped", [ 106 ] ], [ [ 119974, 119974 ], "mapped", [ 107 ] ], [ [ 119975, 119976 ], "disallowed" ], [ [ 119977, 119977 ], "mapped", [ 110 ] ], [ [ 119978, 119978 ], "mapped", [ 111 ] ], [ [ 119979, 119979 ], "mapped", [ 112 ] ], [ [ 119980, 119980 ], "mapped", [ 113 ] ], [ [ 119981, 119981 ], "disallowed" ], [ [ 119982, 119982 ], "mapped", [ 115 ] ], [ [ 119983, 119983 ], "mapped", [ 116 ] ], [ [ 119984, 119984 ], "mapped", [ 117 ] ], [ [ 119985, 119985 ], "mapped", [ 118 ] ], [ [ 119986, 119986 ], "mapped", [ 119 ] ], [ [ 119987, 119987 ], "mapped", [ 120 ] ], [ [ 119988, 119988 ], "mapped", [ 121 ] ], [ [ 119989, 119989 ], "mapped", [ 122 ] ], [ [ 119990, 119990 ], "mapped", [ 97 ] ], [ [ 119991, 119991 ], "mapped", [ 98 ] ], [ [ 119992, 119992 ], "mapped", [ 99 ] ], [ [ 119993, 119993 ], "mapped", [ 100 ] ], [ [ 119994, 119994 ], "disallowed" ], [ [ 119995, 119995 ], "mapped", [ 102 ] ], [ [ 119996, 119996 ], "disallowed" ], [ [ 119997, 119997 ], "mapped", [ 104 ] ], [ [ 119998, 119998 ], "mapped", [ 105 ] ], [ [ 119999, 119999 ], "mapped", [ 106 ] ], [ [ 12e4, 12e4 ], "mapped", [ 107 ] ], [ [ 120001, 120001 ], "mapped", [ 108 ] ], [ [ 120002, 120002 ], "mapped", [ 109 ] ], [ [ 120003, 120003 ], "mapped", [ 110 ] ], [ [ 120004, 120004 ], "disallowed" ], [ [ 120005, 120005 ], "mapped", [ 112 ] ], [ [ 120006, 120006 ], "mapped", [ 113 ] ], [ [ 120007, 120007 ], "mapped", [ 114 ] ], [ [ 120008, 120008 ], "mapped", [ 115 ] ], [ [ 120009, 120009 ], "mapped", [ 116 ] ], [ [ 120010, 120010 ], "mapped", [ 117 ] ], [ [ 120011, 120011 ], "mapped", [ 118 ] ], [ [ 120012, 120012 ], "mapped", [ 119 ] ], [ [ 120013, 120013 ], "mapped", [ 120 ] ], [ [ 120014, 120014 ], "mapped", [ 121 ] ], [ [ 120015, 120015 ], "mapped", [ 122 ] ], [ [ 120016, 120016 ], "mapped", [ 97 ] ], [ [ 120017, 120017 ], "mapped", [ 98 ] ], [ [ 120018, 120018 ], "mapped", [ 99 ] ], [ [ 120019, 120019 ], "mapped", [ 100 ] ], [ [ 120020, 120020 ], "mapped", [ 101 ] ], [ [ 120021, 120021 ], "mapped", [ 102 ] ], [ [ 120022, 120022 ], "mapped", [ 103 ] ], [ [ 120023, 120023 ], "mapped", [ 104 ] ], [ [ 120024, 120024 ], "mapped", [ 105 ] ], [ [ 120025, 120025 ], "mapped", [ 106 ] ], [ [ 120026, 120026 ], "mapped", [ 107 ] ], [ [ 120027, 120027 ], "mapped", [ 108 ] ], [ [ 120028, 120028 ], "mapped", [ 109 ] ], [ [ 120029, 120029 ], "mapped", [ 110 ] ], [ [ 120030, 120030 ], "mapped", [ 111 ] ], [ [ 120031, 120031 ], "mapped", [ 112 ] ], [ [ 120032, 120032 ], "mapped", [ 113 ] ], [ [ 120033, 120033 ], "mapped", [ 114 ] ], [ [ 120034, 120034 ], "mapped", [ 115 ] ], [ [ 120035, 120035 ], "mapped", [ 116 ] ], [ [ 120036, 120036 ], "mapped", [ 117 ] ], [ [ 120037, 120037 ], "mapped", [ 118 ] ], [ [ 120038, 120038 ], "mapped", [ 119 ] ], [ [ 120039, 120039 ], "mapped", [ 120 ] ], [ [ 120040, 120040 ], "mapped", [ 121 ] ], [ [ 120041, 120041 ], "mapped", [ 122 ] ], [ [ 120042, 120042 ], "mapped", [ 97 ] ], [ [ 120043, 120043 ], "mapped", [ 98 ] ], [ [ 120044, 120044 ], "mapped", [ 99 ] ], [ [ 120045, 120045 ], "mapped", [ 100 ] ], [ [ 120046, 120046 ], "mapped", [ 101 ] ], [ [ 120047, 120047 ], "mapped", [ 102 ] ], [ [ 120048, 120048 ], "mapped", [ 103 ] ], [ [ 120049, 120049 ], "mapped", [ 104 ] ], [ [ 120050, 120050 ], "mapped", [ 105 ] ], [ [ 120051, 120051 ], "mapped", [ 106 ] ], [ [ 120052, 120052 ], "mapped", [ 107 ] ], [ [ 120053, 120053 ], "mapped", [ 108 ] ], [ [ 120054, 120054 ], "mapped", [ 109 ] ], [ [ 120055, 120055 ], "mapped", [ 110 ] ], [ [ 120056, 120056 ], "mapped", [ 111 ] ], [ [ 120057, 120057 ], "mapped", [ 112 ] ], [ [ 120058, 120058 ], "mapped", [ 113 ] ], [ [ 120059, 120059 ], "mapped", [ 114 ] ], [ [ 120060, 120060 ], "mapped", [ 115 ] ], [ [ 120061, 120061 ], "mapped", [ 116 ] ], [ [ 120062, 120062 ], "mapped", [ 117 ] ], [ [ 120063, 120063 ], "mapped", [ 118 ] ], [ [ 120064, 120064 ], "mapped", [ 119 ] ], [ [ 120065, 120065 ], "mapped", [ 120 ] ], [ [ 120066, 120066 ], "mapped", [ 121 ] ], [ [ 120067, 120067 ], "mapped", [ 122 ] ], [ [ 120068, 120068 ], "mapped", [ 97 ] ], [ [ 120069, 120069 ], "mapped", [ 98 ] ], [ [ 120070, 120070 ], "disallowed" ], [ [ 120071, 120071 ], "mapped", [ 100 ] ], [ [ 120072, 120072 ], "mapped", [ 101 ] ], [ [ 120073, 120073 ], "mapped", [ 102 ] ], [ [ 120074, 120074 ], "mapped", [ 103 ] ], [ [ 120075, 120076 ], "disallowed" ], [ [ 120077, 120077 ], "mapped", [ 106 ] ], [ [ 120078, 120078 ], "mapped", [ 107 ] ], [ [ 120079, 120079 ], "mapped", [ 108 ] ], [ [ 120080, 120080 ], "mapped", [ 109 ] ], [ [ 120081, 120081 ], "mapped", [ 110 ] ], [ [ 120082, 120082 ], "mapped", [ 111 ] ], [ [ 120083, 120083 ], "mapped", [ 112 ] ], [ [ 120084, 120084 ], "mapped", [ 113 ] ], [ [ 120085, 120085 ], "disallowed" ], [ [ 120086, 120086 ], "mapped", [ 115 ] ], [ [ 120087, 120087 ], "mapped", [ 116 ] ], [ [ 120088, 120088 ], "mapped", [ 117 ] ], [ [ 120089, 120089 ], "mapped", [ 118 ] ], [ [ 120090, 120090 ], "mapped", [ 119 ] ], [ [ 120091, 120091 ], "mapped", [ 120 ] ], [ [ 120092, 120092 ], "mapped", [ 121 ] ], [ [ 120093, 120093 ], "disallowed" ], [ [ 120094, 120094 ], "mapped", [ 97 ] ], [ [ 120095, 120095 ], "mapped", [ 98 ] ], [ [ 120096, 120096 ], "mapped", [ 99 ] ], [ [ 120097, 120097 ], "mapped", [ 100 ] ], [ [ 120098, 120098 ], "mapped", [ 101 ] ], [ [ 120099, 120099 ], "mapped", [ 102 ] ], [ [ 120100, 120100 ], "mapped", [ 103 ] ], [ [ 120101, 120101 ], "mapped", [ 104 ] ], [ [ 120102, 120102 ], "mapped", [ 105 ] ], [ [ 120103, 120103 ], "mapped", [ 106 ] ], [ [ 120104, 120104 ], "mapped", [ 107 ] ], [ [ 120105, 120105 ], "mapped", [ 108 ] ], [ [ 120106, 120106 ], "mapped", [ 109 ] ], [ [ 120107, 120107 ], "mapped", [ 110 ] ], [ [ 120108, 120108 ], "mapped", [ 111 ] ], [ [ 120109, 120109 ], "mapped", [ 112 ] ], [ [ 120110, 120110 ], "mapped", [ 113 ] ], [ [ 120111, 120111 ], "mapped", [ 114 ] ], [ [ 120112, 120112 ], "mapped", [ 115 ] ], [ [ 120113, 120113 ], "mapped", [ 116 ] ], [ [ 120114, 120114 ], "mapped", [ 117 ] ], [ [ 120115, 120115 ], "mapped", [ 118 ] ], [ [ 120116, 120116 ], "mapped", [ 119 ] ], [ [ 120117, 120117 ], "mapped", [ 120 ] ], [ [ 120118, 120118 ], "mapped", [ 121 ] ], [ [ 120119, 120119 ], "mapped", [ 122 ] ], [ [ 120120, 120120 ], "mapped", [ 97 ] ], [ [ 120121, 120121 ], "mapped", [ 98 ] ], [ [ 120122, 120122 ], "disallowed" ], [ [ 120123, 120123 ], "mapped", [ 100 ] ], [ [ 120124, 120124 ], "mapped", [ 101 ] ], [ [ 120125, 120125 ], "mapped", [ 102 ] ], [ [ 120126, 120126 ], "mapped", [ 103 ] ], [ [ 120127, 120127 ], "disallowed" ], [ [ 120128, 120128 ], "mapped", [ 105 ] ], [ [ 120129, 120129 ], "mapped", [ 106 ] ], [ [ 120130, 120130 ], "mapped", [ 107 ] ], [ [ 120131, 120131 ], "mapped", [ 108 ] ], [ [ 120132, 120132 ], "mapped", [ 109 ] ], [ [ 120133, 120133 ], "disallowed" ], [ [ 120134, 120134 ], "mapped", [ 111 ] ], [ [ 120135, 120137 ], "disallowed" ], [ [ 120138, 120138 ], "mapped", [ 115 ] ], [ [ 120139, 120139 ], "mapped", [ 116 ] ], [ [ 120140, 120140 ], "mapped", [ 117 ] ], [ [ 120141, 120141 ], "mapped", [ 118 ] ], [ [ 120142, 120142 ], "mapped", [ 119 ] ], [ [ 120143, 120143 ], "mapped", [ 120 ] ], [ [ 120144, 120144 ], "mapped", [ 121 ] ], [ [ 120145, 120145 ], "disallowed" ], [ [ 120146, 120146 ], "mapped", [ 97 ] ], [ [ 120147, 120147 ], "mapped", [ 98 ] ], [ [ 120148, 120148 ], "mapped", [ 99 ] ], [ [ 120149, 120149 ], "mapped", [ 100 ] ], [ [ 120150, 120150 ], "mapped", [ 101 ] ], [ [ 120151, 120151 ], "mapped", [ 102 ] ], [ [ 120152, 120152 ], "mapped", [ 103 ] ], [ [ 120153, 120153 ], "mapped", [ 104 ] ], [ [ 120154, 120154 ], "mapped", [ 105 ] ], [ [ 120155, 120155 ], "mapped", [ 106 ] ], [ [ 120156, 120156 ], "mapped", [ 107 ] ], [ [ 120157, 120157 ], "mapped", [ 108 ] ], [ [ 120158, 120158 ], "mapped", [ 109 ] ], [ [ 120159, 120159 ], "mapped", [ 110 ] ], [ [ 120160, 120160 ], "mapped", [ 111 ] ], [ [ 120161, 120161 ], "mapped", [ 112 ] ], [ [ 120162, 120162 ], "mapped", [ 113 ] ], [ [ 120163, 120163 ], "mapped", [ 114 ] ], [ [ 120164, 120164 ], "mapped", [ 115 ] ], [ [ 120165, 120165 ], "mapped", [ 116 ] ], [ [ 120166, 120166 ], "mapped", [ 117 ] ], [ [ 120167, 120167 ], "mapped", [ 118 ] ], [ [ 120168, 120168 ], "mapped", [ 119 ] ], [ [ 120169, 120169 ], "mapped", [ 120 ] ], [ [ 120170, 120170 ], "mapped", [ 121 ] ], [ [ 120171, 120171 ], "mapped", [ 122 ] ], [ [ 120172, 120172 ], "mapped", [ 97 ] ], [ [ 120173, 120173 ], "mapped", [ 98 ] ], [ [ 120174, 120174 ], "mapped", [ 99 ] ], [ [ 120175, 120175 ], "mapped", [ 100 ] ], [ [ 120176, 120176 ], "mapped", [ 101 ] ], [ [ 120177, 120177 ], "mapped", [ 102 ] ], [ [ 120178, 120178 ], "mapped", [ 103 ] ], [ [ 120179, 120179 ], "mapped", [ 104 ] ], [ [ 120180, 120180 ], "mapped", [ 105 ] ], [ [ 120181, 120181 ], "mapped", [ 106 ] ], [ [ 120182, 120182 ], "mapped", [ 107 ] ], [ [ 120183, 120183 ], "mapped", [ 108 ] ], [ [ 120184, 120184 ], "mapped", [ 109 ] ], [ [ 120185, 120185 ], "mapped", [ 110 ] ], [ [ 120186, 120186 ], "mapped", [ 111 ] ], [ [ 120187, 120187 ], "mapped", [ 112 ] ], [ [ 120188, 120188 ], "mapped", [ 113 ] ], [ [ 120189, 120189 ], "mapped", [ 114 ] ], [ [ 120190, 120190 ], "mapped", [ 115 ] ], [ [ 120191, 120191 ], "mapped", [ 116 ] ], [ [ 120192, 120192 ], "mapped", [ 117 ] ], [ [ 120193, 120193 ], "mapped", [ 118 ] ], [ [ 120194, 120194 ], "mapped", [ 119 ] ], [ [ 120195, 120195 ], "mapped", [ 120 ] ], [ [ 120196, 120196 ], "mapped", [ 121 ] ], [ [ 120197, 120197 ], "mapped", [ 122 ] ], [ [ 120198, 120198 ], "mapped", [ 97 ] ], [ [ 120199, 120199 ], "mapped", [ 98 ] ], [ [ 120200, 120200 ], "mapped", [ 99 ] ], [ [ 120201, 120201 ], "mapped", [ 100 ] ], [ [ 120202, 120202 ], "mapped", [ 101 ] ], [ [ 120203, 120203 ], "mapped", [ 102 ] ], [ [ 120204, 120204 ], "mapped", [ 103 ] ], [ [ 120205, 120205 ], "mapped", [ 104 ] ], [ [ 120206, 120206 ], "mapped", [ 105 ] ], [ [ 120207, 120207 ], "mapped", [ 106 ] ], [ [ 120208, 120208 ], "mapped", [ 107 ] ], [ [ 120209, 120209 ], "mapped", [ 108 ] ], [ [ 120210, 120210 ], "mapped", [ 109 ] ], [ [ 120211, 120211 ], "mapped", [ 110 ] ], [ [ 120212, 120212 ], "mapped", [ 111 ] ], [ [ 120213, 120213 ], "mapped", [ 112 ] ], [ [ 120214, 120214 ], "mapped", [ 113 ] ], [ [ 120215, 120215 ], "mapped", [ 114 ] ], [ [ 120216, 120216 ], "mapped", [ 115 ] ], [ [ 120217, 120217 ], "mapped", [ 116 ] ], [ [ 120218, 120218 ], "mapped", [ 117 ] ], [ [ 120219, 120219 ], "mapped", [ 118 ] ], [ [ 120220, 120220 ], "mapped", [ 119 ] ], [ [ 120221, 120221 ], "mapped", [ 120 ] ], [ [ 120222, 120222 ], "mapped", [ 121 ] ], [ [ 120223, 120223 ], "mapped", [ 122 ] ], [ [ 120224, 120224 ], "mapped", [ 97 ] ], [ [ 120225, 120225 ], "mapped", [ 98 ] ], [ [ 120226, 120226 ], "mapped", [ 99 ] ], [ [ 120227, 120227 ], "mapped", [ 100 ] ], [ [ 120228, 120228 ], "mapped", [ 101 ] ], [ [ 120229, 120229 ], "mapped", [ 102 ] ], [ [ 120230, 120230 ], "mapped", [ 103 ] ], [ [ 120231, 120231 ], "mapped", [ 104 ] ], [ [ 120232, 120232 ], "mapped", [ 105 ] ], [ [ 120233, 120233 ], "mapped", [ 106 ] ], [ [ 120234, 120234 ], "mapped", [ 107 ] ], [ [ 120235, 120235 ], "mapped", [ 108 ] ], [ [ 120236, 120236 ], "mapped", [ 109 ] ], [ [ 120237, 120237 ], "mapped", [ 110 ] ], [ [ 120238, 120238 ], "mapped", [ 111 ] ], [ [ 120239, 120239 ], "mapped", [ 112 ] ], [ [ 120240, 120240 ], "mapped", [ 113 ] ], [ [ 120241, 120241 ], "mapped", [ 114 ] ], [ [ 120242, 120242 ], "mapped", [ 115 ] ], [ [ 120243, 120243 ], "mapped", [ 116 ] ], [ [ 120244, 120244 ], "mapped", [ 117 ] ], [ [ 120245, 120245 ], "mapped", [ 118 ] ], [ [ 120246, 120246 ], "mapped", [ 119 ] ], [ [ 120247, 120247 ], "mapped", [ 120 ] ], [ [ 120248, 120248 ], "mapped", [ 121 ] ], [ [ 120249, 120249 ], "mapped", [ 122 ] ], [ [ 120250, 120250 ], "mapped", [ 97 ] ], [ [ 120251, 120251 ], "mapped", [ 98 ] ], [ [ 120252, 120252 ], "mapped", [ 99 ] ], [ [ 120253, 120253 ], "mapped", [ 100 ] ], [ [ 120254, 120254 ], "mapped", [ 101 ] ], [ [ 120255, 120255 ], "mapped", [ 102 ] ], [ [ 120256, 120256 ], "mapped", [ 103 ] ], [ [ 120257, 120257 ], "mapped", [ 104 ] ], [ [ 120258, 120258 ], "mapped", [ 105 ] ], [ [ 120259, 120259 ], "mapped", [ 106 ] ], [ [ 120260, 120260 ], "mapped", [ 107 ] ], [ [ 120261, 120261 ], "mapped", [ 108 ] ], [ [ 120262, 120262 ], "mapped", [ 109 ] ], [ [ 120263, 120263 ], "mapped", [ 110 ] ], [ [ 120264, 120264 ], "mapped", [ 111 ] ], [ [ 120265, 120265 ], "mapped", [ 112 ] ], [ [ 120266, 120266 ], "mapped", [ 113 ] ], [ [ 120267, 120267 ], "mapped", [ 114 ] ], [ [ 120268, 120268 ], "mapped", [ 115 ] ], [ [ 120269, 120269 ], "mapped", [ 116 ] ], [ [ 120270, 120270 ], "mapped", [ 117 ] ], [ [ 120271, 120271 ], "mapped", [ 118 ] ], [ [ 120272, 120272 ], "mapped", [ 119 ] ], [ [ 120273, 120273 ], "mapped", [ 120 ] ], [ [ 120274, 120274 ], "mapped", [ 121 ] ], [ [ 120275, 120275 ], "mapped", [ 122 ] ], [ [ 120276, 120276 ], "mapped", [ 97 ] ], [ [ 120277, 120277 ], "mapped", [ 98 ] ], [ [ 120278, 120278 ], "mapped", [ 99 ] ], [ [ 120279, 120279 ], "mapped", [ 100 ] ], [ [ 120280, 120280 ], "mapped", [ 101 ] ], [ [ 120281, 120281 ], "mapped", [ 102 ] ], [ [ 120282, 120282 ], "mapped", [ 103 ] ], [ [ 120283, 120283 ], "mapped", [ 104 ] ], [ [ 120284, 120284 ], "mapped", [ 105 ] ], [ [ 120285, 120285 ], "mapped", [ 106 ] ], [ [ 120286, 120286 ], "mapped", [ 107 ] ], [ [ 120287, 120287 ], "mapped", [ 108 ] ], [ [ 120288, 120288 ], "mapped", [ 109 ] ], [ [ 120289, 120289 ], "mapped", [ 110 ] ], [ [ 120290, 120290 ], "mapped", [ 111 ] ], [ [ 120291, 120291 ], "mapped", [ 112 ] ], [ [ 120292, 120292 ], "mapped", [ 113 ] ], [ [ 120293, 120293 ], "mapped", [ 114 ] ], [ [ 120294, 120294 ], "mapped", [ 115 ] ], [ [ 120295, 120295 ], "mapped", [ 116 ] ], [ [ 120296, 120296 ], "mapped", [ 117 ] ], [ [ 120297, 120297 ], "mapped", [ 118 ] ], [ [ 120298, 120298 ], "mapped", [ 119 ] ], [ [ 120299, 120299 ], "mapped", [ 120 ] ], [ [ 120300, 120300 ], "mapped", [ 121 ] ], [ [ 120301, 120301 ], "mapped", [ 122 ] ], [ [ 120302, 120302 ], "mapped", [ 97 ] ], [ [ 120303, 120303 ], "mapped", [ 98 ] ], [ [ 120304, 120304 ], "mapped", [ 99 ] ], [ [ 120305, 120305 ], "mapped", [ 100 ] ], [ [ 120306, 120306 ], "mapped", [ 101 ] ], [ [ 120307, 120307 ], "mapped", [ 102 ] ], [ [ 120308, 120308 ], "mapped", [ 103 ] ], [ [ 120309, 120309 ], "mapped", [ 104 ] ], [ [ 120310, 120310 ], "mapped", [ 105 ] ], [ [ 120311, 120311 ], "mapped", [ 106 ] ], [ [ 120312, 120312 ], "mapped", [ 107 ] ], [ [ 120313, 120313 ], "mapped", [ 108 ] ], [ [ 120314, 120314 ], "mapped", [ 109 ] ], [ [ 120315, 120315 ], "mapped", [ 110 ] ], [ [ 120316, 120316 ], "mapped", [ 111 ] ], [ [ 120317, 120317 ], "mapped", [ 112 ] ], [ [ 120318, 120318 ], "mapped", [ 113 ] ], [ [ 120319, 120319 ], "mapped", [ 114 ] ], [ [ 120320, 120320 ], "mapped", [ 115 ] ], [ [ 120321, 120321 ], "mapped", [ 116 ] ], [ [ 120322, 120322 ], "mapped", [ 117 ] ], [ [ 120323, 120323 ], "mapped", [ 118 ] ], [ [ 120324, 120324 ], "mapped", [ 119 ] ], [ [ 120325, 120325 ], "mapped", [ 120 ] ], [ [ 120326, 120326 ], "mapped", [ 121 ] ], [ [ 120327, 120327 ], "mapped", [ 122 ] ], [ [ 120328, 120328 ], "mapped", [ 97 ] ], [ [ 120329, 120329 ], "mapped", [ 98 ] ], [ [ 120330, 120330 ], "mapped", [ 99 ] ], [ [ 120331, 120331 ], "mapped", [ 100 ] ], [ [ 120332, 120332 ], "mapped", [ 101 ] ], [ [ 120333, 120333 ], "mapped", [ 102 ] ], [ [ 120334, 120334 ], "mapped", [ 103 ] ], [ [ 120335, 120335 ], "mapped", [ 104 ] ], [ [ 120336, 120336 ], "mapped", [ 105 ] ], [ [ 120337, 120337 ], "mapped", [ 106 ] ], [ [ 120338, 120338 ], "mapped", [ 107 ] ], [ [ 120339, 120339 ], "mapped", [ 108 ] ], [ [ 120340, 120340 ], "mapped", [ 109 ] ], [ [ 120341, 120341 ], "mapped", [ 110 ] ], [ [ 120342, 120342 ], "mapped", [ 111 ] ], [ [ 120343, 120343 ], "mapped", [ 112 ] ], [ [ 120344, 120344 ], "mapped", [ 113 ] ], [ [ 120345, 120345 ], "mapped", [ 114 ] ], [ [ 120346, 120346 ], "mapped", [ 115 ] ], [ [ 120347, 120347 ], "mapped", [ 116 ] ], [ [ 120348, 120348 ], "mapped", [ 117 ] ], [ [ 120349, 120349 ], "mapped", [ 118 ] ], [ [ 120350, 120350 ], "mapped", [ 119 ] ], [ [ 120351, 120351 ], "mapped", [ 120 ] ], [ [ 120352, 120352 ], "mapped", [ 121 ] ], [ [ 120353, 120353 ], "mapped", [ 122 ] ], [ [ 120354, 120354 ], "mapped", [ 97 ] ], [ [ 120355, 120355 ], "mapped", [ 98 ] ], [ [ 120356, 120356 ], "mapped", [ 99 ] ], [ [ 120357, 120357 ], "mapped", [ 100 ] ], [ [ 120358, 120358 ], "mapped", [ 101 ] ], [ [ 120359, 120359 ], "mapped", [ 102 ] ], [ [ 120360, 120360 ], "mapped", [ 103 ] ], [ [ 120361, 120361 ], "mapped", [ 104 ] ], [ [ 120362, 120362 ], "mapped", [ 105 ] ], [ [ 120363, 120363 ], "mapped", [ 106 ] ], [ [ 120364, 120364 ], "mapped", [ 107 ] ], [ [ 120365, 120365 ], "mapped", [ 108 ] ], [ [ 120366, 120366 ], "mapped", [ 109 ] ], [ [ 120367, 120367 ], "mapped", [ 110 ] ], [ [ 120368, 120368 ], "mapped", [ 111 ] ], [ [ 120369, 120369 ], "mapped", [ 112 ] ], [ [ 120370, 120370 ], "mapped", [ 113 ] ], [ [ 120371, 120371 ], "mapped", [ 114 ] ], [ [ 120372, 120372 ], "mapped", [ 115 ] ], [ [ 120373, 120373 ], "mapped", [ 116 ] ], [ [ 120374, 120374 ], "mapped", [ 117 ] ], [ [ 120375, 120375 ], "mapped", [ 118 ] ], [ [ 120376, 120376 ], "mapped", [ 119 ] ], [ [ 120377, 120377 ], "mapped", [ 120 ] ], [ [ 120378, 120378 ], "mapped", [ 121 ] ], [ [ 120379, 120379 ], "mapped", [ 122 ] ], [ [ 120380, 120380 ], "mapped", [ 97 ] ], [ [ 120381, 120381 ], "mapped", [ 98 ] ], [ [ 120382, 120382 ], "mapped", [ 99 ] ], [ [ 120383, 120383 ], "mapped", [ 100 ] ], [ [ 120384, 120384 ], "mapped", [ 101 ] ], [ [ 120385, 120385 ], "mapped", [ 102 ] ], [ [ 120386, 120386 ], "mapped", [ 103 ] ], [ [ 120387, 120387 ], "mapped", [ 104 ] ], [ [ 120388, 120388 ], "mapped", [ 105 ] ], [ [ 120389, 120389 ], "mapped", [ 106 ] ], [ [ 120390, 120390 ], "mapped", [ 107 ] ], [ [ 120391, 120391 ], "mapped", [ 108 ] ], [ [ 120392, 120392 ], "mapped", [ 109 ] ], [ [ 120393, 120393 ], "mapped", [ 110 ] ], [ [ 120394, 120394 ], "mapped", [ 111 ] ], [ [ 120395, 120395 ], "mapped", [ 112 ] ], [ [ 120396, 120396 ], "mapped", [ 113 ] ], [ [ 120397, 120397 ], "mapped", [ 114 ] ], [ [ 120398, 120398 ], "mapped", [ 115 ] ], [ [ 120399, 120399 ], "mapped", [ 116 ] ], [ [ 120400, 120400 ], "mapped", [ 117 ] ], [ [ 120401, 120401 ], "mapped", [ 118 ] ], [ [ 120402, 120402 ], "mapped", [ 119 ] ], [ [ 120403, 120403 ], "mapped", [ 120 ] ], [ [ 120404, 120404 ], "mapped", [ 121 ] ], [ [ 120405, 120405 ], "mapped", [ 122 ] ], [ [ 120406, 120406 ], "mapped", [ 97 ] ], [ [ 120407, 120407 ], "mapped", [ 98 ] ], [ [ 120408, 120408 ], "mapped", [ 99 ] ], [ [ 120409, 120409 ], "mapped", [ 100 ] ], [ [ 120410, 120410 ], "mapped", [ 101 ] ], [ [ 120411, 120411 ], "mapped", [ 102 ] ], [ [ 120412, 120412 ], "mapped", [ 103 ] ], [ [ 120413, 120413 ], "mapped", [ 104 ] ], [ [ 120414, 120414 ], "mapped", [ 105 ] ], [ [ 120415, 120415 ], "mapped", [ 106 ] ], [ [ 120416, 120416 ], "mapped", [ 107 ] ], [ [ 120417, 120417 ], "mapped", [ 108 ] ], [ [ 120418, 120418 ], "mapped", [ 109 ] ], [ [ 120419, 120419 ], "mapped", [ 110 ] ], [ [ 120420, 120420 ], "mapped", [ 111 ] ], [ [ 120421, 120421 ], "mapped", [ 112 ] ], [ [ 120422, 120422 ], "mapped", [ 113 ] ], [ [ 120423, 120423 ], "mapped", [ 114 ] ], [ [ 120424, 120424 ], "mapped", [ 115 ] ], [ [ 120425, 120425 ], "mapped", [ 116 ] ], [ [ 120426, 120426 ], "mapped", [ 117 ] ], [ [ 120427, 120427 ], "mapped", [ 118 ] ], [ [ 120428, 120428 ], "mapped", [ 119 ] ], [ [ 120429, 120429 ], "mapped", [ 120 ] ], [ [ 120430, 120430 ], "mapped", [ 121 ] ], [ [ 120431, 120431 ], "mapped", [ 122 ] ], [ [ 120432, 120432 ], "mapped", [ 97 ] ], [ [ 120433, 120433 ], "mapped", [ 98 ] ], [ [ 120434, 120434 ], "mapped", [ 99 ] ], [ [ 120435, 120435 ], "mapped", [ 100 ] ], [ [ 120436, 120436 ], "mapped", [ 101 ] ], [ [ 120437, 120437 ], "mapped", [ 102 ] ], [ [ 120438, 120438 ], "mapped", [ 103 ] ], [ [ 120439, 120439 ], "mapped", [ 104 ] ], [ [ 120440, 120440 ], "mapped", [ 105 ] ], [ [ 120441, 120441 ], "mapped", [ 106 ] ], [ [ 120442, 120442 ], "mapped", [ 107 ] ], [ [ 120443, 120443 ], "mapped", [ 108 ] ], [ [ 120444, 120444 ], "mapped", [ 109 ] ], [ [ 120445, 120445 ], "mapped", [ 110 ] ], [ [ 120446, 120446 ], "mapped", [ 111 ] ], [ [ 120447, 120447 ], "mapped", [ 112 ] ], [ [ 120448, 120448 ], "mapped", [ 113 ] ], [ [ 120449, 120449 ], "mapped", [ 114 ] ], [ [ 120450, 120450 ], "mapped", [ 115 ] ], [ [ 120451, 120451 ], "mapped", [ 116 ] ], [ [ 120452, 120452 ], "mapped", [ 117 ] ], [ [ 120453, 120453 ], "mapped", [ 118 ] ], [ [ 120454, 120454 ], "mapped", [ 119 ] ], [ [ 120455, 120455 ], "mapped", [ 120 ] ], [ [ 120456, 120456 ], "mapped", [ 121 ] ], [ [ 120457, 120457 ], "mapped", [ 122 ] ], [ [ 120458, 120458 ], "mapped", [ 97 ] ], [ [ 120459, 120459 ], "mapped", [ 98 ] ], [ [ 120460, 120460 ], "mapped", [ 99 ] ], [ [ 120461, 120461 ], "mapped", [ 100 ] ], [ [ 120462, 120462 ], "mapped", [ 101 ] ], [ [ 120463, 120463 ], "mapped", [ 102 ] ], [ [ 120464, 120464 ], "mapped", [ 103 ] ], [ [ 120465, 120465 ], "mapped", [ 104 ] ], [ [ 120466, 120466 ], "mapped", [ 105 ] ], [ [ 120467, 120467 ], "mapped", [ 106 ] ], [ [ 120468, 120468 ], "mapped", [ 107 ] ], [ [ 120469, 120469 ], "mapped", [ 108 ] ], [ [ 120470, 120470 ], "mapped", [ 109 ] ], [ [ 120471, 120471 ], "mapped", [ 110 ] ], [ [ 120472, 120472 ], "mapped", [ 111 ] ], [ [ 120473, 120473 ], "mapped", [ 112 ] ], [ [ 120474, 120474 ], "mapped", [ 113 ] ], [ [ 120475, 120475 ], "mapped", [ 114 ] ], [ [ 120476, 120476 ], "mapped", [ 115 ] ], [ [ 120477, 120477 ], "mapped", [ 116 ] ], [ [ 120478, 120478 ], "mapped", [ 117 ] ], [ [ 120479, 120479 ], "mapped", [ 118 ] ], [ [ 120480, 120480 ], "mapped", [ 119 ] ], [ [ 120481, 120481 ], "mapped", [ 120 ] ], [ [ 120482, 120482 ], "mapped", [ 121 ] ], [ [ 120483, 120483 ], "mapped", [ 122 ] ], [ [ 120484, 120484 ], "mapped", [ 305 ] ], [ [ 120485, 120485 ], "mapped", [ 567 ] ], [ [ 120486, 120487 ], "disallowed" ], [ [ 120488, 120488 ], "mapped", [ 945 ] ], [ [ 120489, 120489 ], "mapped", [ 946 ] ], [ [ 120490, 120490 ], "mapped", [ 947 ] ], [ [ 120491, 120491 ], "mapped", [ 948 ] ], [ [ 120492, 120492 ], "mapped", [ 949 ] ], [ [ 120493, 120493 ], "mapped", [ 950 ] ], [ [ 120494, 120494 ], "mapped", [ 951 ] ], [ [ 120495, 120495 ], "mapped", [ 952 ] ], [ [ 120496, 120496 ], "mapped", [ 953 ] ], [ [ 120497, 120497 ], "mapped", [ 954 ] ], [ [ 120498, 120498 ], "mapped", [ 955 ] ], [ [ 120499, 120499 ], "mapped", [ 956 ] ], [ [ 120500, 120500 ], "mapped", [ 957 ] ], [ [ 120501, 120501 ], "mapped", [ 958 ] ], [ [ 120502, 120502 ], "mapped", [ 959 ] ], [ [ 120503, 120503 ], "mapped", [ 960 ] ], [ [ 120504, 120504 ], "mapped", [ 961 ] ], [ [ 120505, 120505 ], "mapped", [ 952 ] ], [ [ 120506, 120506 ], "mapped", [ 963 ] ], [ [ 120507, 120507 ], "mapped", [ 964 ] ], [ [ 120508, 120508 ], "mapped", [ 965 ] ], [ [ 120509, 120509 ], "mapped", [ 966 ] ], [ [ 120510, 120510 ], "mapped", [ 967 ] ], [ [ 120511, 120511 ], "mapped", [ 968 ] ], [ [ 120512, 120512 ], "mapped", [ 969 ] ], [ [ 120513, 120513 ], "mapped", [ 8711 ] ], [ [ 120514, 120514 ], "mapped", [ 945 ] ], [ [ 120515, 120515 ], "mapped", [ 946 ] ], [ [ 120516, 120516 ], "mapped", [ 947 ] ], [ [ 120517, 120517 ], "mapped", [ 948 ] ], [ [ 120518, 120518 ], "mapped", [ 949 ] ], [ [ 120519, 120519 ], "mapped", [ 950 ] ], [ [ 120520, 120520 ], "mapped", [ 951 ] ], [ [ 120521, 120521 ], "mapped", [ 952 ] ], [ [ 120522, 120522 ], "mapped", [ 953 ] ], [ [ 120523, 120523 ], "mapped", [ 954 ] ], [ [ 120524, 120524 ], "mapped", [ 955 ] ], [ [ 120525, 120525 ], "mapped", [ 956 ] ], [ [ 120526, 120526 ], "mapped", [ 957 ] ], [ [ 120527, 120527 ], "mapped", [ 958 ] ], [ [ 120528, 120528 ], "mapped", [ 959 ] ], [ [ 120529, 120529 ], "mapped", [ 960 ] ], [ [ 120530, 120530 ], "mapped", [ 961 ] ], [ [ 120531, 120532 ], "mapped", [ 963 ] ], [ [ 120533, 120533 ], "mapped", [ 964 ] ], [ [ 120534, 120534 ], "mapped", [ 965 ] ], [ [ 120535, 120535 ], "mapped", [ 966 ] ], [ [ 120536, 120536 ], "mapped", [ 967 ] ], [ [ 120537, 120537 ], "mapped", [ 968 ] ], [ [ 120538, 120538 ], "mapped", [ 969 ] ], [ [ 120539, 120539 ], "mapped", [ 8706 ] ], [ [ 120540, 120540 ], "mapped", [ 949 ] ], [ [ 120541, 120541 ], "mapped", [ 952 ] ], [ [ 120542, 120542 ], "mapped", [ 954 ] ], [ [ 120543, 120543 ], "mapped", [ 966 ] ], [ [ 120544, 120544 ], "mapped", [ 961 ] ], [ [ 120545, 120545 ], "mapped", [ 960 ] ], [ [ 120546, 120546 ], "mapped", [ 945 ] ], [ [ 120547, 120547 ], "mapped", [ 946 ] ], [ [ 120548, 120548 ], "mapped", [ 947 ] ], [ [ 120549, 120549 ], "mapped", [ 948 ] ], [ [ 120550, 120550 ], "mapped", [ 949 ] ], [ [ 120551, 120551 ], "mapped", [ 950 ] ], [ [ 120552, 120552 ], "mapped", [ 951 ] ], [ [ 120553, 120553 ], "mapped", [ 952 ] ], [ [ 120554, 120554 ], "mapped", [ 953 ] ], [ [ 120555, 120555 ], "mapped", [ 954 ] ], [ [ 120556, 120556 ], "mapped", [ 955 ] ], [ [ 120557, 120557 ], "mapped", [ 956 ] ], [ [ 120558, 120558 ], "mapped", [ 957 ] ], [ [ 120559, 120559 ], "mapped", [ 958 ] ], [ [ 120560, 120560 ], "mapped", [ 959 ] ], [ [ 120561, 120561 ], "mapped", [ 960 ] ], [ [ 120562, 120562 ], "mapped", [ 961 ] ], [ [ 120563, 120563 ], "mapped", [ 952 ] ], [ [ 120564, 120564 ], "mapped", [ 963 ] ], [ [ 120565, 120565 ], "mapped", [ 964 ] ], [ [ 120566, 120566 ], "mapped", [ 965 ] ], [ [ 120567, 120567 ], "mapped", [ 966 ] ], [ [ 120568, 120568 ], "mapped", [ 967 ] ], [ [ 120569, 120569 ], "mapped", [ 968 ] ], [ [ 120570, 120570 ], "mapped", [ 969 ] ], [ [ 120571, 120571 ], "mapped", [ 8711 ] ], [ [ 120572, 120572 ], "mapped", [ 945 ] ], [ [ 120573, 120573 ], "mapped", [ 946 ] ], [ [ 120574, 120574 ], "mapped", [ 947 ] ], [ [ 120575, 120575 ], "mapped", [ 948 ] ], [ [ 120576, 120576 ], "mapped", [ 949 ] ], [ [ 120577, 120577 ], "mapped", [ 950 ] ], [ [ 120578, 120578 ], "mapped", [ 951 ] ], [ [ 120579, 120579 ], "mapped", [ 952 ] ], [ [ 120580, 120580 ], "mapped", [ 953 ] ], [ [ 120581, 120581 ], "mapped", [ 954 ] ], [ [ 120582, 120582 ], "mapped", [ 955 ] ], [ [ 120583, 120583 ], "mapped", [ 956 ] ], [ [ 120584, 120584 ], "mapped", [ 957 ] ], [ [ 120585, 120585 ], "mapped", [ 958 ] ], [ [ 120586, 120586 ], "mapped", [ 959 ] ], [ [ 120587, 120587 ], "mapped", [ 960 ] ], [ [ 120588, 120588 ], "mapped", [ 961 ] ], [ [ 120589, 120590 ], "mapped", [ 963 ] ], [ [ 120591, 120591 ], "mapped", [ 964 ] ], [ [ 120592, 120592 ], "mapped", [ 965 ] ], [ [ 120593, 120593 ], "mapped", [ 966 ] ], [ [ 120594, 120594 ], "mapped", [ 967 ] ], [ [ 120595, 120595 ], "mapped", [ 968 ] ], [ [ 120596, 120596 ], "mapped", [ 969 ] ], [ [ 120597, 120597 ], "mapped", [ 8706 ] ], [ [ 120598, 120598 ], "mapped", [ 949 ] ], [ [ 120599, 120599 ], "mapped", [ 952 ] ], [ [ 120600, 120600 ], "mapped", [ 954 ] ], [ [ 120601, 120601 ], "mapped", [ 966 ] ], [ [ 120602, 120602 ], "mapped", [ 961 ] ], [ [ 120603, 120603 ], "mapped", [ 960 ] ], [ [ 120604, 120604 ], "mapped", [ 945 ] ], [ [ 120605, 120605 ], "mapped", [ 946 ] ], [ [ 120606, 120606 ], "mapped", [ 947 ] ], [ [ 120607, 120607 ], "mapped", [ 948 ] ], [ [ 120608, 120608 ], "mapped", [ 949 ] ], [ [ 120609, 120609 ], "mapped", [ 950 ] ], [ [ 120610, 120610 ], "mapped", [ 951 ] ], [ [ 120611, 120611 ], "mapped", [ 952 ] ], [ [ 120612, 120612 ], "mapped", [ 953 ] ], [ [ 120613, 120613 ], "mapped", [ 954 ] ], [ [ 120614, 120614 ], "mapped", [ 955 ] ], [ [ 120615, 120615 ], "mapped", [ 956 ] ], [ [ 120616, 120616 ], "mapped", [ 957 ] ], [ [ 120617, 120617 ], "mapped", [ 958 ] ], [ [ 120618, 120618 ], "mapped", [ 959 ] ], [ [ 120619, 120619 ], "mapped", [ 960 ] ], [ [ 120620, 120620 ], "mapped", [ 961 ] ], [ [ 120621, 120621 ], "mapped", [ 952 ] ], [ [ 120622, 120622 ], "mapped", [ 963 ] ], [ [ 120623, 120623 ], "mapped", [ 964 ] ], [ [ 120624, 120624 ], "mapped", [ 965 ] ], [ [ 120625, 120625 ], "mapped", [ 966 ] ], [ [ 120626, 120626 ], "mapped", [ 967 ] ], [ [ 120627, 120627 ], "mapped", [ 968 ] ], [ [ 120628, 120628 ], "mapped", [ 969 ] ], [ [ 120629, 120629 ], "mapped", [ 8711 ] ], [ [ 120630, 120630 ], "mapped", [ 945 ] ], [ [ 120631, 120631 ], "mapped", [ 946 ] ], [ [ 120632, 120632 ], "mapped", [ 947 ] ], [ [ 120633, 120633 ], "mapped", [ 948 ] ], [ [ 120634, 120634 ], "mapped", [ 949 ] ], [ [ 120635, 120635 ], "mapped", [ 950 ] ], [ [ 120636, 120636 ], "mapped", [ 951 ] ], [ [ 120637, 120637 ], "mapped", [ 952 ] ], [ [ 120638, 120638 ], "mapped", [ 953 ] ], [ [ 120639, 120639 ], "mapped", [ 954 ] ], [ [ 120640, 120640 ], "mapped", [ 955 ] ], [ [ 120641, 120641 ], "mapped", [ 956 ] ], [ [ 120642, 120642 ], "mapped", [ 957 ] ], [ [ 120643, 120643 ], "mapped", [ 958 ] ], [ [ 120644, 120644 ], "mapped", [ 959 ] ], [ [ 120645, 120645 ], "mapped", [ 960 ] ], [ [ 120646, 120646 ], "mapped", [ 961 ] ], [ [ 120647, 120648 ], "mapped", [ 963 ] ], [ [ 120649, 120649 ], "mapped", [ 964 ] ], [ [ 120650, 120650 ], "mapped", [ 965 ] ], [ [ 120651, 120651 ], "mapped", [ 966 ] ], [ [ 120652, 120652 ], "mapped", [ 967 ] ], [ [ 120653, 120653 ], "mapped", [ 968 ] ], [ [ 120654, 120654 ], "mapped", [ 969 ] ], [ [ 120655, 120655 ], "mapped", [ 8706 ] ], [ [ 120656, 120656 ], "mapped", [ 949 ] ], [ [ 120657, 120657 ], "mapped", [ 952 ] ], [ [ 120658, 120658 ], "mapped", [ 954 ] ], [ [ 120659, 120659 ], "mapped", [ 966 ] ], [ [ 120660, 120660 ], "mapped", [ 961 ] ], [ [ 120661, 120661 ], "mapped", [ 960 ] ], [ [ 120662, 120662 ], "mapped", [ 945 ] ], [ [ 120663, 120663 ], "mapped", [ 946 ] ], [ [ 120664, 120664 ], "mapped", [ 947 ] ], [ [ 120665, 120665 ], "mapped", [ 948 ] ], [ [ 120666, 120666 ], "mapped", [ 949 ] ], [ [ 120667, 120667 ], "mapped", [ 950 ] ], [ [ 120668, 120668 ], "mapped", [ 951 ] ], [ [ 120669, 120669 ], "mapped", [ 952 ] ], [ [ 120670, 120670 ], "mapped", [ 953 ] ], [ [ 120671, 120671 ], "mapped", [ 954 ] ], [ [ 120672, 120672 ], "mapped", [ 955 ] ], [ [ 120673, 120673 ], "mapped", [ 956 ] ], [ [ 120674, 120674 ], "mapped", [ 957 ] ], [ [ 120675, 120675 ], "mapped", [ 958 ] ], [ [ 120676, 120676 ], "mapped", [ 959 ] ], [ [ 120677, 120677 ], "mapped", [ 960 ] ], [ [ 120678, 120678 ], "mapped", [ 961 ] ], [ [ 120679, 120679 ], "mapped", [ 952 ] ], [ [ 120680, 120680 ], "mapped", [ 963 ] ], [ [ 120681, 120681 ], "mapped", [ 964 ] ], [ [ 120682, 120682 ], "mapped", [ 965 ] ], [ [ 120683, 120683 ], "mapped", [ 966 ] ], [ [ 120684, 120684 ], "mapped", [ 967 ] ], [ [ 120685, 120685 ], "mapped", [ 968 ] ], [ [ 120686, 120686 ], "mapped", [ 969 ] ], [ [ 120687, 120687 ], "mapped", [ 8711 ] ], [ [ 120688, 120688 ], "mapped", [ 945 ] ], [ [ 120689, 120689 ], "mapped", [ 946 ] ], [ [ 120690, 120690 ], "mapped", [ 947 ] ], [ [ 120691, 120691 ], "mapped", [ 948 ] ], [ [ 120692, 120692 ], "mapped", [ 949 ] ], [ [ 120693, 120693 ], "mapped", [ 950 ] ], [ [ 120694, 120694 ], "mapped", [ 951 ] ], [ [ 120695, 120695 ], "mapped", [ 952 ] ], [ [ 120696, 120696 ], "mapped", [ 953 ] ], [ [ 120697, 120697 ], "mapped", [ 954 ] ], [ [ 120698, 120698 ], "mapped", [ 955 ] ], [ [ 120699, 120699 ], "mapped", [ 956 ] ], [ [ 120700, 120700 ], "mapped", [ 957 ] ], [ [ 120701, 120701 ], "mapped", [ 958 ] ], [ [ 120702, 120702 ], "mapped", [ 959 ] ], [ [ 120703, 120703 ], "mapped", [ 960 ] ], [ [ 120704, 120704 ], "mapped", [ 961 ] ], [ [ 120705, 120706 ], "mapped", [ 963 ] ], [ [ 120707, 120707 ], "mapped", [ 964 ] ], [ [ 120708, 120708 ], "mapped", [ 965 ] ], [ [ 120709, 120709 ], "mapped", [ 966 ] ], [ [ 120710, 120710 ], "mapped", [ 967 ] ], [ [ 120711, 120711 ], "mapped", [ 968 ] ], [ [ 120712, 120712 ], "mapped", [ 969 ] ], [ [ 120713, 120713 ], "mapped", [ 8706 ] ], [ [ 120714, 120714 ], "mapped", [ 949 ] ], [ [ 120715, 120715 ], "mapped", [ 952 ] ], [ [ 120716, 120716 ], "mapped", [ 954 ] ], [ [ 120717, 120717 ], "mapped", [ 966 ] ], [ [ 120718, 120718 ], "mapped", [ 961 ] ], [ [ 120719, 120719 ], "mapped", [ 960 ] ], [ [ 120720, 120720 ], "mapped", [ 945 ] ], [ [ 120721, 120721 ], "mapped", [ 946 ] ], [ [ 120722, 120722 ], "mapped", [ 947 ] ], [ [ 120723, 120723 ], "mapped", [ 948 ] ], [ [ 120724, 120724 ], "mapped", [ 949 ] ], [ [ 120725, 120725 ], "mapped", [ 950 ] ], [ [ 120726, 120726 ], "mapped", [ 951 ] ], [ [ 120727, 120727 ], "mapped", [ 952 ] ], [ [ 120728, 120728 ], "mapped", [ 953 ] ], [ [ 120729, 120729 ], "mapped", [ 954 ] ], [ [ 120730, 120730 ], "mapped", [ 955 ] ], [ [ 120731, 120731 ], "mapped", [ 956 ] ], [ [ 120732, 120732 ], "mapped", [ 957 ] ], [ [ 120733, 120733 ], "mapped", [ 958 ] ], [ [ 120734, 120734 ], "mapped", [ 959 ] ], [ [ 120735, 120735 ], "mapped", [ 960 ] ], [ [ 120736, 120736 ], "mapped", [ 961 ] ], [ [ 120737, 120737 ], "mapped", [ 952 ] ], [ [ 120738, 120738 ], "mapped", [ 963 ] ], [ [ 120739, 120739 ], "mapped", [ 964 ] ], [ [ 120740, 120740 ], "mapped", [ 965 ] ], [ [ 120741, 120741 ], "mapped", [ 966 ] ], [ [ 120742, 120742 ], "mapped", [ 967 ] ], [ [ 120743, 120743 ], "mapped", [ 968 ] ], [ [ 120744, 120744 ], "mapped", [ 969 ] ], [ [ 120745, 120745 ], "mapped", [ 8711 ] ], [ [ 120746, 120746 ], "mapped", [ 945 ] ], [ [ 120747, 120747 ], "mapped", [ 946 ] ], [ [ 120748, 120748 ], "mapped", [ 947 ] ], [ [ 120749, 120749 ], "mapped", [ 948 ] ], [ [ 120750, 120750 ], "mapped", [ 949 ] ], [ [ 120751, 120751 ], "mapped", [ 950 ] ], [ [ 120752, 120752 ], "mapped", [ 951 ] ], [ [ 120753, 120753 ], "mapped", [ 952 ] ], [ [ 120754, 120754 ], "mapped", [ 953 ] ], [ [ 120755, 120755 ], "mapped", [ 954 ] ], [ [ 120756, 120756 ], "mapped", [ 955 ] ], [ [ 120757, 120757 ], "mapped", [ 956 ] ], [ [ 120758, 120758 ], "mapped", [ 957 ] ], [ [ 120759, 120759 ], "mapped", [ 958 ] ], [ [ 120760, 120760 ], "mapped", [ 959 ] ], [ [ 120761, 120761 ], "mapped", [ 960 ] ], [ [ 120762, 120762 ], "mapped", [ 961 ] ], [ [ 120763, 120764 ], "mapped", [ 963 ] ], [ [ 120765, 120765 ], "mapped", [ 964 ] ], [ [ 120766, 120766 ], "mapped", [ 965 ] ], [ [ 120767, 120767 ], "mapped", [ 966 ] ], [ [ 120768, 120768 ], "mapped", [ 967 ] ], [ [ 120769, 120769 ], "mapped", [ 968 ] ], [ [ 120770, 120770 ], "mapped", [ 969 ] ], [ [ 120771, 120771 ], "mapped", [ 8706 ] ], [ [ 120772, 120772 ], "mapped", [ 949 ] ], [ [ 120773, 120773 ], "mapped", [ 952 ] ], [ [ 120774, 120774 ], "mapped", [ 954 ] ], [ [ 120775, 120775 ], "mapped", [ 966 ] ], [ [ 120776, 120776 ], "mapped", [ 961 ] ], [ [ 120777, 120777 ], "mapped", [ 960 ] ], [ [ 120778, 120779 ], "mapped", [ 989 ] ], [ [ 120780, 120781 ], "disallowed" ], [ [ 120782, 120782 ], "mapped", [ 48 ] ], [ [ 120783, 120783 ], "mapped", [ 49 ] ], [ [ 120784, 120784 ], "mapped", [ 50 ] ], [ [ 120785, 120785 ], "mapped", [ 51 ] ], [ [ 120786, 120786 ], "mapped", [ 52 ] ], [ [ 120787, 120787 ], "mapped", [ 53 ] ], [ [ 120788, 120788 ], "mapped", [ 54 ] ], [ [ 120789, 120789 ], "mapped", [ 55 ] ], [ [ 120790, 120790 ], "mapped", [ 56 ] ], [ [ 120791, 120791 ], "mapped", [ 57 ] ], [ [ 120792, 120792 ], "mapped", [ 48 ] ], [ [ 120793, 120793 ], "mapped", [ 49 ] ], [ [ 120794, 120794 ], "mapped", [ 50 ] ], [ [ 120795, 120795 ], "mapped", [ 51 ] ], [ [ 120796, 120796 ], "mapped", [ 52 ] ], [ [ 120797, 120797 ], "mapped", [ 53 ] ], [ [ 120798, 120798 ], "mapped", [ 54 ] ], [ [ 120799, 120799 ], "mapped", [ 55 ] ], [ [ 120800, 120800 ], "mapped", [ 56 ] ], [ [ 120801, 120801 ], "mapped", [ 57 ] ], [ [ 120802, 120802 ], "mapped", [ 48 ] ], [ [ 120803, 120803 ], "mapped", [ 49 ] ], [ [ 120804, 120804 ], "mapped", [ 50 ] ], [ [ 120805, 120805 ], "mapped", [ 51 ] ], [ [ 120806, 120806 ], "mapped", [ 52 ] ], [ [ 120807, 120807 ], "mapped", [ 53 ] ], [ [ 120808, 120808 ], "mapped", [ 54 ] ], [ [ 120809, 120809 ], "mapped", [ 55 ] ], [ [ 120810, 120810 ], "mapped", [ 56 ] ], [ [ 120811, 120811 ], "mapped", [ 57 ] ], [ [ 120812, 120812 ], "mapped", [ 48 ] ], [ [ 120813, 120813 ], "mapped", [ 49 ] ], [ [ 120814, 120814 ], "mapped", [ 50 ] ], [ [ 120815, 120815 ], "mapped", [ 51 ] ], [ [ 120816, 120816 ], "mapped", [ 52 ] ], [ [ 120817, 120817 ], "mapped", [ 53 ] ], [ [ 120818, 120818 ], "mapped", [ 54 ] ], [ [ 120819, 120819 ], "mapped", [ 55 ] ], [ [ 120820, 120820 ], "mapped", [ 56 ] ], [ [ 120821, 120821 ], "mapped", [ 57 ] ], [ [ 120822, 120822 ], "mapped", [ 48 ] ], [ [ 120823, 120823 ], "mapped", [ 49 ] ], [ [ 120824, 120824 ], "mapped", [ 50 ] ], [ [ 120825, 120825 ], "mapped", [ 51 ] ], [ [ 120826, 120826 ], "mapped", [ 52 ] ], [ [ 120827, 120827 ], "mapped", [ 53 ] ], [ [ 120828, 120828 ], "mapped", [ 54 ] ], [ [ 120829, 120829 ], "mapped", [ 55 ] ], [ [ 120830, 120830 ], "mapped", [ 56 ] ], [ [ 120831, 120831 ], "mapped", [ 57 ] ], [ [ 120832, 121343 ], "valid", [], "NV8" ], [ [ 121344, 121398 ], "valid" ], [ [ 121399, 121402 ], "valid", [], "NV8" ], [ [ 121403, 121452 ], "valid" ], [ [ 121453, 121460 ], "valid", [], "NV8" ], [ [ 121461, 121461 ], "valid" ], [ [ 121462, 121475 ], "valid", [], "NV8" ], [ [ 121476, 121476 ], "valid" ], [ [ 121477, 121483 ], "valid", [], "NV8" ], [ [ 121484, 121498 ], "disallowed" ], [ [ 121499, 121503 ], "valid" ], [ [ 121504, 121504 ], "disallowed" ], [ [ 121505, 121519 ], "valid" ], [ [ 121520, 124927 ], "disallowed" ], [ [ 124928, 125124 ], "valid" ], [ [ 125125, 125126 ], "disallowed" ], [ [ 125127, 125135 ], "valid", [], "NV8" ], [ [ 125136, 125142 ], "valid" ], [ [ 125143, 126463 ], "disallowed" ], [ [ 126464, 126464 ], "mapped", [ 1575 ] ], [ [ 126465, 126465 ], "mapped", [ 1576 ] ], [ [ 126466, 126466 ], "mapped", [ 1580 ] ], [ [ 126467, 126467 ], "mapped", [ 1583 ] ], [ [ 126468, 126468 ], "disallowed" ], [ [ 126469, 126469 ], "mapped", [ 1608 ] ], [ [ 126470, 126470 ], "mapped", [ 1586 ] ], [ [ 126471, 126471 ], "mapped", [ 1581 ] ], [ [ 126472, 126472 ], "mapped", [ 1591 ] ], [ [ 126473, 126473 ], "mapped", [ 1610 ] ], [ [ 126474, 126474 ], "mapped", [ 1603 ] ], [ [ 126475, 126475 ], "mapped", [ 1604 ] ], [ [ 126476, 126476 ], "mapped", [ 1605 ] ], [ [ 126477, 126477 ], "mapped", [ 1606 ] ], [ [ 126478, 126478 ], "mapped", [ 1587 ] ], [ [ 126479, 126479 ], "mapped", [ 1593 ] ], [ [ 126480, 126480 ], "mapped", [ 1601 ] ], [ [ 126481, 126481 ], "mapped", [ 1589 ] ], [ [ 126482, 126482 ], "mapped", [ 1602 ] ], [ [ 126483, 126483 ], "mapped", [ 1585 ] ], [ [ 126484, 126484 ], "mapped", [ 1588 ] ], [ [ 126485, 126485 ], "mapped", [ 1578 ] ], [ [ 126486, 126486 ], "mapped", [ 1579 ] ], [ [ 126487, 126487 ], "mapped", [ 1582 ] ], [ [ 126488, 126488 ], "mapped", [ 1584 ] ], [ [ 126489, 126489 ], "mapped", [ 1590 ] ], [ [ 126490, 126490 ], "mapped", [ 1592 ] ], [ [ 126491, 126491 ], "mapped", [ 1594 ] ], [ [ 126492, 126492 ], "mapped", [ 1646 ] ], [ [ 126493, 126493 ], "mapped", [ 1722 ] ], [ [ 126494, 126494 ], "mapped", [ 1697 ] ], [ [ 126495, 126495 ], "mapped", [ 1647 ] ], [ [ 126496, 126496 ], "disallowed" ], [ [ 126497, 126497 ], "mapped", [ 1576 ] ], [ [ 126498, 126498 ], "mapped", [ 1580 ] ], [ [ 126499, 126499 ], "disallowed" ], [ [ 126500, 126500 ], "mapped", [ 1607 ] ], [ [ 126501, 126502 ], "disallowed" ], [ [ 126503, 126503 ], "mapped", [ 1581 ] ], [ [ 126504, 126504 ], "disallowed" ], [ [ 126505, 126505 ], "mapped", [ 1610 ] ], [ [ 126506, 126506 ], "mapped", [ 1603 ] ], [ [ 126507, 126507 ], "mapped", [ 1604 ] ], [ [ 126508, 126508 ], "mapped", [ 1605 ] ], [ [ 126509, 126509 ], "mapped", [ 1606 ] ], [ [ 126510, 126510 ], "mapped", [ 1587 ] ], [ [ 126511, 126511 ], "mapped", [ 1593 ] ], [ [ 126512, 126512 ], "mapped", [ 1601 ] ], [ [ 126513, 126513 ], "mapped", [ 1589 ] ], [ [ 126514, 126514 ], "mapped", [ 1602 ] ], [ [ 126515, 126515 ], "disallowed" ], [ [ 126516, 126516 ], "mapped", [ 1588 ] ], [ [ 126517, 126517 ], "mapped", [ 1578 ] ], [ [ 126518, 126518 ], "mapped", [ 1579 ] ], [ [ 126519, 126519 ], "mapped", [ 1582 ] ], [ [ 126520, 126520 ], "disallowed" ], [ [ 126521, 126521 ], "mapped", [ 1590 ] ], [ [ 126522, 126522 ], "disallowed" ], [ [ 126523, 126523 ], "mapped", [ 1594 ] ], [ [ 126524, 126529 ], "disallowed" ], [ [ 126530, 126530 ], "mapped", [ 1580 ] ], [ [ 126531, 126534 ], "disallowed" ], [ [ 126535, 126535 ], "mapped", [ 1581 ] ], [ [ 126536, 126536 ], "disallowed" ], [ [ 126537, 126537 ], "mapped", [ 1610 ] ], [ [ 126538, 126538 ], "disallowed" ], [ [ 126539, 126539 ], "mapped", [ 1604 ] ], [ [ 126540, 126540 ], "disallowed" ], [ [ 126541, 126541 ], "mapped", [ 1606 ] ], [ [ 126542, 126542 ], "mapped", [ 1587 ] ], [ [ 126543, 126543 ], "mapped", [ 1593 ] ], [ [ 126544, 126544 ], "disallowed" ], [ [ 126545, 126545 ], "mapped", [ 1589 ] ], [ [ 126546, 126546 ], "mapped", [ 1602 ] ], [ [ 126547, 126547 ], "disallowed" ], [ [ 126548, 126548 ], "mapped", [ 1588 ] ], [ [ 126549, 126550 ], "disallowed" ], [ [ 126551, 126551 ], "mapped", [ 1582 ] ], [ [ 126552, 126552 ], "disallowed" ], [ [ 126553, 126553 ], "mapped", [ 1590 ] ], [ [ 126554, 126554 ], "disallowed" ], [ [ 126555, 126555 ], "mapped", [ 1594 ] ], [ [ 126556, 126556 ], "disallowed" ], [ [ 126557, 126557 ], "mapped", [ 1722 ] ], [ [ 126558, 126558 ], "disallowed" ], [ [ 126559, 126559 ], "mapped", [ 1647 ] ], [ [ 126560, 126560 ], "disallowed" ], [ [ 126561, 126561 ], "mapped", [ 1576 ] ], [ [ 126562, 126562 ], "mapped", [ 1580 ] ], [ [ 126563, 126563 ], "disallowed" ], [ [ 126564, 126564 ], "mapped", [ 1607 ] ], [ [ 126565, 126566 ], "disallowed" ], [ [ 126567, 126567 ], "mapped", [ 1581 ] ], [ [ 126568, 126568 ], "mapped", [ 1591 ] ], [ [ 126569, 126569 ], "mapped", [ 1610 ] ], [ [ 126570, 126570 ], "mapped", [ 1603 ] ], [ [ 126571, 126571 ], "disallowed" ], [ [ 126572, 126572 ], "mapped", [ 1605 ] ], [ [ 126573, 126573 ], "mapped", [ 1606 ] ], [ [ 126574, 126574 ], "mapped", [ 1587 ] ], [ [ 126575, 126575 ], "mapped", [ 1593 ] ], [ [ 126576, 126576 ], "mapped", [ 1601 ] ], [ [ 126577, 126577 ], "mapped", [ 1589 ] ], [ [ 126578, 126578 ], "mapped", [ 1602 ] ], [ [ 126579, 126579 ], "disallowed" ], [ [ 126580, 126580 ], "mapped", [ 1588 ] ], [ [ 126581, 126581 ], "mapped", [ 1578 ] ], [ [ 126582, 126582 ], "mapped", [ 1579 ] ], [ [ 126583, 126583 ], "mapped", [ 1582 ] ], [ [ 126584, 126584 ], "disallowed" ], [ [ 126585, 126585 ], "mapped", [ 1590 ] ], [ [ 126586, 126586 ], "mapped", [ 1592 ] ], [ [ 126587, 126587 ], "mapped", [ 1594 ] ], [ [ 126588, 126588 ], "mapped", [ 1646 ] ], [ [ 126589, 126589 ], "disallowed" ], [ [ 126590, 126590 ], "mapped", [ 1697 ] ], [ [ 126591, 126591 ], "disallowed" ], [ [ 126592, 126592 ], "mapped", [ 1575 ] ], [ [ 126593, 126593 ], "mapped", [ 1576 ] ], [ [ 126594, 126594 ], "mapped", [ 1580 ] ], [ [ 126595, 126595 ], "mapped", [ 1583 ] ], [ [ 126596, 126596 ], "mapped", [ 1607 ] ], [ [ 126597, 126597 ], "mapped", [ 1608 ] ], [ [ 126598, 126598 ], "mapped", [ 1586 ] ], [ [ 126599, 126599 ], "mapped", [ 1581 ] ], [ [ 126600, 126600 ], "mapped", [ 1591 ] ], [ [ 126601, 126601 ], "mapped", [ 1610 ] ], [ [ 126602, 126602 ], "disallowed" ], [ [ 126603, 126603 ], "mapped", [ 1604 ] ], [ [ 126604, 126604 ], "mapped", [ 1605 ] ], [ [ 126605, 126605 ], "mapped", [ 1606 ] ], [ [ 126606, 126606 ], "mapped", [ 1587 ] ], [ [ 126607, 126607 ], "mapped", [ 1593 ] ], [ [ 126608, 126608 ], "mapped", [ 1601 ] ], [ [ 126609, 126609 ], "mapped", [ 1589 ] ], [ [ 126610, 126610 ], "mapped", [ 1602 ] ], [ [ 126611, 126611 ], "mapped", [ 1585 ] ], [ [ 126612, 126612 ], "mapped", [ 1588 ] ], [ [ 126613, 126613 ], "mapped", [ 1578 ] ], [ [ 126614, 126614 ], "mapped", [ 1579 ] ], [ [ 126615, 126615 ], "mapped", [ 1582 ] ], [ [ 126616, 126616 ], "mapped", [ 1584 ] ], [ [ 126617, 126617 ], "mapped", [ 1590 ] ], [ [ 126618, 126618 ], "mapped", [ 1592 ] ], [ [ 126619, 126619 ], "mapped", [ 1594 ] ], [ [ 126620, 126624 ], "disallowed" ], [ [ 126625, 126625 ], "mapped", [ 1576 ] ], [ [ 126626, 126626 ], "mapped", [ 1580 ] ], [ [ 126627, 126627 ], "mapped", [ 1583 ] ], [ [ 126628, 126628 ], "disallowed" ], [ [ 126629, 126629 ], "mapped", [ 1608 ] ], [ [ 126630, 126630 ], "mapped", [ 1586 ] ], [ [ 126631, 126631 ], "mapped", [ 1581 ] ], [ [ 126632, 126632 ], "mapped", [ 1591 ] ], [ [ 126633, 126633 ], "mapped", [ 1610 ] ], [ [ 126634, 126634 ], "disallowed" ], [ [ 126635, 126635 ], "mapped", [ 1604 ] ], [ [ 126636, 126636 ], "mapped", [ 1605 ] ], [ [ 126637, 126637 ], "mapped", [ 1606 ] ], [ [ 126638, 126638 ], "mapped", [ 1587 ] ], [ [ 126639, 126639 ], "mapped", [ 1593 ] ], [ [ 126640, 126640 ], "mapped", [ 1601 ] ], [ [ 126641, 126641 ], "mapped", [ 1589 ] ], [ [ 126642, 126642 ], "mapped", [ 1602 ] ], [ [ 126643, 126643 ], "mapped", [ 1585 ] ], [ [ 126644, 126644 ], "mapped", [ 1588 ] ], [ [ 126645, 126645 ], "mapped", [ 1578 ] ], [ [ 126646, 126646 ], "mapped", [ 1579 ] ], [ [ 126647, 126647 ], "mapped", [ 1582 ] ], [ [ 126648, 126648 ], "mapped", [ 1584 ] ], [ [ 126649, 126649 ], "mapped", [ 1590 ] ], [ [ 126650, 126650 ], "mapped", [ 1592 ] ], [ [ 126651, 126651 ], "mapped", [ 1594 ] ], [ [ 126652, 126703 ], "disallowed" ], [ [ 126704, 126705 ], "valid", [], "NV8" ], [ [ 126706, 126975 ], "disallowed" ], [ [ 126976, 127019 ], "valid", [], "NV8" ], [ [ 127020, 127023 ], "disallowed" ], [ [ 127024, 127123 ], "valid", [], "NV8" ], [ [ 127124, 127135 ], "disallowed" ], [ [ 127136, 127150 ], "valid", [], "NV8" ], [ [ 127151, 127152 ], "disallowed" ], [ [ 127153, 127166 ], "valid", [], "NV8" ], [ [ 127167, 127167 ], "valid", [], "NV8" ], [ [ 127168, 127168 ], "disallowed" ], [ [ 127169, 127183 ], "valid", [], "NV8" ], [ [ 127184, 127184 ], "disallowed" ], [ [ 127185, 127199 ], "valid", [], "NV8" ], [ [ 127200, 127221 ], "valid", [], "NV8" ], [ [ 127222, 127231 ], "disallowed" ], [ [ 127232, 127232 ], "disallowed" ], [ [ 127233, 127233 ], "disallowed_STD3_mapped", [ 48, 44 ] ], [ [ 127234, 127234 ], "disallowed_STD3_mapped", [ 49, 44 ] ], [ [ 127235, 127235 ], "disallowed_STD3_mapped", [ 50, 44 ] ], [ [ 127236, 127236 ], "disallowed_STD3_mapped", [ 51, 44 ] ], [ [ 127237, 127237 ], "disallowed_STD3_mapped", [ 52, 44 ] ], [ [ 127238, 127238 ], "disallowed_STD3_mapped", [ 53, 44 ] ], [ [ 127239, 127239 ], "disallowed_STD3_mapped", [ 54, 44 ] ], [ [ 127240, 127240 ], "disallowed_STD3_mapped", [ 55, 44 ] ], [ [ 127241, 127241 ], "disallowed_STD3_mapped", [ 56, 44 ] ], [ [ 127242, 127242 ], "disallowed_STD3_mapped", [ 57, 44 ] ], [ [ 127243, 127244 ], "valid", [], "NV8" ], [ [ 127245, 127247 ], "disallowed" ], [ [ 127248, 127248 ], "disallowed_STD3_mapped", [ 40, 97, 41 ] ], [ [ 127249, 127249 ], "disallowed_STD3_mapped", [ 40, 98, 41 ] ], [ [ 127250, 127250 ], "disallowed_STD3_mapped", [ 40, 99, 41 ] ], [ [ 127251, 127251 ], "disallowed_STD3_mapped", [ 40, 100, 41 ] ], [ [ 127252, 127252 ], "disallowed_STD3_mapped", [ 40, 101, 41 ] ], [ [ 127253, 127253 ], "disallowed_STD3_mapped", [ 40, 102, 41 ] ], [ [ 127254, 127254 ], "disallowed_STD3_mapped", [ 40, 103, 41 ] ], [ [ 127255, 127255 ], "disallowed_STD3_mapped", [ 40, 104, 41 ] ], [ [ 127256, 127256 ], "disallowed_STD3_mapped", [ 40, 105, 41 ] ], [ [ 127257, 127257 ], "disallowed_STD3_mapped", [ 40, 106, 41 ] ], [ [ 127258, 127258 ], "disallowed_STD3_mapped", [ 40, 107, 41 ] ], [ [ 127259, 127259 ], "disallowed_STD3_mapped", [ 40, 108, 41 ] ], [ [ 127260, 127260 ], "disallowed_STD3_mapped", [ 40, 109, 41 ] ], [ [ 127261, 127261 ], "disallowed_STD3_mapped", [ 40, 110, 41 ] ], [ [ 127262, 127262 ], "disallowed_STD3_mapped", [ 40, 111, 41 ] ], [ [ 127263, 127263 ], "disallowed_STD3_mapped", [ 40, 112, 41 ] ], [ [ 127264, 127264 ], "disallowed_STD3_mapped", [ 40, 113, 41 ] ], [ [ 127265, 127265 ], "disallowed_STD3_mapped", [ 40, 114, 41 ] ], [ [ 127266, 127266 ], "disallowed_STD3_mapped", [ 40, 115, 41 ] ], [ [ 127267, 127267 ], "disallowed_STD3_mapped", [ 40, 116, 41 ] ], [ [ 127268, 127268 ], "disallowed_STD3_mapped", [ 40, 117, 41 ] ], [ [ 127269, 127269 ], "disallowed_STD3_mapped", [ 40, 118, 41 ] ], [ [ 127270, 127270 ], "disallowed_STD3_mapped", [ 40, 119, 41 ] ], [ [ 127271, 127271 ], "disallowed_STD3_mapped", [ 40, 120, 41 ] ], [ [ 127272, 127272 ], "disallowed_STD3_mapped", [ 40, 121, 41 ] ], [ [ 127273, 127273 ], "disallowed_STD3_mapped", [ 40, 122, 41 ] ], [ [ 127274, 127274 ], "mapped", [ 12308, 115, 12309 ] ], [ [ 127275, 127275 ], "mapped", [ 99 ] ], [ [ 127276, 127276 ], "mapped", [ 114 ] ], [ [ 127277, 127277 ], "mapped", [ 99, 100 ] ], [ [ 127278, 127278 ], "mapped", [ 119, 122 ] ], [ [ 127279, 127279 ], "disallowed" ], [ [ 127280, 127280 ], "mapped", [ 97 ] ], [ [ 127281, 127281 ], "mapped", [ 98 ] ], [ [ 127282, 127282 ], "mapped", [ 99 ] ], [ [ 127283, 127283 ], "mapped", [ 100 ] ], [ [ 127284, 127284 ], "mapped", [ 101 ] ], [ [ 127285, 127285 ], "mapped", [ 102 ] ], [ [ 127286, 127286 ], "mapped", [ 103 ] ], [ [ 127287, 127287 ], "mapped", [ 104 ] ], [ [ 127288, 127288 ], "mapped", [ 105 ] ], [ [ 127289, 127289 ], "mapped", [ 106 ] ], [ [ 127290, 127290 ], "mapped", [ 107 ] ], [ [ 127291, 127291 ], "mapped", [ 108 ] ], [ [ 127292, 127292 ], "mapped", [ 109 ] ], [ [ 127293, 127293 ], "mapped", [ 110 ] ], [ [ 127294, 127294 ], "mapped", [ 111 ] ], [ [ 127295, 127295 ], "mapped", [ 112 ] ], [ [ 127296, 127296 ], "mapped", [ 113 ] ], [ [ 127297, 127297 ], "mapped", [ 114 ] ], [ [ 127298, 127298 ], "mapped", [ 115 ] ], [ [ 127299, 127299 ], "mapped", [ 116 ] ], [ [ 127300, 127300 ], "mapped", [ 117 ] ], [ [ 127301, 127301 ], "mapped", [ 118 ] ], [ [ 127302, 127302 ], "mapped", [ 119 ] ], [ [ 127303, 127303 ], "mapped", [ 120 ] ], [ [ 127304, 127304 ], "mapped", [ 121 ] ], [ [ 127305, 127305 ], "mapped", [ 122 ] ], [ [ 127306, 127306 ], "mapped", [ 104, 118 ] ], [ [ 127307, 127307 ], "mapped", [ 109, 118 ] ], [ [ 127308, 127308 ], "mapped", [ 115, 100 ] ], [ [ 127309, 127309 ], "mapped", [ 115, 115 ] ], [ [ 127310, 127310 ], "mapped", [ 112, 112, 118 ] ], [ [ 127311, 127311 ], "mapped", [ 119, 99 ] ], [ [ 127312, 127318 ], "valid", [], "NV8" ], [ [ 127319, 127319 ], "valid", [], "NV8" ], [ [ 127320, 127326 ], "valid", [], "NV8" ], [ [ 127327, 127327 ], "valid", [], "NV8" ], [ [ 127328, 127337 ], "valid", [], "NV8" ], [ [ 127338, 127338 ], "mapped", [ 109, 99 ] ], [ [ 127339, 127339 ], "mapped", [ 109, 100 ] ], [ [ 127340, 127343 ], "disallowed" ], [ [ 127344, 127352 ], "valid", [], "NV8" ], [ [ 127353, 127353 ], "valid", [], "NV8" ], [ [ 127354, 127354 ], "valid", [], "NV8" ], [ [ 127355, 127356 ], "valid", [], "NV8" ], [ [ 127357, 127358 ], "valid", [], "NV8" ], [ [ 127359, 127359 ], "valid", [], "NV8" ], [ [ 127360, 127369 ], "valid", [], "NV8" ], [ [ 127370, 127373 ], "valid", [], "NV8" ], [ [ 127374, 127375 ], "valid", [], "NV8" ], [ [ 127376, 127376 ], "mapped", [ 100, 106 ] ], [ [ 127377, 127386 ], "valid", [], "NV8" ], [ [ 127387, 127461 ], "disallowed" ], [ [ 127462, 127487 ], "valid", [], "NV8" ], [ [ 127488, 127488 ], "mapped", [ 12411, 12363 ] ], [ [ 127489, 127489 ], "mapped", [ 12467, 12467 ] ], [ [ 127490, 127490 ], "mapped", [ 12469 ] ], [ [ 127491, 127503 ], "disallowed" ], [ [ 127504, 127504 ], "mapped", [ 25163 ] ], [ [ 127505, 127505 ], "mapped", [ 23383 ] ], [ [ 127506, 127506 ], "mapped", [ 21452 ] ], [ [ 127507, 127507 ], "mapped", [ 12487 ] ], [ [ 127508, 127508 ], "mapped", [ 20108 ] ], [ [ 127509, 127509 ], "mapped", [ 22810 ] ], [ [ 127510, 127510 ], "mapped", [ 35299 ] ], [ [ 127511, 127511 ], "mapped", [ 22825 ] ], [ [ 127512, 127512 ], "mapped", [ 20132 ] ], [ [ 127513, 127513 ], "mapped", [ 26144 ] ], [ [ 127514, 127514 ], "mapped", [ 28961 ] ], [ [ 127515, 127515 ], "mapped", [ 26009 ] ], [ [ 127516, 127516 ], "mapped", [ 21069 ] ], [ [ 127517, 127517 ], "mapped", [ 24460 ] ], [ [ 127518, 127518 ], "mapped", [ 20877 ] ], [ [ 127519, 127519 ], "mapped", [ 26032 ] ], [ [ 127520, 127520 ], "mapped", [ 21021 ] ], [ [ 127521, 127521 ], "mapped", [ 32066 ] ], [ [ 127522, 127522 ], "mapped", [ 29983 ] ], [ [ 127523, 127523 ], "mapped", [ 36009 ] ], [ [ 127524, 127524 ], "mapped", [ 22768 ] ], [ [ 127525, 127525 ], "mapped", [ 21561 ] ], [ [ 127526, 127526 ], "mapped", [ 28436 ] ], [ [ 127527, 127527 ], "mapped", [ 25237 ] ], [ [ 127528, 127528 ], "mapped", [ 25429 ] ], [ [ 127529, 127529 ], "mapped", [ 19968 ] ], [ [ 127530, 127530 ], "mapped", [ 19977 ] ], [ [ 127531, 127531 ], "mapped", [ 36938 ] ], [ [ 127532, 127532 ], "mapped", [ 24038 ] ], [ [ 127533, 127533 ], "mapped", [ 20013 ] ], [ [ 127534, 127534 ], "mapped", [ 21491 ] ], [ [ 127535, 127535 ], "mapped", [ 25351 ] ], [ [ 127536, 127536 ], "mapped", [ 36208 ] ], [ [ 127537, 127537 ], "mapped", [ 25171 ] ], [ [ 127538, 127538 ], "mapped", [ 31105 ] ], [ [ 127539, 127539 ], "mapped", [ 31354 ] ], [ [ 127540, 127540 ], "mapped", [ 21512 ] ], [ [ 127541, 127541 ], "mapped", [ 28288 ] ], [ [ 127542, 127542 ], "mapped", [ 26377 ] ], [ [ 127543, 127543 ], "mapped", [ 26376 ] ], [ [ 127544, 127544 ], "mapped", [ 30003 ] ], [ [ 127545, 127545 ], "mapped", [ 21106 ] ], [ [ 127546, 127546 ], "mapped", [ 21942 ] ], [ [ 127547, 127551 ], "disallowed" ], [ [ 127552, 127552 ], "mapped", [ 12308, 26412, 12309 ] ], [ [ 127553, 127553 ], "mapped", [ 12308, 19977, 12309 ] ], [ [ 127554, 127554 ], "mapped", [ 12308, 20108, 12309 ] ], [ [ 127555, 127555 ], "mapped", [ 12308, 23433, 12309 ] ], [ [ 127556, 127556 ], "mapped", [ 12308, 28857, 12309 ] ], [ [ 127557, 127557 ], "mapped", [ 12308, 25171, 12309 ] ], [ [ 127558, 127558 ], "mapped", [ 12308, 30423, 12309 ] ], [ [ 127559, 127559 ], "mapped", [ 12308, 21213, 12309 ] ], [ [ 127560, 127560 ], "mapped", [ 12308, 25943, 12309 ] ], [ [ 127561, 127567 ], "disallowed" ], [ [ 127568, 127568 ], "mapped", [ 24471 ] ], [ [ 127569, 127569 ], "mapped", [ 21487 ] ], [ [ 127570, 127743 ], "disallowed" ], [ [ 127744, 127776 ], "valid", [], "NV8" ], [ [ 127777, 127788 ], "valid", [], "NV8" ], [ [ 127789, 127791 ], "valid", [], "NV8" ], [ [ 127792, 127797 ], "valid", [], "NV8" ], [ [ 127798, 127798 ], "valid", [], "NV8" ], [ [ 127799, 127868 ], "valid", [], "NV8" ], [ [ 127869, 127869 ], "valid", [], "NV8" ], [ [ 127870, 127871 ], "valid", [], "NV8" ], [ [ 127872, 127891 ], "valid", [], "NV8" ], [ [ 127892, 127903 ], "valid", [], "NV8" ], [ [ 127904, 127940 ], "valid", [], "NV8" ], [ [ 127941, 127941 ], "valid", [], "NV8" ], [ [ 127942, 127946 ], "valid", [], "NV8" ], [ [ 127947, 127950 ], "valid", [], "NV8" ], [ [ 127951, 127955 ], "valid", [], "NV8" ], [ [ 127956, 127967 ], "valid", [], "NV8" ], [ [ 127968, 127984 ], "valid", [], "NV8" ], [ [ 127985, 127991 ], "valid", [], "NV8" ], [ [ 127992, 127999 ], "valid", [], "NV8" ], [ [ 128e3, 128062 ], "valid", [], "NV8" ], [ [ 128063, 128063 ], "valid", [], "NV8" ], [ [ 128064, 128064 ], "valid", [], "NV8" ], [ [ 128065, 128065 ], "valid", [], "NV8" ], [ [ 128066, 128247 ], "valid", [], "NV8" ], [ [ 128248, 128248 ], "valid", [], "NV8" ], [ [ 128249, 128252 ], "valid", [], "NV8" ], [ [ 128253, 128254 ], "valid", [], "NV8" ], [ [ 128255, 128255 ], "valid", [], "NV8" ], [ [ 128256, 128317 ], "valid", [], "NV8" ], [ [ 128318, 128319 ], "valid", [], "NV8" ], [ [ 128320, 128323 ], "valid", [], "NV8" ], [ [ 128324, 128330 ], "valid", [], "NV8" ], [ [ 128331, 128335 ], "valid", [], "NV8" ], [ [ 128336, 128359 ], "valid", [], "NV8" ], [ [ 128360, 128377 ], "valid", [], "NV8" ], [ [ 128378, 128378 ], "disallowed" ], [ [ 128379, 128419 ], "valid", [], "NV8" ], [ [ 128420, 128420 ], "disallowed" ], [ [ 128421, 128506 ], "valid", [], "NV8" ], [ [ 128507, 128511 ], "valid", [], "NV8" ], [ [ 128512, 128512 ], "valid", [], "NV8" ], [ [ 128513, 128528 ], "valid", [], "NV8" ], [ [ 128529, 128529 ], "valid", [], "NV8" ], [ [ 128530, 128532 ], "valid", [], "NV8" ], [ [ 128533, 128533 ], "valid", [], "NV8" ], [ [ 128534, 128534 ], "valid", [], "NV8" ], [ [ 128535, 128535 ], "valid", [], "NV8" ], [ [ 128536, 128536 ], "valid", [], "NV8" ], [ [ 128537, 128537 ], "valid", [], "NV8" ], [ [ 128538, 128538 ], "valid", [], "NV8" ], [ [ 128539, 128539 ], "valid", [], "NV8" ], [ [ 128540, 128542 ], "valid", [], "NV8" ], [ [ 128543, 128543 ], "valid", [], "NV8" ], [ [ 128544, 128549 ], "valid", [], "NV8" ], [ [ 128550, 128551 ], "valid", [], "NV8" ], [ [ 128552, 128555 ], "valid", [], "NV8" ], [ [ 128556, 128556 ], "valid", [], "NV8" ], [ [ 128557, 128557 ], "valid", [], "NV8" ], [ [ 128558, 128559 ], "valid", [], "NV8" ], [ [ 128560, 128563 ], "valid", [], "NV8" ], [ [ 128564, 128564 ], "valid", [], "NV8" ], [ [ 128565, 128576 ], "valid", [], "NV8" ], [ [ 128577, 128578 ], "valid", [], "NV8" ], [ [ 128579, 128580 ], "valid", [], "NV8" ], [ [ 128581, 128591 ], "valid", [], "NV8" ], [ [ 128592, 128639 ], "valid", [], "NV8" ], [ [ 128640, 128709 ], "valid", [], "NV8" ], [ [ 128710, 128719 ], "valid", [], "NV8" ], [ [ 128720, 128720 ], "valid", [], "NV8" ], [ [ 128721, 128735 ], "disallowed" ], [ [ 128736, 128748 ], "valid", [], "NV8" ], [ [ 128749, 128751 ], "disallowed" ], [ [ 128752, 128755 ], "valid", [], "NV8" ], [ [ 128756, 128767 ], "disallowed" ], [ [ 128768, 128883 ], "valid", [], "NV8" ], [ [ 128884, 128895 ], "disallowed" ], [ [ 128896, 128980 ], "valid", [], "NV8" ], [ [ 128981, 129023 ], "disallowed" ], [ [ 129024, 129035 ], "valid", [], "NV8" ], [ [ 129036, 129039 ], "disallowed" ], [ [ 129040, 129095 ], "valid", [], "NV8" ], [ [ 129096, 129103 ], "disallowed" ], [ [ 129104, 129113 ], "valid", [], "NV8" ], [ [ 129114, 129119 ], "disallowed" ], [ [ 129120, 129159 ], "valid", [], "NV8" ], [ [ 129160, 129167 ], "disallowed" ], [ [ 129168, 129197 ], "valid", [], "NV8" ], [ [ 129198, 129295 ], "disallowed" ], [ [ 129296, 129304 ], "valid", [], "NV8" ], [ [ 129305, 129407 ], "disallowed" ], [ [ 129408, 129412 ], "valid", [], "NV8" ], [ [ 129413, 129471 ], "disallowed" ], [ [ 129472, 129472 ], "valid", [], "NV8" ], [ [ 129473, 131069 ], "disallowed" ], [ [ 131070, 131071 ], "disallowed" ], [ [ 131072, 173782 ], "valid" ], [ [ 173783, 173823 ], "disallowed" ], [ [ 173824, 177972 ], "valid" ], [ [ 177973, 177983 ], "disallowed" ], [ [ 177984, 178205 ], "valid" ], [ [ 178206, 178207 ], "disallowed" ], [ [ 178208, 183969 ], "valid" ], [ [ 183970, 194559 ], "disallowed" ], [ [ 194560, 194560 ], "mapped", [ 20029 ] ], [ [ 194561, 194561 ], "mapped", [ 20024 ] ], [ [ 194562, 194562 ], "mapped", [ 20033 ] ], [ [ 194563, 194563 ], "mapped", [ 131362 ] ], [ [ 194564, 194564 ], "mapped", [ 20320 ] ], [ [ 194565, 194565 ], "mapped", [ 20398 ] ], [ [ 194566, 194566 ], "mapped", [ 20411 ] ], [ [ 194567, 194567 ], "mapped", [ 20482 ] ], [ [ 194568, 194568 ], "mapped", [ 20602 ] ], [ [ 194569, 194569 ], "mapped", [ 20633 ] ], [ [ 194570, 194570 ], "mapped", [ 20711 ] ], [ [ 194571, 194571 ], "mapped", [ 20687 ] ], [ [ 194572, 194572 ], "mapped", [ 13470 ] ], [ [ 194573, 194573 ], "mapped", [ 132666 ] ], [ [ 194574, 194574 ], "mapped", [ 20813 ] ], [ [ 194575, 194575 ], "mapped", [ 20820 ] ], [ [ 194576, 194576 ], "mapped", [ 20836 ] ], [ [ 194577, 194577 ], "mapped", [ 20855 ] ], [ [ 194578, 194578 ], "mapped", [ 132380 ] ], [ [ 194579, 194579 ], "mapped", [ 13497 ] ], [ [ 194580, 194580 ], "mapped", [ 20839 ] ], [ [ 194581, 194581 ], "mapped", [ 20877 ] ], [ [ 194582, 194582 ], "mapped", [ 132427 ] ], [ [ 194583, 194583 ], "mapped", [ 20887 ] ], [ [ 194584, 194584 ], "mapped", [ 20900 ] ], [ [ 194585, 194585 ], "mapped", [ 20172 ] ], [ [ 194586, 194586 ], "mapped", [ 20908 ] ], [ [ 194587, 194587 ], "mapped", [ 20917 ] ], [ [ 194588, 194588 ], "mapped", [ 168415 ] ], [ [ 194589, 194589 ], "mapped", [ 20981 ] ], [ [ 194590, 194590 ], "mapped", [ 20995 ] ], [ [ 194591, 194591 ], "mapped", [ 13535 ] ], [ [ 194592, 194592 ], "mapped", [ 21051 ] ], [ [ 194593, 194593 ], "mapped", [ 21062 ] ], [ [ 194594, 194594 ], "mapped", [ 21106 ] ], [ [ 194595, 194595 ], "mapped", [ 21111 ] ], [ [ 194596, 194596 ], "mapped", [ 13589 ] ], [ [ 194597, 194597 ], "mapped", [ 21191 ] ], [ [ 194598, 194598 ], "mapped", [ 21193 ] ], [ [ 194599, 194599 ], "mapped", [ 21220 ] ], [ [ 194600, 194600 ], "mapped", [ 21242 ] ], [ [ 194601, 194601 ], "mapped", [ 21253 ] ], [ [ 194602, 194602 ], "mapped", [ 21254 ] ], [ [ 194603, 194603 ], "mapped", [ 21271 ] ], [ [ 194604, 194604 ], "mapped", [ 21321 ] ], [ [ 194605, 194605 ], "mapped", [ 21329 ] ], [ [ 194606, 194606 ], "mapped", [ 21338 ] ], [ [ 194607, 194607 ], "mapped", [ 21363 ] ], [ [ 194608, 194608 ], "mapped", [ 21373 ] ], [ [ 194609, 194611 ], "mapped", [ 21375 ] ], [ [ 194612, 194612 ], "mapped", [ 133676 ] ], [ [ 194613, 194613 ], "mapped", [ 28784 ] ], [ [ 194614, 194614 ], "mapped", [ 21450 ] ], [ [ 194615, 194615 ], "mapped", [ 21471 ] ], [ [ 194616, 194616 ], "mapped", [ 133987 ] ], [ [ 194617, 194617 ], "mapped", [ 21483 ] ], [ [ 194618, 194618 ], "mapped", [ 21489 ] ], [ [ 194619, 194619 ], "mapped", [ 21510 ] ], [ [ 194620, 194620 ], "mapped", [ 21662 ] ], [ [ 194621, 194621 ], "mapped", [ 21560 ] ], [ [ 194622, 194622 ], "mapped", [ 21576 ] ], [ [ 194623, 194623 ], "mapped", [ 21608 ] ], [ [ 194624, 194624 ], "mapped", [ 21666 ] ], [ [ 194625, 194625 ], "mapped", [ 21750 ] ], [ [ 194626, 194626 ], "mapped", [ 21776 ] ], [ [ 194627, 194627 ], "mapped", [ 21843 ] ], [ [ 194628, 194628 ], "mapped", [ 21859 ] ], [ [ 194629, 194630 ], "mapped", [ 21892 ] ], [ [ 194631, 194631 ], "mapped", [ 21913 ] ], [ [ 194632, 194632 ], "mapped", [ 21931 ] ], [ [ 194633, 194633 ], "mapped", [ 21939 ] ], [ [ 194634, 194634 ], "mapped", [ 21954 ] ], [ [ 194635, 194635 ], "mapped", [ 22294 ] ], [ [ 194636, 194636 ], "mapped", [ 22022 ] ], [ [ 194637, 194637 ], "mapped", [ 22295 ] ], [ [ 194638, 194638 ], "mapped", [ 22097 ] ], [ [ 194639, 194639 ], "mapped", [ 22132 ] ], [ [ 194640, 194640 ], "mapped", [ 20999 ] ], [ [ 194641, 194641 ], "mapped", [ 22766 ] ], [ [ 194642, 194642 ], "mapped", [ 22478 ] ], [ [ 194643, 194643 ], "mapped", [ 22516 ] ], [ [ 194644, 194644 ], "mapped", [ 22541 ] ], [ [ 194645, 194645 ], "mapped", [ 22411 ] ], [ [ 194646, 194646 ], "mapped", [ 22578 ] ], [ [ 194647, 194647 ], "mapped", [ 22577 ] ], [ [ 194648, 194648 ], "mapped", [ 22700 ] ], [ [ 194649, 194649 ], "mapped", [ 136420 ] ], [ [ 194650, 194650 ], "mapped", [ 22770 ] ], [ [ 194651, 194651 ], "mapped", [ 22775 ] ], [ [ 194652, 194652 ], "mapped", [ 22790 ] ], [ [ 194653, 194653 ], "mapped", [ 22810 ] ], [ [ 194654, 194654 ], "mapped", [ 22818 ] ], [ [ 194655, 194655 ], "mapped", [ 22882 ] ], [ [ 194656, 194656 ], "mapped", [ 136872 ] ], [ [ 194657, 194657 ], "mapped", [ 136938 ] ], [ [ 194658, 194658 ], "mapped", [ 23020 ] ], [ [ 194659, 194659 ], "mapped", [ 23067 ] ], [ [ 194660, 194660 ], "mapped", [ 23079 ] ], [ [ 194661, 194661 ], "mapped", [ 23e3 ] ], [ [ 194662, 194662 ], "mapped", [ 23142 ] ], [ [ 194663, 194663 ], "mapped", [ 14062 ] ], [ [ 194664, 194664 ], "disallowed" ], [ [ 194665, 194665 ], "mapped", [ 23304 ] ], [ [ 194666, 194667 ], "mapped", [ 23358 ] ], [ [ 194668, 194668 ], "mapped", [ 137672 ] ], [ [ 194669, 194669 ], "mapped", [ 23491 ] ], [ [ 194670, 194670 ], "mapped", [ 23512 ] ], [ [ 194671, 194671 ], "mapped", [ 23527 ] ], [ [ 194672, 194672 ], "mapped", [ 23539 ] ], [ [ 194673, 194673 ], "mapped", [ 138008 ] ], [ [ 194674, 194674 ], "mapped", [ 23551 ] ], [ [ 194675, 194675 ], "mapped", [ 23558 ] ], [ [ 194676, 194676 ], "disallowed" ], [ [ 194677, 194677 ], "mapped", [ 23586 ] ], [ [ 194678, 194678 ], "mapped", [ 14209 ] ], [ [ 194679, 194679 ], "mapped", [ 23648 ] ], [ [ 194680, 194680 ], "mapped", [ 23662 ] ], [ [ 194681, 194681 ], "mapped", [ 23744 ] ], [ [ 194682, 194682 ], "mapped", [ 23693 ] ], [ [ 194683, 194683 ], "mapped", [ 138724 ] ], [ [ 194684, 194684 ], "mapped", [ 23875 ] ], [ [ 194685, 194685 ], "mapped", [ 138726 ] ], [ [ 194686, 194686 ], "mapped", [ 23918 ] ], [ [ 194687, 194687 ], "mapped", [ 23915 ] ], [ [ 194688, 194688 ], "mapped", [ 23932 ] ], [ [ 194689, 194689 ], "mapped", [ 24033 ] ], [ [ 194690, 194690 ], "mapped", [ 24034 ] ], [ [ 194691, 194691 ], "mapped", [ 14383 ] ], [ [ 194692, 194692 ], "mapped", [ 24061 ] ], [ [ 194693, 194693 ], "mapped", [ 24104 ] ], [ [ 194694, 194694 ], "mapped", [ 24125 ] ], [ [ 194695, 194695 ], "mapped", [ 24169 ] ], [ [ 194696, 194696 ], "mapped", [ 14434 ] ], [ [ 194697, 194697 ], "mapped", [ 139651 ] ], [ [ 194698, 194698 ], "mapped", [ 14460 ] ], [ [ 194699, 194699 ], "mapped", [ 24240 ] ], [ [ 194700, 194700 ], "mapped", [ 24243 ] ], [ [ 194701, 194701 ], "mapped", [ 24246 ] ], [ [ 194702, 194702 ], "mapped", [ 24266 ] ], [ [ 194703, 194703 ], "mapped", [ 172946 ] ], [ [ 194704, 194704 ], "mapped", [ 24318 ] ], [ [ 194705, 194706 ], "mapped", [ 140081 ] ], [ [ 194707, 194707 ], "mapped", [ 33281 ] ], [ [ 194708, 194709 ], "mapped", [ 24354 ] ], [ [ 194710, 194710 ], "mapped", [ 14535 ] ], [ [ 194711, 194711 ], "mapped", [ 144056 ] ], [ [ 194712, 194712 ], "mapped", [ 156122 ] ], [ [ 194713, 194713 ], "mapped", [ 24418 ] ], [ [ 194714, 194714 ], "mapped", [ 24427 ] ], [ [ 194715, 194715 ], "mapped", [ 14563 ] ], [ [ 194716, 194716 ], "mapped", [ 24474 ] ], [ [ 194717, 194717 ], "mapped", [ 24525 ] ], [ [ 194718, 194718 ], "mapped", [ 24535 ] ], [ [ 194719, 194719 ], "mapped", [ 24569 ] ], [ [ 194720, 194720 ], "mapped", [ 24705 ] ], [ [ 194721, 194721 ], "mapped", [ 14650 ] ], [ [ 194722, 194722 ], "mapped", [ 14620 ] ], [ [ 194723, 194723 ], "mapped", [ 24724 ] ], [ [ 194724, 194724 ], "mapped", [ 141012 ] ], [ [ 194725, 194725 ], "mapped", [ 24775 ] ], [ [ 194726, 194726 ], "mapped", [ 24904 ] ], [ [ 194727, 194727 ], "mapped", [ 24908 ] ], [ [ 194728, 194728 ], "mapped", [ 24910 ] ], [ [ 194729, 194729 ], "mapped", [ 24908 ] ], [ [ 194730, 194730 ], "mapped", [ 24954 ] ], [ [ 194731, 194731 ], "mapped", [ 24974 ] ], [ [ 194732, 194732 ], "mapped", [ 25010 ] ], [ [ 194733, 194733 ], "mapped", [ 24996 ] ], [ [ 194734, 194734 ], "mapped", [ 25007 ] ], [ [ 194735, 194735 ], "mapped", [ 25054 ] ], [ [ 194736, 194736 ], "mapped", [ 25074 ] ], [ [ 194737, 194737 ], "mapped", [ 25078 ] ], [ [ 194738, 194738 ], "mapped", [ 25104 ] ], [ [ 194739, 194739 ], "mapped", [ 25115 ] ], [ [ 194740, 194740 ], "mapped", [ 25181 ] ], [ [ 194741, 194741 ], "mapped", [ 25265 ] ], [ [ 194742, 194742 ], "mapped", [ 25300 ] ], [ [ 194743, 194743 ], "mapped", [ 25424 ] ], [ [ 194744, 194744 ], "mapped", [ 142092 ] ], [ [ 194745, 194745 ], "mapped", [ 25405 ] ], [ [ 194746, 194746 ], "mapped", [ 25340 ] ], [ [ 194747, 194747 ], "mapped", [ 25448 ] ], [ [ 194748, 194748 ], "mapped", [ 25475 ] ], [ [ 194749, 194749 ], "mapped", [ 25572 ] ], [ [ 194750, 194750 ], "mapped", [ 142321 ] ], [ [ 194751, 194751 ], "mapped", [ 25634 ] ], [ [ 194752, 194752 ], "mapped", [ 25541 ] ], [ [ 194753, 194753 ], "mapped", [ 25513 ] ], [ [ 194754, 194754 ], "mapped", [ 14894 ] ], [ [ 194755, 194755 ], "mapped", [ 25705 ] ], [ [ 194756, 194756 ], "mapped", [ 25726 ] ], [ [ 194757, 194757 ], "mapped", [ 25757 ] ], [ [ 194758, 194758 ], "mapped", [ 25719 ] ], [ [ 194759, 194759 ], "mapped", [ 14956 ] ], [ [ 194760, 194760 ], "mapped", [ 25935 ] ], [ [ 194761, 194761 ], "mapped", [ 25964 ] ], [ [ 194762, 194762 ], "mapped", [ 143370 ] ], [ [ 194763, 194763 ], "mapped", [ 26083 ] ], [ [ 194764, 194764 ], "mapped", [ 26360 ] ], [ [ 194765, 194765 ], "mapped", [ 26185 ] ], [ [ 194766, 194766 ], "mapped", [ 15129 ] ], [ [ 194767, 194767 ], "mapped", [ 26257 ] ], [ [ 194768, 194768 ], "mapped", [ 15112 ] ], [ [ 194769, 194769 ], "mapped", [ 15076 ] ], [ [ 194770, 194770 ], "mapped", [ 20882 ] ], [ [ 194771, 194771 ], "mapped", [ 20885 ] ], [ [ 194772, 194772 ], "mapped", [ 26368 ] ], [ [ 194773, 194773 ], "mapped", [ 26268 ] ], [ [ 194774, 194774 ], "mapped", [ 32941 ] ], [ [ 194775, 194775 ], "mapped", [ 17369 ] ], [ [ 194776, 194776 ], "mapped", [ 26391 ] ], [ [ 194777, 194777 ], "mapped", [ 26395 ] ], [ [ 194778, 194778 ], "mapped", [ 26401 ] ], [ [ 194779, 194779 ], "mapped", [ 26462 ] ], [ [ 194780, 194780 ], "mapped", [ 26451 ] ], [ [ 194781, 194781 ], "mapped", [ 144323 ] ], [ [ 194782, 194782 ], "mapped", [ 15177 ] ], [ [ 194783, 194783 ], "mapped", [ 26618 ] ], [ [ 194784, 194784 ], "mapped", [ 26501 ] ], [ [ 194785, 194785 ], "mapped", [ 26706 ] ], [ [ 194786, 194786 ], "mapped", [ 26757 ] ], [ [ 194787, 194787 ], "mapped", [ 144493 ] ], [ [ 194788, 194788 ], "mapped", [ 26766 ] ], [ [ 194789, 194789 ], "mapped", [ 26655 ] ], [ [ 194790, 194790 ], "mapped", [ 26900 ] ], [ [ 194791, 194791 ], "mapped", [ 15261 ] ], [ [ 194792, 194792 ], "mapped", [ 26946 ] ], [ [ 194793, 194793 ], "mapped", [ 27043 ] ], [ [ 194794, 194794 ], "mapped", [ 27114 ] ], [ [ 194795, 194795 ], "mapped", [ 27304 ] ], [ [ 194796, 194796 ], "mapped", [ 145059 ] ], [ [ 194797, 194797 ], "mapped", [ 27355 ] ], [ [ 194798, 194798 ], "mapped", [ 15384 ] ], [ [ 194799, 194799 ], "mapped", [ 27425 ] ], [ [ 194800, 194800 ], "mapped", [ 145575 ] ], [ [ 194801, 194801 ], "mapped", [ 27476 ] ], [ [ 194802, 194802 ], "mapped", [ 15438 ] ], [ [ 194803, 194803 ], "mapped", [ 27506 ] ], [ [ 194804, 194804 ], "mapped", [ 27551 ] ], [ [ 194805, 194805 ], "mapped", [ 27578 ] ], [ [ 194806, 194806 ], "mapped", [ 27579 ] ], [ [ 194807, 194807 ], "mapped", [ 146061 ] ], [ [ 194808, 194808 ], "mapped", [ 138507 ] ], [ [ 194809, 194809 ], "mapped", [ 146170 ] ], [ [ 194810, 194810 ], "mapped", [ 27726 ] ], [ [ 194811, 194811 ], "mapped", [ 146620 ] ], [ [ 194812, 194812 ], "mapped", [ 27839 ] ], [ [ 194813, 194813 ], "mapped", [ 27853 ] ], [ [ 194814, 194814 ], "mapped", [ 27751 ] ], [ [ 194815, 194815 ], "mapped", [ 27926 ] ], [ [ 194816, 194816 ], "mapped", [ 27966 ] ], [ [ 194817, 194817 ], "mapped", [ 28023 ] ], [ [ 194818, 194818 ], "mapped", [ 27969 ] ], [ [ 194819, 194819 ], "mapped", [ 28009 ] ], [ [ 194820, 194820 ], "mapped", [ 28024 ] ], [ [ 194821, 194821 ], "mapped", [ 28037 ] ], [ [ 194822, 194822 ], "mapped", [ 146718 ] ], [ [ 194823, 194823 ], "mapped", [ 27956 ] ], [ [ 194824, 194824 ], "mapped", [ 28207 ] ], [ [ 194825, 194825 ], "mapped", [ 28270 ] ], [ [ 194826, 194826 ], "mapped", [ 15667 ] ], [ [ 194827, 194827 ], "mapped", [ 28363 ] ], [ [ 194828, 194828 ], "mapped", [ 28359 ] ], [ [ 194829, 194829 ], "mapped", [ 147153 ] ], [ [ 194830, 194830 ], "mapped", [ 28153 ] ], [ [ 194831, 194831 ], "mapped", [ 28526 ] ], [ [ 194832, 194832 ], "mapped", [ 147294 ] ], [ [ 194833, 194833 ], "mapped", [ 147342 ] ], [ [ 194834, 194834 ], "mapped", [ 28614 ] ], [ [ 194835, 194835 ], "mapped", [ 28729 ] ], [ [ 194836, 194836 ], "mapped", [ 28702 ] ], [ [ 194837, 194837 ], "mapped", [ 28699 ] ], [ [ 194838, 194838 ], "mapped", [ 15766 ] ], [ [ 194839, 194839 ], "mapped", [ 28746 ] ], [ [ 194840, 194840 ], "mapped", [ 28797 ] ], [ [ 194841, 194841 ], "mapped", [ 28791 ] ], [ [ 194842, 194842 ], "mapped", [ 28845 ] ], [ [ 194843, 194843 ], "mapped", [ 132389 ] ], [ [ 194844, 194844 ], "mapped", [ 28997 ] ], [ [ 194845, 194845 ], "mapped", [ 148067 ] ], [ [ 194846, 194846 ], "mapped", [ 29084 ] ], [ [ 194847, 194847 ], "disallowed" ], [ [ 194848, 194848 ], "mapped", [ 29224 ] ], [ [ 194849, 194849 ], "mapped", [ 29237 ] ], [ [ 194850, 194850 ], "mapped", [ 29264 ] ], [ [ 194851, 194851 ], "mapped", [ 149e3 ] ], [ [ 194852, 194852 ], "mapped", [ 29312 ] ], [ [ 194853, 194853 ], "mapped", [ 29333 ] ], [ [ 194854, 194854 ], "mapped", [ 149301 ] ], [ [ 194855, 194855 ], "mapped", [ 149524 ] ], [ [ 194856, 194856 ], "mapped", [ 29562 ] ], [ [ 194857, 194857 ], "mapped", [ 29579 ] ], [ [ 194858, 194858 ], "mapped", [ 16044 ] ], [ [ 194859, 194859 ], "mapped", [ 29605 ] ], [ [ 194860, 194861 ], "mapped", [ 16056 ] ], [ [ 194862, 194862 ], "mapped", [ 29767 ] ], [ [ 194863, 194863 ], "mapped", [ 29788 ] ], [ [ 194864, 194864 ], "mapped", [ 29809 ] ], [ [ 194865, 194865 ], "mapped", [ 29829 ] ], [ [ 194866, 194866 ], "mapped", [ 29898 ] ], [ [ 194867, 194867 ], "mapped", [ 16155 ] ], [ [ 194868, 194868 ], "mapped", [ 29988 ] ], [ [ 194869, 194869 ], "mapped", [ 150582 ] ], [ [ 194870, 194870 ], "mapped", [ 30014 ] ], [ [ 194871, 194871 ], "mapped", [ 150674 ] ], [ [ 194872, 194872 ], "mapped", [ 30064 ] ], [ [ 194873, 194873 ], "mapped", [ 139679 ] ], [ [ 194874, 194874 ], "mapped", [ 30224 ] ], [ [ 194875, 194875 ], "mapped", [ 151457 ] ], [ [ 194876, 194876 ], "mapped", [ 151480 ] ], [ [ 194877, 194877 ], "mapped", [ 151620 ] ], [ [ 194878, 194878 ], "mapped", [ 16380 ] ], [ [ 194879, 194879 ], "mapped", [ 16392 ] ], [ [ 194880, 194880 ], "mapped", [ 30452 ] ], [ [ 194881, 194881 ], "mapped", [ 151795 ] ], [ [ 194882, 194882 ], "mapped", [ 151794 ] ], [ [ 194883, 194883 ], "mapped", [ 151833 ] ], [ [ 194884, 194884 ], "mapped", [ 151859 ] ], [ [ 194885, 194885 ], "mapped", [ 30494 ] ], [ [ 194886, 194887 ], "mapped", [ 30495 ] ], [ [ 194888, 194888 ], "mapped", [ 30538 ] ], [ [ 194889, 194889 ], "mapped", [ 16441 ] ], [ [ 194890, 194890 ], "mapped", [ 30603 ] ], [ [ 194891, 194891 ], "mapped", [ 16454 ] ], [ [ 194892, 194892 ], "mapped", [ 16534 ] ], [ [ 194893, 194893 ], "mapped", [ 152605 ] ], [ [ 194894, 194894 ], "mapped", [ 30798 ] ], [ [ 194895, 194895 ], "mapped", [ 30860 ] ], [ [ 194896, 194896 ], "mapped", [ 30924 ] ], [ [ 194897, 194897 ], "mapped", [ 16611 ] ], [ [ 194898, 194898 ], "mapped", [ 153126 ] ], [ [ 194899, 194899 ], "mapped", [ 31062 ] ], [ [ 194900, 194900 ], "mapped", [ 153242 ] ], [ [ 194901, 194901 ], "mapped", [ 153285 ] ], [ [ 194902, 194902 ], "mapped", [ 31119 ] ], [ [ 194903, 194903 ], "mapped", [ 31211 ] ], [ [ 194904, 194904 ], "mapped", [ 16687 ] ], [ [ 194905, 194905 ], "mapped", [ 31296 ] ], [ [ 194906, 194906 ], "mapped", [ 31306 ] ], [ [ 194907, 194907 ], "mapped", [ 31311 ] ], [ [ 194908, 194908 ], "mapped", [ 153980 ] ], [ [ 194909, 194910 ], "mapped", [ 154279 ] ], [ [ 194911, 194911 ], "disallowed" ], [ [ 194912, 194912 ], "mapped", [ 16898 ] ], [ [ 194913, 194913 ], "mapped", [ 154539 ] ], [ [ 194914, 194914 ], "mapped", [ 31686 ] ], [ [ 194915, 194915 ], "mapped", [ 31689 ] ], [ [ 194916, 194916 ], "mapped", [ 16935 ] ], [ [ 194917, 194917 ], "mapped", [ 154752 ] ], [ [ 194918, 194918 ], "mapped", [ 31954 ] ], [ [ 194919, 194919 ], "mapped", [ 17056 ] ], [ [ 194920, 194920 ], "mapped", [ 31976 ] ], [ [ 194921, 194921 ], "mapped", [ 31971 ] ], [ [ 194922, 194922 ], "mapped", [ 32e3 ] ], [ [ 194923, 194923 ], "mapped", [ 155526 ] ], [ [ 194924, 194924 ], "mapped", [ 32099 ] ], [ [ 194925, 194925 ], "mapped", [ 17153 ] ], [ [ 194926, 194926 ], "mapped", [ 32199 ] ], [ [ 194927, 194927 ], "mapped", [ 32258 ] ], [ [ 194928, 194928 ], "mapped", [ 32325 ] ], [ [ 194929, 194929 ], "mapped", [ 17204 ] ], [ [ 194930, 194930 ], "mapped", [ 156200 ] ], [ [ 194931, 194931 ], "mapped", [ 156231 ] ], [ [ 194932, 194932 ], "mapped", [ 17241 ] ], [ [ 194933, 194933 ], "mapped", [ 156377 ] ], [ [ 194934, 194934 ], "mapped", [ 32634 ] ], [ [ 194935, 194935 ], "mapped", [ 156478 ] ], [ [ 194936, 194936 ], "mapped", [ 32661 ] ], [ [ 194937, 194937 ], "mapped", [ 32762 ] ], [ [ 194938, 194938 ], "mapped", [ 32773 ] ], [ [ 194939, 194939 ], "mapped", [ 156890 ] ], [ [ 194940, 194940 ], "mapped", [ 156963 ] ], [ [ 194941, 194941 ], "mapped", [ 32864 ] ], [ [ 194942, 194942 ], "mapped", [ 157096 ] ], [ [ 194943, 194943 ], "mapped", [ 32880 ] ], [ [ 194944, 194944 ], "mapped", [ 144223 ] ], [ [ 194945, 194945 ], "mapped", [ 17365 ] ], [ [ 194946, 194946 ], "mapped", [ 32946 ] ], [ [ 194947, 194947 ], "mapped", [ 33027 ] ], [ [ 194948, 194948 ], "mapped", [ 17419 ] ], [ [ 194949, 194949 ], "mapped", [ 33086 ] ], [ [ 194950, 194950 ], "mapped", [ 23221 ] ], [ [ 194951, 194951 ], "mapped", [ 157607 ] ], [ [ 194952, 194952 ], "mapped", [ 157621 ] ], [ [ 194953, 194953 ], "mapped", [ 144275 ] ], [ [ 194954, 194954 ], "mapped", [ 144284 ] ], [ [ 194955, 194955 ], "mapped", [ 33281 ] ], [ [ 194956, 194956 ], "mapped", [ 33284 ] ], [ [ 194957, 194957 ], "mapped", [ 36766 ] ], [ [ 194958, 194958 ], "mapped", [ 17515 ] ], [ [ 194959, 194959 ], "mapped", [ 33425 ] ], [ [ 194960, 194960 ], "mapped", [ 33419 ] ], [ [ 194961, 194961 ], "mapped", [ 33437 ] ], [ [ 194962, 194962 ], "mapped", [ 21171 ] ], [ [ 194963, 194963 ], "mapped", [ 33457 ] ], [ [ 194964, 194964 ], "mapped", [ 33459 ] ], [ [ 194965, 194965 ], "mapped", [ 33469 ] ], [ [ 194966, 194966 ], "mapped", [ 33510 ] ], [ [ 194967, 194967 ], "mapped", [ 158524 ] ], [ [ 194968, 194968 ], "mapped", [ 33509 ] ], [ [ 194969, 194969 ], "mapped", [ 33565 ] ], [ [ 194970, 194970 ], "mapped", [ 33635 ] ], [ [ 194971, 194971 ], "mapped", [ 33709 ] ], [ [ 194972, 194972 ], "mapped", [ 33571 ] ], [ [ 194973, 194973 ], "mapped", [ 33725 ] ], [ [ 194974, 194974 ], "mapped", [ 33767 ] ], [ [ 194975, 194975 ], "mapped", [ 33879 ] ], [ [ 194976, 194976 ], "mapped", [ 33619 ] ], [ [ 194977, 194977 ], "mapped", [ 33738 ] ], [ [ 194978, 194978 ], "mapped", [ 33740 ] ], [ [ 194979, 194979 ], "mapped", [ 33756 ] ], [ [ 194980, 194980 ], "mapped", [ 158774 ] ], [ [ 194981, 194981 ], "mapped", [ 159083 ] ], [ [ 194982, 194982 ], "mapped", [ 158933 ] ], [ [ 194983, 194983 ], "mapped", [ 17707 ] ], [ [ 194984, 194984 ], "mapped", [ 34033 ] ], [ [ 194985, 194985 ], "mapped", [ 34035 ] ], [ [ 194986, 194986 ], "mapped", [ 34070 ] ], [ [ 194987, 194987 ], "mapped", [ 160714 ] ], [ [ 194988, 194988 ], "mapped", [ 34148 ] ], [ [ 194989, 194989 ], "mapped", [ 159532 ] ], [ [ 194990, 194990 ], "mapped", [ 17757 ] ], [ [ 194991, 194991 ], "mapped", [ 17761 ] ], [ [ 194992, 194992 ], "mapped", [ 159665 ] ], [ [ 194993, 194993 ], "mapped", [ 159954 ] ], [ [ 194994, 194994 ], "mapped", [ 17771 ] ], [ [ 194995, 194995 ], "mapped", [ 34384 ] ], [ [ 194996, 194996 ], "mapped", [ 34396 ] ], [ [ 194997, 194997 ], "mapped", [ 34407 ] ], [ [ 194998, 194998 ], "mapped", [ 34409 ] ], [ [ 194999, 194999 ], "mapped", [ 34473 ] ], [ [ 195e3, 195e3 ], "mapped", [ 34440 ] ], [ [ 195001, 195001 ], "mapped", [ 34574 ] ], [ [ 195002, 195002 ], "mapped", [ 34530 ] ], [ [ 195003, 195003 ], "mapped", [ 34681 ] ], [ [ 195004, 195004 ], "mapped", [ 34600 ] ], [ [ 195005, 195005 ], "mapped", [ 34667 ] ], [ [ 195006, 195006 ], "mapped", [ 34694 ] ], [ [ 195007, 195007 ], "disallowed" ], [ [ 195008, 195008 ], "mapped", [ 34785 ] ], [ [ 195009, 195009 ], "mapped", [ 34817 ] ], [ [ 195010, 195010 ], "mapped", [ 17913 ] ], [ [ 195011, 195011 ], "mapped", [ 34912 ] ], [ [ 195012, 195012 ], "mapped", [ 34915 ] ], [ [ 195013, 195013 ], "mapped", [ 161383 ] ], [ [ 195014, 195014 ], "mapped", [ 35031 ] ], [ [ 195015, 195015 ], "mapped", [ 35038 ] ], [ [ 195016, 195016 ], "mapped", [ 17973 ] ], [ [ 195017, 195017 ], "mapped", [ 35066 ] ], [ [ 195018, 195018 ], "mapped", [ 13499 ] ], [ [ 195019, 195019 ], "mapped", [ 161966 ] ], [ [ 195020, 195020 ], "mapped", [ 162150 ] ], [ [ 195021, 195021 ], "mapped", [ 18110 ] ], [ [ 195022, 195022 ], "mapped", [ 18119 ] ], [ [ 195023, 195023 ], "mapped", [ 35488 ] ], [ [ 195024, 195024 ], "mapped", [ 35565 ] ], [ [ 195025, 195025 ], "mapped", [ 35722 ] ], [ [ 195026, 195026 ], "mapped", [ 35925 ] ], [ [ 195027, 195027 ], "mapped", [ 162984 ] ], [ [ 195028, 195028 ], "mapped", [ 36011 ] ], [ [ 195029, 195029 ], "mapped", [ 36033 ] ], [ [ 195030, 195030 ], "mapped", [ 36123 ] ], [ [ 195031, 195031 ], "mapped", [ 36215 ] ], [ [ 195032, 195032 ], "mapped", [ 163631 ] ], [ [ 195033, 195033 ], "mapped", [ 133124 ] ], [ [ 195034, 195034 ], "mapped", [ 36299 ] ], [ [ 195035, 195035 ], "mapped", [ 36284 ] ], [ [ 195036, 195036 ], "mapped", [ 36336 ] ], [ [ 195037, 195037 ], "mapped", [ 133342 ] ], [ [ 195038, 195038 ], "mapped", [ 36564 ] ], [ [ 195039, 195039 ], "mapped", [ 36664 ] ], [ [ 195040, 195040 ], "mapped", [ 165330 ] ], [ [ 195041, 195041 ], "mapped", [ 165357 ] ], [ [ 195042, 195042 ], "mapped", [ 37012 ] ], [ [ 195043, 195043 ], "mapped", [ 37105 ] ], [ [ 195044, 195044 ], "mapped", [ 37137 ] ], [ [ 195045, 195045 ], "mapped", [ 165678 ] ], [ [ 195046, 195046 ], "mapped", [ 37147 ] ], [ [ 195047, 195047 ], "mapped", [ 37432 ] ], [ [ 195048, 195048 ], "mapped", [ 37591 ] ], [ [ 195049, 195049 ], "mapped", [ 37592 ] ], [ [ 195050, 195050 ], "mapped", [ 37500 ] ], [ [ 195051, 195051 ], "mapped", [ 37881 ] ], [ [ 195052, 195052 ], "mapped", [ 37909 ] ], [ [ 195053, 195053 ], "mapped", [ 166906 ] ], [ [ 195054, 195054 ], "mapped", [ 38283 ] ], [ [ 195055, 195055 ], "mapped", [ 18837 ] ], [ [ 195056, 195056 ], "mapped", [ 38327 ] ], [ [ 195057, 195057 ], "mapped", [ 167287 ] ], [ [ 195058, 195058 ], "mapped", [ 18918 ] ], [ [ 195059, 195059 ], "mapped", [ 38595 ] ], [ [ 195060, 195060 ], "mapped", [ 23986 ] ], [ [ 195061, 195061 ], "mapped", [ 38691 ] ], [ [ 195062, 195062 ], "mapped", [ 168261 ] ], [ [ 195063, 195063 ], "mapped", [ 168474 ] ], [ [ 195064, 195064 ], "mapped", [ 19054 ] ], [ [ 195065, 195065 ], "mapped", [ 19062 ] ], [ [ 195066, 195066 ], "mapped", [ 38880 ] ], [ [ 195067, 195067 ], "mapped", [ 168970 ] ], [ [ 195068, 195068 ], "mapped", [ 19122 ] ], [ [ 195069, 195069 ], "mapped", [ 169110 ] ], [ [ 195070, 195071 ], "mapped", [ 38923 ] ], [ [ 195072, 195072 ], "mapped", [ 38953 ] ], [ [ 195073, 195073 ], "mapped", [ 169398 ] ], [ [ 195074, 195074 ], "mapped", [ 39138 ] ], [ [ 195075, 195075 ], "mapped", [ 19251 ] ], [ [ 195076, 195076 ], "mapped", [ 39209 ] ], [ [ 195077, 195077 ], "mapped", [ 39335 ] ], [ [ 195078, 195078 ], "mapped", [ 39362 ] ], [ [ 195079, 195079 ], "mapped", [ 39422 ] ], [ [ 195080, 195080 ], "mapped", [ 19406 ] ], [ [ 195081, 195081 ], "mapped", [ 170800 ] ], [ [ 195082, 195082 ], "mapped", [ 39698 ] ], [ [ 195083, 195083 ], "mapped", [ 4e4 ] ], [ [ 195084, 195084 ], "mapped", [ 40189 ] ], [ [ 195085, 195085 ], "mapped", [ 19662 ] ], [ [ 195086, 195086 ], "mapped", [ 19693 ] ], [ [ 195087, 195087 ], "mapped", [ 40295 ] ], [ [ 195088, 195088 ], "mapped", [ 172238 ] ], [ [ 195089, 195089 ], "mapped", [ 19704 ] ], [ [ 195090, 195090 ], "mapped", [ 172293 ] ], [ [ 195091, 195091 ], "mapped", [ 172558 ] ], [ [ 195092, 195092 ], "mapped", [ 172689 ] ], [ [ 195093, 195093 ], "mapped", [ 40635 ] ], [ [ 195094, 195094 ], "mapped", [ 19798 ] ], [ [ 195095, 195095 ], "mapped", [ 40697 ] ], [ [ 195096, 195096 ], "mapped", [ 40702 ] ], [ [ 195097, 195097 ], "mapped", [ 40709 ] ], [ [ 195098, 195098 ], "mapped", [ 40719 ] ], [ [ 195099, 195099 ], "mapped", [ 40726 ] ], [ [ 195100, 195100 ], "mapped", [ 40763 ] ], [ [ 195101, 195101 ], "mapped", [ 173568 ] ], [ [ 195102, 196605 ], "disallowed" ], [ [ 196606, 196607 ], "disallowed" ], [ [ 196608, 262141 ], "disallowed" ], [ [ 262142, 262143 ], "disallowed" ], [ [ 262144, 327677 ], "disallowed" ], [ [ 327678, 327679 ], "disallowed" ], [ [ 327680, 393213 ], "disallowed" ], [ [ 393214, 393215 ], "disallowed" ], [ [ 393216, 458749 ], "disallowed" ], [ [ 458750, 458751 ], "disallowed" ], [ [ 458752, 524285 ], "disallowed" ], [ [ 524286, 524287 ], "disallowed" ], [ [ 524288, 589821 ], "disallowed" ], [ [ 589822, 589823 ], "disallowed" ], [ [ 589824, 655357 ], "disallowed" ], [ [ 655358, 655359 ], "disallowed" ], [ [ 655360, 720893 ], "disallowed" ], [ [ 720894, 720895 ], "disallowed" ], [ [ 720896, 786429 ], "disallowed" ], [ [ 786430, 786431 ], "disallowed" ], [ [ 786432, 851965 ], "disallowed" ], [ [ 851966, 851967 ], "disallowed" ], [ [ 851968, 917501 ], "disallowed" ], [ [ 917502, 917503 ], "disallowed" ], [ [ 917504, 917504 ], "disallowed" ], [ [ 917505, 917505 ], "disallowed" ], [ [ 917506, 917535 ], "disallowed" ], [ [ 917536, 917631 ], "disallowed" ], [ [ 917632, 917759 ], "disallowed" ], [ [ 917760, 917999 ], "ignored" ], [ [ 918e3, 983037 ], "disallowed" ], [ [ 983038, 983039 ], "disallowed" ], [ [ 983040, 1048573 ], "disallowed" ], [ [ 1048574, 1048575 ], "disallowed" ], [ [ 1048576, 1114109 ], "disallowed" ], [ [ 1114110, 1114111 ], "disallowed" ] ];
    var punycode = punycode_1;
    var mappingTable = require$1;
    var PROCESSING_OPTIONS = {
        TRANSITIONAL: 0,
        NONTRANSITIONAL: 1
    };
    function normalize(str) {
        return str.split("\0").map((function(s) {
            return s.normalize("NFC");
        })).join("\0");
    }
    function findStatus(val) {
        var start = 0;
        var end = mappingTable.length - 1;
        while (start <= end) {
            var mid = Math.floor((start + end) / 2);
            var target = mappingTable[mid];
            if (target[0][0] <= val && target[0][1] >= val) {
                return target;
            } else if (target[0][0] > val) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
        return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
        var hasError = false;
        var processed = "";
        var len = countSymbols(domain_name);
        for (var i = 0; i < len; ++i) {
            var codePoint = domain_name.codePointAt(i);
            var status = findStatus(codePoint);
            switch (status[1]) {
              case "disallowed":
                hasError = true;
                processed += String.fromCodePoint(codePoint);
                break;

              case "ignored":
                break;

              case "mapped":
                processed += String.fromCodePoint.apply(String, status[2]);
                break;

              case "deviation":
                if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                    processed += String.fromCodePoint.apply(String, status[2]);
                } else {
                    processed += String.fromCodePoint(codePoint);
                }
                break;

              case "valid":
                processed += String.fromCodePoint(codePoint);
                break;

              case "disallowed_STD3_mapped":
                if (useSTD3) {
                    hasError = true;
                    processed += String.fromCodePoint(codePoint);
                } else {
                    processed += String.fromCodePoint.apply(String, status[2]);
                }
                break;

              case "disallowed_STD3_valid":
                if (useSTD3) {
                    hasError = true;
                }
                processed += String.fromCodePoint(codePoint);
                break;
            }
        }
        return {
            string: processed,
            error: hasError
        };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
        if (label.substr(0, 4) === "xn--") {
            label = punycode.toUnicode(label);
            PROCESSING_OPTIONS.NONTRANSITIONAL;
        }
        var error = false;
        if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
            error = true;
        }
        var len = countSymbols(label);
        for (var i = 0; i < len; ++i) {
            var status = findStatus(label.codePointAt(i));
            if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
                error = true;
                break;
            }
        }
        return {
            label: label,
            error: error
        };
    }
    function processing(domain_name, useSTD3, processing_option) {
        var result = mapChars(domain_name, useSTD3, processing_option);
        result.string = normalize(result.string);
        var labels = result.string.split(".");
        for (var i = 0; i < labels.length; ++i) {
            try {
                var validation = validateLabel(labels[i]);
                labels[i] = validation.label;
                result.error = result.error || validation.error;
            } catch (e) {
                result.error = true;
            }
        }
        return {
            string: labels.join("."),
            error: result.error
        };
    }
    tr46.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
        var result = processing(domain_name, useSTD3, processing_option);
        var labels = result.string.split(".");
        labels = labels.map((function(l) {
            try {
                return punycode.toASCII(l);
            } catch (e) {
                result.error = true;
                return l;
            }
        }));
        if (verifyDnsLength) {
            var total = labels.slice(0, labels.length - 1).join(".").length;
            if (total.length > 253 || total.length === 0) {
                result.error = true;
            }
            for (var i = 0; i < labels.length; ++i) {
                if (labels.length > 63 || labels.length === 0) {
                    result.error = true;
                    break;
                }
            }
        }
        if (result.error) return null;
        return labels.join(".");
    };
    tr46.toUnicode = function(domain_name, useSTD3) {
        var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
        return {
            domain: result.string,
            error: result.error
        };
    };
    tr46.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    (function(module) {
        const punycode = punycode_1;
        const tr46$1 = tr46;
        const specialSchemes = {
            ftp: 21,
            file: null,
            gopher: 70,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        };
        const failure = Symbol("failure");
        function countSymbols(str) {
            return punycode.ucs2.decode(str).length;
        }
        function at(input, idx) {
            const c = input[idx];
            return isNaN(c) ? undefined : String.fromCodePoint(c);
        }
        function isASCIIDigit(c) {
            return c >= 48 && c <= 57;
        }
        function isASCIIAlpha(c) {
            return c >= 65 && c <= 90 || c >= 97 && c <= 122;
        }
        function isASCIIAlphanumeric(c) {
            return isASCIIAlpha(c) || isASCIIDigit(c);
        }
        function isASCIIHex(c) {
            return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
        }
        function isSingleDot(buffer) {
            return buffer === "." || buffer.toLowerCase() === "%2e";
        }
        function isDoubleDot(buffer) {
            buffer = buffer.toLowerCase();
            return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
        }
        function isWindowsDriveLetterCodePoints(cp1, cp2) {
            return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
        }
        function isWindowsDriveLetterString(string) {
            return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
        }
        function isNormalizedWindowsDriveLetterString(string) {
            return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
        }
        function containsForbiddenHostCodePoint(string) {
            return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
        }
        function containsForbiddenHostCodePointExcludingPercent(string) {
            return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
        }
        function isSpecialScheme(scheme) {
            return specialSchemes[scheme] !== undefined;
        }
        function isSpecial(url) {
            return isSpecialScheme(url.scheme);
        }
        function defaultPort(scheme) {
            return specialSchemes[scheme];
        }
        function percentEncode(c) {
            let hex = c.toString(16).toUpperCase();
            if (hex.length === 1) {
                hex = "0" + hex;
            }
            return "%" + hex;
        }
        function utf8PercentEncode(c) {
            const buf = new Buffer(c);
            let str = "";
            for (let i = 0; i < buf.length; ++i) {
                str += percentEncode(buf[i]);
            }
            return str;
        }
        function utf8PercentDecode(str) {
            const input = new Buffer(str);
            const output = [];
            for (let i = 0; i < input.length; ++i) {
                if (input[i] !== 37) {
                    output.push(input[i]);
                } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
                    output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
                    i += 2;
                } else {
                    output.push(input[i]);
                }
            }
            return new Buffer(output).toString();
        }
        function isC0ControlPercentEncode(c) {
            return c <= 31 || c > 126;
        }
        const extraPathPercentEncodeSet = new Set([ 32, 34, 35, 60, 62, 63, 96, 123, 125 ]);
        function isPathPercentEncode(c) {
            return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
        }
        const extraUserinfoPercentEncodeSet = new Set([ 47, 58, 59, 61, 64, 91, 92, 93, 94, 124 ]);
        function isUserinfoPercentEncode(c) {
            return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
        }
        function percentEncodeChar(c, encodeSetPredicate) {
            const cStr = String.fromCodePoint(c);
            if (encodeSetPredicate(c)) {
                return utf8PercentEncode(cStr);
            }
            return cStr;
        }
        function parseIPv4Number(input) {
            let R = 10;
            if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
                input = input.substring(2);
                R = 16;
            } else if (input.length >= 2 && input.charAt(0) === "0") {
                input = input.substring(1);
                R = 8;
            }
            if (input === "") {
                return 0;
            }
            const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
            if (regex.test(input)) {
                return failure;
            }
            return parseInt(input, R);
        }
        function parseIPv4(input) {
            const parts = input.split(".");
            if (parts[parts.length - 1] === "") {
                if (parts.length > 1) {
                    parts.pop();
                }
            }
            if (parts.length > 4) {
                return input;
            }
            const numbers = [];
            for (const part of parts) {
                if (part === "") {
                    return input;
                }
                const n = parseIPv4Number(part);
                if (n === failure) {
                    return input;
                }
                numbers.push(n);
            }
            for (let i = 0; i < numbers.length - 1; ++i) {
                if (numbers[i] > 255) {
                    return failure;
                }
            }
            if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
                return failure;
            }
            let ipv4 = numbers.pop();
            let counter = 0;
            for (const n of numbers) {
                ipv4 += n * Math.pow(256, 3 - counter);
                ++counter;
            }
            return ipv4;
        }
        function serializeIPv4(address) {
            let output = "";
            let n = address;
            for (let i = 1; i <= 4; ++i) {
                output = String(n % 256) + output;
                if (i !== 4) {
                    output = "." + output;
                }
                n = Math.floor(n / 256);
            }
            return output;
        }
        function parseIPv6(input) {
            const address = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
            let pieceIndex = 0;
            let compress = null;
            let pointer = 0;
            input = punycode.ucs2.decode(input);
            if (input[pointer] === 58) {
                if (input[pointer + 1] !== 58) {
                    return failure;
                }
                pointer += 2;
                ++pieceIndex;
                compress = pieceIndex;
            }
            while (pointer < input.length) {
                if (pieceIndex === 8) {
                    return failure;
                }
                if (input[pointer] === 58) {
                    if (compress !== null) {
                        return failure;
                    }
                    ++pointer;
                    ++pieceIndex;
                    compress = pieceIndex;
                    continue;
                }
                let value = 0;
                let length = 0;
                while (length < 4 && isASCIIHex(input[pointer])) {
                    value = value * 16 + parseInt(at(input, pointer), 16);
                    ++pointer;
                    ++length;
                }
                if (input[pointer] === 46) {
                    if (length === 0) {
                        return failure;
                    }
                    pointer -= length;
                    if (pieceIndex > 6) {
                        return failure;
                    }
                    let numbersSeen = 0;
                    while (input[pointer] !== undefined) {
                        let ipv4Piece = null;
                        if (numbersSeen > 0) {
                            if (input[pointer] === 46 && numbersSeen < 4) {
                                ++pointer;
                            } else {
                                return failure;
                            }
                        }
                        if (!isASCIIDigit(input[pointer])) {
                            return failure;
                        }
                        while (isASCIIDigit(input[pointer])) {
                            const number = parseInt(at(input, pointer));
                            if (ipv4Piece === null) {
                                ipv4Piece = number;
                            } else if (ipv4Piece === 0) {
                                return failure;
                            } else {
                                ipv4Piece = ipv4Piece * 10 + number;
                            }
                            if (ipv4Piece > 255) {
                                return failure;
                            }
                            ++pointer;
                        }
                        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                        ++numbersSeen;
                        if (numbersSeen === 2 || numbersSeen === 4) {
                            ++pieceIndex;
                        }
                    }
                    if (numbersSeen !== 4) {
                        return failure;
                    }
                    break;
                } else if (input[pointer] === 58) {
                    ++pointer;
                    if (input[pointer] === undefined) {
                        return failure;
                    }
                } else if (input[pointer] !== undefined) {
                    return failure;
                }
                address[pieceIndex] = value;
                ++pieceIndex;
            }
            if (compress !== null) {
                let swaps = pieceIndex - compress;
                pieceIndex = 7;
                while (pieceIndex !== 0 && swaps > 0) {
                    const temp = address[compress + swaps - 1];
                    address[compress + swaps - 1] = address[pieceIndex];
                    address[pieceIndex] = temp;
                    --pieceIndex;
                    --swaps;
                }
            } else if (compress === null && pieceIndex !== 8) {
                return failure;
            }
            return address;
        }
        function serializeIPv6(address) {
            let output = "";
            const seqResult = findLongestZeroSequence(address);
            const compress = seqResult.idx;
            let ignore0 = false;
            for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
                if (ignore0 && address[pieceIndex] === 0) {
                    continue;
                } else if (ignore0) {
                    ignore0 = false;
                }
                if (compress === pieceIndex) {
                    const separator = pieceIndex === 0 ? "::" : ":";
                    output += separator;
                    ignore0 = true;
                    continue;
                }
                output += address[pieceIndex].toString(16);
                if (pieceIndex !== 7) {
                    output += ":";
                }
            }
            return output;
        }
        function parseHost(input, isSpecialArg) {
            if (input[0] === "[") {
                if (input[input.length - 1] !== "]") {
                    return failure;
                }
                return parseIPv6(input.substring(1, input.length - 1));
            }
            if (!isSpecialArg) {
                return parseOpaqueHost(input);
            }
            const domain = utf8PercentDecode(input);
            const asciiDomain = tr46$1.toASCII(domain, false, tr46$1.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
            if (asciiDomain === null) {
                return failure;
            }
            if (containsForbiddenHostCodePoint(asciiDomain)) {
                return failure;
            }
            const ipv4Host = parseIPv4(asciiDomain);
            if (typeof ipv4Host === "number" || ipv4Host === failure) {
                return ipv4Host;
            }
            return asciiDomain;
        }
        function parseOpaqueHost(input) {
            if (containsForbiddenHostCodePointExcludingPercent(input)) {
                return failure;
            }
            let output = "";
            const decoded = punycode.ucs2.decode(input);
            for (let i = 0; i < decoded.length; ++i) {
                output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
            }
            return output;
        }
        function findLongestZeroSequence(arr) {
            let maxIdx = null;
            let maxLen = 1;
            let currStart = null;
            let currLen = 0;
            for (let i = 0; i < arr.length; ++i) {
                if (arr[i] !== 0) {
                    if (currLen > maxLen) {
                        maxIdx = currStart;
                        maxLen = currLen;
                    }
                    currStart = null;
                    currLen = 0;
                } else {
                    if (currStart === null) {
                        currStart = i;
                    }
                    ++currLen;
                }
            }
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            return {
                idx: maxIdx,
                len: maxLen
            };
        }
        function serializeHost(host) {
            if (typeof host === "number") {
                return serializeIPv4(host);
            }
            if (host instanceof Array) {
                return "[" + serializeIPv6(host) + "]";
            }
            return host;
        }
        function trimControlChars(url) {
            return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
        }
        function trimTabAndNewline(url) {
            return url.replace(/\u0009|\u000A|\u000D/g, "");
        }
        function shortenPath(url) {
            const path = url.path;
            if (path.length === 0) {
                return;
            }
            if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
                return;
            }
            path.pop();
        }
        function includesCredentials(url) {
            return url.username !== "" || url.password !== "";
        }
        function cannotHaveAUsernamePasswordPort(url) {
            return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
        }
        function isNormalizedWindowsDriveLetter(string) {
            return /^[A-Za-z]:$/.test(string);
        }
        function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
            this.pointer = 0;
            this.input = input;
            this.base = base || null;
            this.encodingOverride = encodingOverride || "utf-8";
            this.stateOverride = stateOverride;
            this.url = url;
            this.failure = false;
            this.parseError = false;
            if (!this.url) {
                this.url = {
                    scheme: "",
                    username: "",
                    password: "",
                    host: null,
                    port: null,
                    path: [],
                    query: null,
                    fragment: null,
                    cannotBeABaseURL: false
                };
                const res = trimControlChars(this.input);
                if (res !== this.input) {
                    this.parseError = true;
                }
                this.input = res;
            }
            const res = trimTabAndNewline(this.input);
            if (res !== this.input) {
                this.parseError = true;
            }
            this.input = res;
            this.state = stateOverride || "scheme start";
            this.buffer = "";
            this.atFlag = false;
            this.arrFlag = false;
            this.passwordTokenSeenFlag = false;
            this.input = punycode.ucs2.decode(this.input);
            for (;this.pointer <= this.input.length; ++this.pointer) {
                const c = this.input[this.pointer];
                const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
                const ret = this["parse " + this.state](c, cStr);
                if (!ret) {
                    break;
                } else if (ret === failure) {
                    this.failure = true;
                    break;
                }
            }
        }
        URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
            if (isASCIIAlpha(c)) {
                this.buffer += cStr.toLowerCase();
                this.state = "scheme";
            } else if (!this.stateOverride) {
                this.state = "no scheme";
                --this.pointer;
            } else {
                this.parseError = true;
                return failure;
            }
            return true;
        };
        URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
            if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
                this.buffer += cStr.toLowerCase();
            } else if (c === 58) {
                if (this.stateOverride) {
                    if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                        return false;
                    }
                    if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                        return false;
                    }
                    if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                        return false;
                    }
                    if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                        return false;
                    }
                }
                this.url.scheme = this.buffer;
                this.buffer = "";
                if (this.stateOverride) {
                    return false;
                }
                if (this.url.scheme === "file") {
                    if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                        this.parseError = true;
                    }
                    this.state = "file";
                } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
                    this.state = "special relative or authority";
                } else if (isSpecial(this.url)) {
                    this.state = "special authority slashes";
                } else if (this.input[this.pointer + 1] === 47) {
                    this.state = "path or authority";
                    ++this.pointer;
                } else {
                    this.url.cannotBeABaseURL = true;
                    this.url.path.push("");
                    this.state = "cannot-be-a-base-URL path";
                }
            } else if (!this.stateOverride) {
                this.buffer = "";
                this.state = "no scheme";
                this.pointer = -1;
            } else {
                this.parseError = true;
                return failure;
            }
            return true;
        };
        URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
            if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
                return failure;
            } else if (this.base.cannotBeABaseURL && c === 35) {
                this.url.scheme = this.base.scheme;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.url.cannotBeABaseURL = true;
                this.state = "fragment";
            } else if (this.base.scheme === "file") {
                this.state = "file";
                --this.pointer;
            } else {
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
            if (c === 47 && this.input[this.pointer + 1] === 47) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
            if (c === 47) {
                this.state = "authority";
            } else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
            this.url.scheme = this.base.scheme;
            if (isNaN(c)) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
            } else if (c === 47) {
                this.state = "relative slash";
            } else if (c === 63) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = "";
                this.state = "query";
            } else if (c === 35) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.state = "fragment";
            } else if (isSpecial(this.url) && c === 92) {
                this.parseError = true;
                this.state = "relative slash";
            } else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice(0, this.base.path.length - 1);
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
            if (isSpecial(this.url) && (c === 47 || c === 92)) {
                if (c === 92) {
                    this.parseError = true;
                }
                this.state = "special authority ignore slashes";
            } else if (c === 47) {
                this.state = "authority";
            } else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
            if (c === 47 && this.input[this.pointer + 1] === 47) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "special authority ignore slashes";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
            if (c !== 47 && c !== 92) {
                this.state = "authority";
                --this.pointer;
            } else {
                this.parseError = true;
            }
            return true;
        };
        URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
            if (c === 64) {
                this.parseError = true;
                if (this.atFlag) {
                    this.buffer = "%40" + this.buffer;
                }
                this.atFlag = true;
                const len = countSymbols(this.buffer);
                for (let pointer = 0; pointer < len; ++pointer) {
                    const codePoint = this.buffer.codePointAt(pointer);
                    if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                        this.passwordTokenSeenFlag = true;
                        continue;
                    }
                    const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                    if (this.passwordTokenSeenFlag) {
                        this.url.password += encodedCodePoints;
                    } else {
                        this.url.username += encodedCodePoints;
                    }
                }
                this.buffer = "";
            } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
                if (this.atFlag && this.buffer === "") {
                    this.parseError = true;
                    return failure;
                }
                this.pointer -= countSymbols(this.buffer) + 1;
                this.buffer = "";
                this.state = "host";
            } else {
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
            if (this.stateOverride && this.url.scheme === "file") {
                --this.pointer;
                this.state = "file host";
            } else if (c === 58 && !this.arrFlag) {
                if (this.buffer === "") {
                    this.parseError = true;
                    return failure;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) {
                    return failure;
                }
                this.url.host = host;
                this.buffer = "";
                this.state = "port";
                if (this.stateOverride === "hostname") {
                    return false;
                }
            } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
                --this.pointer;
                if (isSpecial(this.url) && this.buffer === "") {
                    this.parseError = true;
                    return failure;
                } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
                    this.parseError = true;
                    return false;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) {
                    return failure;
                }
                this.url.host = host;
                this.buffer = "";
                this.state = "path start";
                if (this.stateOverride) {
                    return false;
                }
            } else {
                if (c === 91) {
                    this.arrFlag = true;
                } else if (c === 93) {
                    this.arrFlag = false;
                }
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
            if (isASCIIDigit(c)) {
                this.buffer += cStr;
            } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
                if (this.buffer !== "") {
                    const port = parseInt(this.buffer);
                    if (port > Math.pow(2, 16) - 1) {
                        this.parseError = true;
                        return failure;
                    }
                    this.url.port = port === defaultPort(this.url.scheme) ? null : port;
                    this.buffer = "";
                }
                if (this.stateOverride) {
                    return false;
                }
                this.state = "path start";
                --this.pointer;
            } else {
                this.parseError = true;
                return failure;
            }
            return true;
        };
        const fileOtherwiseCodePoints = new Set([ 47, 92, 63, 35 ]);
        URLStateMachine.prototype["parse file"] = function parseFile(c) {
            this.url.scheme = "file";
            if (c === 47 || c === 92) {
                if (c === 92) {
                    this.parseError = true;
                }
                this.state = "file slash";
            } else if (this.base !== null && this.base.scheme === "file") {
                if (isNaN(c)) {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                } else if (c === 63) {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    this.url.query = "";
                    this.state = "query";
                } else if (c === 35) {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    this.url.query = this.base.query;
                    this.url.fragment = "";
                    this.state = "fragment";
                } else {
                    if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
                        this.url.host = this.base.host;
                        this.url.path = this.base.path.slice();
                        shortenPath(this.url);
                    } else {
                        this.parseError = true;
                    }
                    this.state = "path";
                    --this.pointer;
                }
            } else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
            if (c === 47 || c === 92) {
                if (c === 92) {
                    this.parseError = true;
                }
                this.state = "file host";
            } else {
                if (this.base !== null && this.base.scheme === "file") {
                    if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                        this.url.path.push(this.base.path[0]);
                    } else {
                        this.url.host = this.base.host;
                    }
                }
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
            if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
                --this.pointer;
                if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
                    this.parseError = true;
                    this.state = "path";
                } else if (this.buffer === "") {
                    this.url.host = "";
                    if (this.stateOverride) {
                        return false;
                    }
                    this.state = "path start";
                } else {
                    let host = parseHost(this.buffer, isSpecial(this.url));
                    if (host === failure) {
                        return failure;
                    }
                    if (host === "localhost") {
                        host = "";
                    }
                    this.url.host = host;
                    if (this.stateOverride) {
                        return false;
                    }
                    this.buffer = "";
                    this.state = "path start";
                }
            } else {
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
            if (isSpecial(this.url)) {
                if (c === 92) {
                    this.parseError = true;
                }
                this.state = "path";
                if (c !== 47 && c !== 92) {
                    --this.pointer;
                }
            } else if (!this.stateOverride && c === 63) {
                this.url.query = "";
                this.state = "query";
            } else if (!this.stateOverride && c === 35) {
                this.url.fragment = "";
                this.state = "fragment";
            } else if (c !== undefined) {
                this.state = "path";
                if (c !== 47) {
                    --this.pointer;
                }
            }
            return true;
        };
        URLStateMachine.prototype["parse path"] = function parsePath(c) {
            if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
                if (isSpecial(this.url) && c === 92) {
                    this.parseError = true;
                }
                if (isDoubleDot(this.buffer)) {
                    shortenPath(this.url);
                    if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                        this.url.path.push("");
                    }
                } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
                    this.url.path.push("");
                } else if (!isSingleDot(this.buffer)) {
                    if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                        if (this.url.host !== "" && this.url.host !== null) {
                            this.parseError = true;
                            this.url.host = "";
                        }
                        this.buffer = this.buffer[0] + ":";
                    }
                    this.url.path.push(this.buffer);
                }
                this.buffer = "";
                if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
                    while (this.url.path.length > 1 && this.url.path[0] === "") {
                        this.parseError = true;
                        this.url.path.shift();
                    }
                }
                if (c === 63) {
                    this.url.query = "";
                    this.state = "query";
                }
                if (c === 35) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
                    this.parseError = true;
                }
                this.buffer += percentEncodeChar(c, isPathPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
            if (c === 63) {
                this.url.query = "";
                this.state = "query";
            } else if (c === 35) {
                this.url.fragment = "";
                this.state = "fragment";
            } else {
                if (!isNaN(c) && c !== 37) {
                    this.parseError = true;
                }
                if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
                    this.parseError = true;
                }
                if (!isNaN(c)) {
                    this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
                }
            }
            return true;
        };
        URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
            if (isNaN(c) || !this.stateOverride && c === 35) {
                if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
                    this.encodingOverride = "utf-8";
                }
                const buffer = new Buffer(this.buffer);
                for (let i = 0; i < buffer.length; ++i) {
                    if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
                        this.url.query += percentEncode(buffer[i]);
                    } else {
                        this.url.query += String.fromCodePoint(buffer[i]);
                    }
                }
                this.buffer = "";
                if (c === 35) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
                    this.parseError = true;
                }
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
            if (isNaN(c)) ; else if (c === 0) {
                this.parseError = true;
            } else {
                if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
                    this.parseError = true;
                }
                this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        function serializeURL(url, excludeFragment) {
            let output = url.scheme + ":";
            if (url.host !== null) {
                output += "//";
                if (url.username !== "" || url.password !== "") {
                    output += url.username;
                    if (url.password !== "") {
                        output += ":" + url.password;
                    }
                    output += "@";
                }
                output += serializeHost(url.host);
                if (url.port !== null) {
                    output += ":" + url.port;
                }
            } else if (url.host === null && url.scheme === "file") {
                output += "//";
            }
            if (url.cannotBeABaseURL) {
                output += url.path[0];
            } else {
                for (const string of url.path) {
                    output += "/" + string;
                }
            }
            if (url.query !== null) {
                output += "?" + url.query;
            }
            if (!excludeFragment && url.fragment !== null) {
                output += "#" + url.fragment;
            }
            return output;
        }
        function serializeOrigin(tuple) {
            let result = tuple.scheme + "://";
            result += serializeHost(tuple.host);
            if (tuple.port !== null) {
                result += ":" + tuple.port;
            }
            return result;
        }
        module.exports.serializeURL = serializeURL;
        module.exports.serializeURLOrigin = function(url) {
            switch (url.scheme) {
              case "blob":
                try {
                    return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                } catch (e) {
                    return "null";
                }

              case "ftp":
              case "gopher":
              case "http":
              case "https":
              case "ws":
              case "wss":
                return serializeOrigin({
                    scheme: url.scheme,
                    host: url.host,
                    port: url.port
                });

              case "file":
                return "file://";

              default:
                return "null";
            }
        };
        module.exports.basicURLParse = function(input, options) {
            if (options === undefined) {
                options = {};
            }
            const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
            if (usm.failure) {
                return "failure";
            }
            return usm.url;
        };
        module.exports.setTheUsername = function(url, username) {
            url.username = "";
            const decoded = punycode.ucs2.decode(username);
            for (let i = 0; i < decoded.length; ++i) {
                url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
            }
        };
        module.exports.setThePassword = function(url, password) {
            url.password = "";
            const decoded = punycode.ucs2.decode(password);
            for (let i = 0; i < decoded.length; ++i) {
                url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
            }
        };
        module.exports.serializeHost = serializeHost;
        module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
        module.exports.serializeInteger = function(integer) {
            return String(integer);
        };
        module.exports.parseURL = function(input, options) {
            if (options === undefined) {
                options = {};
            }
            return module.exports.basicURLParse(input, {
                baseURL: options.baseURL,
                encodingOverride: options.encodingOverride
            });
        };
    })(urlStateMachine);
    const usm = urlStateMachine.exports;
    URLImpl.implementation = class URLImpl {
        constructor(constructorArgs) {
            const url = constructorArgs[0];
            const base = constructorArgs[1];
            let parsedBase = null;
            if (base !== undefined) {
                parsedBase = usm.basicURLParse(base);
                if (parsedBase === "failure") {
                    throw new TypeError("Invalid base URL");
                }
            }
            const parsedURL = usm.basicURLParse(url, {
                baseURL: parsedBase
            });
            if (parsedURL === "failure") {
                throw new TypeError("Invalid URL");
            }
            this._url = parsedURL;
        }
        get href() {
            return usm.serializeURL(this._url);
        }
        set href(v) {
            const parsedURL = usm.basicURLParse(v);
            if (parsedURL === "failure") {
                throw new TypeError("Invalid URL");
            }
            this._url = parsedURL;
        }
        get origin() {
            return usm.serializeURLOrigin(this._url);
        }
        get protocol() {
            return this._url.scheme + ":";
        }
        set protocol(v) {
            usm.basicURLParse(v + ":", {
                url: this._url,
                stateOverride: "scheme start"
            });
        }
        get username() {
            return this._url.username;
        }
        set username(v) {
            if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                return;
            }
            usm.setTheUsername(this._url, v);
        }
        get password() {
            return this._url.password;
        }
        set password(v) {
            if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                return;
            }
            usm.setThePassword(this._url, v);
        }
        get host() {
            const url = this._url;
            if (url.host === null) {
                return "";
            }
            if (url.port === null) {
                return usm.serializeHost(url.host);
            }
            return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
        }
        set host(v) {
            if (this._url.cannotBeABaseURL) {
                return;
            }
            usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "host"
            });
        }
        get hostname() {
            if (this._url.host === null) {
                return "";
            }
            return usm.serializeHost(this._url.host);
        }
        set hostname(v) {
            if (this._url.cannotBeABaseURL) {
                return;
            }
            usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "hostname"
            });
        }
        get port() {
            if (this._url.port === null) {
                return "";
            }
            return usm.serializeInteger(this._url.port);
        }
        set port(v) {
            if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
                return;
            }
            if (v === "") {
                this._url.port = null;
            } else {
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "port"
                });
            }
        }
        get pathname() {
            if (this._url.cannotBeABaseURL) {
                return this._url.path[0];
            }
            if (this._url.path.length === 0) {
                return "";
            }
            return "/" + this._url.path.join("/");
        }
        set pathname(v) {
            if (this._url.cannotBeABaseURL) {
                return;
            }
            this._url.path = [];
            usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "path start"
            });
        }
        get search() {
            if (this._url.query === null || this._url.query === "") {
                return "";
            }
            return "?" + this._url.query;
        }
        set search(v) {
            const url = this._url;
            if (v === "") {
                url.query = null;
                return;
            }
            const input = v[0] === "?" ? v.substring(1) : v;
            url.query = "";
            usm.basicURLParse(input, {
                url: url,
                stateOverride: "query"
            });
        }
        get hash() {
            if (this._url.fragment === null || this._url.fragment === "") {
                return "";
            }
            return "#" + this._url.fragment;
        }
        set hash(v) {
            if (v === "") {
                this._url.fragment = null;
                return;
            }
            const input = v[0] === "#" ? v.substring(1) : v;
            this._url.fragment = "";
            usm.basicURLParse(input, {
                url: this._url,
                stateOverride: "fragment"
            });
        }
        toJSON() {
            return this.href;
        }
    };
    (function(module) {
        const conversions = lib;
        const utils = utils$2.exports;
        const Impl = URLImpl;
        const impl = utils.implSymbol;
        function URL(url) {
            if (!this || this[impl] || !(this instanceof URL)) {
                throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
            }
            if (arguments.length < 1) {
                throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
            }
            const args = [];
            for (let i = 0; i < arguments.length && i < 2; ++i) {
                args[i] = arguments[i];
            }
            args[0] = conversions["USVString"](args[0]);
            if (args[1] !== undefined) {
                args[1] = conversions["USVString"](args[1]);
            }
            module.exports.setup(this, args);
        }
        URL.prototype.toJSON = function toJSON() {
            if (!this || !module.exports.is(this)) {
                throw new TypeError("Illegal invocation");
            }
            const args = [];
            for (let i = 0; i < arguments.length && i < 0; ++i) {
                args[i] = arguments[i];
            }
            return this[impl].toJSON.apply(this[impl], args);
        };
        Object.defineProperty(URL.prototype, "href", {
            get() {
                return this[impl].href;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].href = V;
            },
            enumerable: true,
            configurable: true
        });
        URL.prototype.toString = function() {
            if (!this || !module.exports.is(this)) {
                throw new TypeError("Illegal invocation");
            }
            return this.href;
        };
        Object.defineProperty(URL.prototype, "origin", {
            get() {
                return this[impl].origin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "protocol", {
            get() {
                return this[impl].protocol;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].protocol = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "username", {
            get() {
                return this[impl].username;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].username = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "password", {
            get() {
                return this[impl].password;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].password = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "host", {
            get() {
                return this[impl].host;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].host = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "hostname", {
            get() {
                return this[impl].hostname;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].hostname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "port", {
            get() {
                return this[impl].port;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].port = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "pathname", {
            get() {
                return this[impl].pathname;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].pathname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "search", {
            get() {
                return this[impl].search;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].search = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL.prototype, "hash", {
            get() {
                return this[impl].hash;
            },
            set(V) {
                V = conversions["USVString"](V);
                this[impl].hash = V;
            },
            enumerable: true,
            configurable: true
        });
        module.exports = {
            is(obj) {
                return !!obj && obj[impl] instanceof Impl.implementation;
            },
            create(constructorArgs, privateData) {
                let obj = Object.create(URL.prototype);
                this.setup(obj, constructorArgs, privateData);
                return obj;
            },
            setup(obj, constructorArgs, privateData) {
                if (!privateData) privateData = {};
                privateData.wrapper = obj;
                obj[impl] = new Impl.implementation(constructorArgs, privateData);
                obj[impl][utils.wrapperSymbol] = obj;
            },
            interface: URL,
            expose: {
                Window: {
                    URL: URL
                },
                Worker: {
                    URL: URL
                }
            }
        };
    })(URL);
    publicApi.URL = URL.exports.interface;
    publicApi.serializeURL = urlStateMachine.exports.serializeURL;
    publicApi.serializeURLOrigin = urlStateMachine.exports.serializeURLOrigin;
    publicApi.basicURLParse = urlStateMachine.exports.basicURLParse;
    publicApi.setTheUsername = urlStateMachine.exports.setTheUsername;
    publicApi.setThePassword = urlStateMachine.exports.setThePassword;
    publicApi.serializeHost = urlStateMachine.exports.serializeHost;
    publicApi.serializeInteger = urlStateMachine.exports.serializeInteger;
    publicApi.parseURL = urlStateMachine.exports.parseURL;
    (function(module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function _interopDefault(ex) {
            return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
        }
        var Stream = _interopDefault(require$0__default["default"]);
        var http = _interopDefault(require$1__default["default"]);
        var Url = _interopDefault(require$2__default["default"]);
        var whatwgUrl = _interopDefault(publicApi);
        var https = _interopDefault(require$4__default["default"]);
        var zlib = _interopDefault(require$5__default["default"]);
        const Readable = Stream.Readable;
        const BUFFER = Symbol("buffer");
        const TYPE = Symbol("type");
        class Blob {
            constructor() {
                this[TYPE] = "";
                const blobParts = arguments[0];
                const options = arguments[1];
                const buffers = [];
                let size = 0;
                if (blobParts) {
                    const a = blobParts;
                    const length = Number(a.length);
                    for (let i = 0; i < length; i++) {
                        const element = a[i];
                        let buffer;
                        if (element instanceof Buffer) {
                            buffer = element;
                        } else if (ArrayBuffer.isView(element)) {
                            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                        } else if (element instanceof ArrayBuffer) {
                            buffer = Buffer.from(element);
                        } else if (element instanceof Blob) {
                            buffer = element[BUFFER];
                        } else {
                            buffer = Buffer.from(typeof element === "string" ? element : String(element));
                        }
                        size += buffer.length;
                        buffers.push(buffer);
                    }
                }
                this[BUFFER] = Buffer.concat(buffers);
                let type = options && options.type !== undefined && String(options.type).toLowerCase();
                if (type && !/[^\u0020-\u007E]/.test(type)) {
                    this[TYPE] = type;
                }
            }
            get size() {
                return this[BUFFER].length;
            }
            get type() {
                return this[TYPE];
            }
            text() {
                return Promise.resolve(this[BUFFER].toString());
            }
            arrayBuffer() {
                const buf = this[BUFFER];
                const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                return Promise.resolve(ab);
            }
            stream() {
                const readable = new Readable;
                readable._read = function() {};
                readable.push(this[BUFFER]);
                readable.push(null);
                return readable;
            }
            toString() {
                return "[object Blob]";
            }
            slice() {
                const size = this.size;
                const start = arguments[0];
                const end = arguments[1];
                let relativeStart, relativeEnd;
                if (start === undefined) {
                    relativeStart = 0;
                } else if (start < 0) {
                    relativeStart = Math.max(size + start, 0);
                } else {
                    relativeStart = Math.min(start, size);
                }
                if (end === undefined) {
                    relativeEnd = size;
                } else if (end < 0) {
                    relativeEnd = Math.max(size + end, 0);
                } else {
                    relativeEnd = Math.min(end, size);
                }
                const span = Math.max(relativeEnd - relativeStart, 0);
                const buffer = this[BUFFER];
                const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
                const blob = new Blob([], {
                    type: arguments[2]
                });
                blob[BUFFER] = slicedBuffer;
                return blob;
            }
        }
        Object.defineProperties(Blob.prototype, {
            size: {
                enumerable: true
            },
            type: {
                enumerable: true
            },
            slice: {
                enumerable: true
            }
        });
        Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
            value: "Blob",
            writable: false,
            enumerable: false,
            configurable: true
        });
        function FetchError(message, type, systemError) {
            Error.call(this, message);
            this.message = message;
            this.type = type;
            if (systemError) {
                this.code = this.errno = systemError.code;
            }
            Error.captureStackTrace(this, this.constructor);
        }
        FetchError.prototype = Object.create(Error.prototype);
        FetchError.prototype.constructor = FetchError;
        FetchError.prototype.name = "FetchError";
        let convert;
        try {
            convert = require("encoding").convert;
        } catch (e) {}
        const INTERNALS = Symbol("Body internals");
        const PassThrough = Stream.PassThrough;
        function Body(body) {
            var _this = this;
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;
            let size = _ref$size === undefined ? 0 : _ref$size;
            var _ref$timeout = _ref.timeout;
            let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;
            if (body == null) {
                body = null;
            } else if (isURLSearchParams(body)) {
                body = Buffer.from(body.toString());
            } else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
                body = Buffer.from(body);
            } else if (ArrayBuffer.isView(body)) {
                body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
            } else if (body instanceof Stream) ; else {
                body = Buffer.from(String(body));
            }
            this[INTERNALS] = {
                body: body,
                disturbed: false,
                error: null
            };
            this.size = size;
            this.timeout = timeout;
            if (body instanceof Stream) {
                body.on("error", (function(err) {
                    const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
                    _this[INTERNALS].error = error;
                }));
            }
        }
        Body.prototype = {
            get body() {
                return this[INTERNALS].body;
            },
            get bodyUsed() {
                return this[INTERNALS].disturbed;
            },
            arrayBuffer() {
                return consumeBody.call(this).then((function(buf) {
                    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
                }));
            },
            blob() {
                let ct = this.headers && this.headers.get("content-type") || "";
                return consumeBody.call(this).then((function(buf) {
                    return Object.assign(new Blob([], {
                        type: ct.toLowerCase()
                    }), {
                        [BUFFER]: buf
                    });
                }));
            },
            json() {
                var _this2 = this;
                return consumeBody.call(this).then((function(buffer) {
                    try {
                        return JSON.parse(buffer.toString());
                    } catch (err) {
                        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
                    }
                }));
            },
            text() {
                return consumeBody.call(this).then((function(buffer) {
                    return buffer.toString();
                }));
            },
            buffer() {
                return consumeBody.call(this);
            },
            textConverted() {
                var _this3 = this;
                return consumeBody.call(this).then((function(buffer) {
                    return convertBody(buffer, _this3.headers);
                }));
            }
        };
        Object.defineProperties(Body.prototype, {
            body: {
                enumerable: true
            },
            bodyUsed: {
                enumerable: true
            },
            arrayBuffer: {
                enumerable: true
            },
            blob: {
                enumerable: true
            },
            json: {
                enumerable: true
            },
            text: {
                enumerable: true
            }
        });
        Body.mixIn = function(proto) {
            for (const name of Object.getOwnPropertyNames(Body.prototype)) {
                if (!(name in proto)) {
                    const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
                    Object.defineProperty(proto, name, desc);
                }
            }
        };
        function consumeBody() {
            var _this4 = this;
            if (this[INTERNALS].disturbed) {
                return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
            }
            this[INTERNALS].disturbed = true;
            if (this[INTERNALS].error) {
                return Body.Promise.reject(this[INTERNALS].error);
            }
            let body = this.body;
            if (body === null) {
                return Body.Promise.resolve(Buffer.alloc(0));
            }
            if (isBlob(body)) {
                body = body.stream();
            }
            if (Buffer.isBuffer(body)) {
                return Body.Promise.resolve(body);
            }
            if (!(body instanceof Stream)) {
                return Body.Promise.resolve(Buffer.alloc(0));
            }
            let accum = [];
            let accumBytes = 0;
            let abort = false;
            return new Body.Promise((function(resolve, reject) {
                let resTimeout;
                if (_this4.timeout) {
                    resTimeout = setTimeout((function() {
                        abort = true;
                        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
                    }), _this4.timeout);
                }
                body.on("error", (function(err) {
                    if (err.name === "AbortError") {
                        abort = true;
                        reject(err);
                    } else {
                        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
                    }
                }));
                body.on("data", (function(chunk) {
                    if (abort || chunk === null) {
                        return;
                    }
                    if (_this4.size && accumBytes + chunk.length > _this4.size) {
                        abort = true;
                        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
                        return;
                    }
                    accumBytes += chunk.length;
                    accum.push(chunk);
                }));
                body.on("end", (function() {
                    if (abort) {
                        return;
                    }
                    clearTimeout(resTimeout);
                    try {
                        resolve(Buffer.concat(accum, accumBytes));
                    } catch (err) {
                        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
                    }
                }));
            }));
        }
        function convertBody(buffer, headers) {
            if (typeof convert !== "function") {
                throw new Error("The package `encoding` must be installed to use the textConverted() function");
            }
            const ct = headers.get("content-type");
            let charset = "utf-8";
            let res, str;
            if (ct) {
                res = /charset=([^;]*)/i.exec(ct);
            }
            str = buffer.slice(0, 1024).toString();
            if (!res && str) {
                res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
            }
            if (!res && str) {
                res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
                if (!res) {
                    res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
                    if (res) {
                        res.pop();
                    }
                }
                if (res) {
                    res = /charset=(.*)/i.exec(res.pop());
                }
            }
            if (!res && str) {
                res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
            }
            if (res) {
                charset = res.pop();
                if (charset === "gb2312" || charset === "gbk") {
                    charset = "gb18030";
                }
            }
            return convert(buffer, "UTF-8", charset).toString();
        }
        function isURLSearchParams(obj) {
            if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
                return false;
            }
            return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
        }
        function isBlob(obj) {
            return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
        }
        function clone(instance) {
            let p1, p2;
            let body = instance.body;
            if (instance.bodyUsed) {
                throw new Error("cannot clone body after it is used");
            }
            if (body instanceof Stream && typeof body.getBoundary !== "function") {
                p1 = new PassThrough;
                p2 = new PassThrough;
                body.pipe(p1);
                body.pipe(p2);
                instance[INTERNALS].body = p1;
                body = p2;
            }
            return body;
        }
        function extractContentType(body) {
            if (body === null) {
                return null;
            } else if (typeof body === "string") {
                return "text/plain;charset=UTF-8";
            } else if (isURLSearchParams(body)) {
                return "application/x-www-form-urlencoded;charset=UTF-8";
            } else if (isBlob(body)) {
                return body.type || null;
            } else if (Buffer.isBuffer(body)) {
                return null;
            } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
                return null;
            } else if (ArrayBuffer.isView(body)) {
                return null;
            } else if (typeof body.getBoundary === "function") {
                return `multipart/form-data;boundary=${body.getBoundary()}`;
            } else if (body instanceof Stream) {
                return null;
            } else {
                return "text/plain;charset=UTF-8";
            }
        }
        function getTotalBytes(instance) {
            const body = instance.body;
            if (body === null) {
                return 0;
            } else if (isBlob(body)) {
                return body.size;
            } else if (Buffer.isBuffer(body)) {
                return body.length;
            } else if (body && typeof body.getLengthSync === "function") {
                if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
                    return body.getLengthSync();
                }
                return null;
            } else {
                return null;
            }
        }
        function writeToStream(dest, instance) {
            const body = instance.body;
            if (body === null) {
                dest.end();
            } else if (isBlob(body)) {
                body.stream().pipe(dest);
            } else if (Buffer.isBuffer(body)) {
                dest.write(body);
                dest.end();
            } else {
                body.pipe(dest);
            }
        }
        Body.Promise = commonjsGlobal.Promise;
        const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
        const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        function validateName(name) {
            name = `${name}`;
            if (invalidTokenRegex.test(name) || name === "") {
                throw new TypeError(`${name} is not a legal HTTP header name`);
            }
        }
        function validateValue(value) {
            value = `${value}`;
            if (invalidHeaderCharRegex.test(value)) {
                throw new TypeError(`${value} is not a legal HTTP header value`);
            }
        }
        function find(map, name) {
            name = name.toLowerCase();
            for (const key in map) {
                if (key.toLowerCase() === name) {
                    return key;
                }
            }
            return undefined;
        }
        const MAP = Symbol("map");
        class Headers {
            constructor() {
                let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
                this[MAP] = Object.create(null);
                if (init instanceof Headers) {
                    const rawHeaders = init.raw();
                    const headerNames = Object.keys(rawHeaders);
                    for (const headerName of headerNames) {
                        for (const value of rawHeaders[headerName]) {
                            this.append(headerName, value);
                        }
                    }
                    return;
                }
                if (init == null) ; else if (typeof init === "object") {
                    const method = init[Symbol.iterator];
                    if (method != null) {
                        if (typeof method !== "function") {
                            throw new TypeError("Header pairs must be iterable");
                        }
                        const pairs = [];
                        for (const pair of init) {
                            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                                throw new TypeError("Each header pair must be iterable");
                            }
                            pairs.push(Array.from(pair));
                        }
                        for (const pair of pairs) {
                            if (pair.length !== 2) {
                                throw new TypeError("Each header pair must be a name/value tuple");
                            }
                            this.append(pair[0], pair[1]);
                        }
                    } else {
                        for (const key of Object.keys(init)) {
                            const value = init[key];
                            this.append(key, value);
                        }
                    }
                } else {
                    throw new TypeError("Provided initializer must be an object");
                }
            }
            get(name) {
                name = `${name}`;
                validateName(name);
                const key = find(this[MAP], name);
                if (key === undefined) {
                    return null;
                }
                return this[MAP][key].join(", ");
            }
            forEach(callback) {
                let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
                let pairs = getHeaders(this);
                let i = 0;
                while (i < pairs.length) {
                    var _pairs$i = pairs[i];
                    const name = _pairs$i[0], value = _pairs$i[1];
                    callback.call(thisArg, value, name, this);
                    pairs = getHeaders(this);
                    i++;
                }
            }
            set(name, value) {
                name = `${name}`;
                value = `${value}`;
                validateName(name);
                validateValue(value);
                const key = find(this[MAP], name);
                this[MAP][key !== undefined ? key : name] = [ value ];
            }
            append(name, value) {
                name = `${name}`;
                value = `${value}`;
                validateName(name);
                validateValue(value);
                const key = find(this[MAP], name);
                if (key !== undefined) {
                    this[MAP][key].push(value);
                } else {
                    this[MAP][name] = [ value ];
                }
            }
            has(name) {
                name = `${name}`;
                validateName(name);
                return find(this[MAP], name) !== undefined;
            }
            delete(name) {
                name = `${name}`;
                validateName(name);
                const key = find(this[MAP], name);
                if (key !== undefined) {
                    delete this[MAP][key];
                }
            }
            raw() {
                return this[MAP];
            }
            keys() {
                return createHeadersIterator(this, "key");
            }
            values() {
                return createHeadersIterator(this, "value");
            }
            [Symbol.iterator]() {
                return createHeadersIterator(this, "key+value");
            }
        }
        Headers.prototype.entries = Headers.prototype[Symbol.iterator];
        Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
            value: "Headers",
            writable: false,
            enumerable: false,
            configurable: true
        });
        Object.defineProperties(Headers.prototype, {
            get: {
                enumerable: true
            },
            forEach: {
                enumerable: true
            },
            set: {
                enumerable: true
            },
            append: {
                enumerable: true
            },
            has: {
                enumerable: true
            },
            delete: {
                enumerable: true
            },
            keys: {
                enumerable: true
            },
            values: {
                enumerable: true
            },
            entries: {
                enumerable: true
            }
        });
        function getHeaders(headers) {
            let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "key+value";
            const keys = Object.keys(headers[MAP]).sort();
            return keys.map(kind === "key" ? function(k) {
                return k.toLowerCase();
            } : kind === "value" ? function(k) {
                return headers[MAP][k].join(", ");
            } : function(k) {
                return [ k.toLowerCase(), headers[MAP][k].join(", ") ];
            });
        }
        const INTERNAL = Symbol("internal");
        function createHeadersIterator(target, kind) {
            const iterator = Object.create(HeadersIteratorPrototype);
            iterator[INTERNAL] = {
                target: target,
                kind: kind,
                index: 0
            };
            return iterator;
        }
        const HeadersIteratorPrototype = Object.setPrototypeOf({
            next() {
                if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
                    throw new TypeError("Value of `this` is not a HeadersIterator");
                }
                var _INTERNAL = this[INTERNAL];
                const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
                const values = getHeaders(target, kind);
                const len = values.length;
                if (index >= len) {
                    return {
                        value: undefined,
                        done: true
                    };
                }
                this[INTERNAL].index = index + 1;
                return {
                    value: values[index],
                    done: false
                };
            }
        }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
        Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
            value: "HeadersIterator",
            writable: false,
            enumerable: false,
            configurable: true
        });
        function exportNodeCompatibleHeaders(headers) {
            const obj = Object.assign({
                __proto__: null
            }, headers[MAP]);
            const hostHeaderKey = find(headers[MAP], "Host");
            if (hostHeaderKey !== undefined) {
                obj[hostHeaderKey] = obj[hostHeaderKey][0];
            }
            return obj;
        }
        function createHeadersLenient(obj) {
            const headers = new Headers;
            for (const name of Object.keys(obj)) {
                if (invalidTokenRegex.test(name)) {
                    continue;
                }
                if (Array.isArray(obj[name])) {
                    for (const val of obj[name]) {
                        if (invalidHeaderCharRegex.test(val)) {
                            continue;
                        }
                        if (headers[MAP][name] === undefined) {
                            headers[MAP][name] = [ val ];
                        } else {
                            headers[MAP][name].push(val);
                        }
                    }
                } else if (!invalidHeaderCharRegex.test(obj[name])) {
                    headers[MAP][name] = [ obj[name] ];
                }
            }
            return headers;
        }
        const INTERNALS$1 = Symbol("Response internals");
        const STATUS_CODES = http.STATUS_CODES;
        class Response {
            constructor() {
                let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                Body.call(this, body, opts);
                const status = opts.status || 200;
                const headers = new Headers(opts.headers);
                if (body != null && !headers.has("Content-Type")) {
                    const contentType = extractContentType(body);
                    if (contentType) {
                        headers.append("Content-Type", contentType);
                    }
                }
                this[INTERNALS$1] = {
                    url: opts.url,
                    status: status,
                    statusText: opts.statusText || STATUS_CODES[status],
                    headers: headers,
                    counter: opts.counter
                };
            }
            get url() {
                return this[INTERNALS$1].url || "";
            }
            get status() {
                return this[INTERNALS$1].status;
            }
            get ok() {
                return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
            }
            get redirected() {
                return this[INTERNALS$1].counter > 0;
            }
            get statusText() {
                return this[INTERNALS$1].statusText;
            }
            get headers() {
                return this[INTERNALS$1].headers;
            }
            clone() {
                return new Response(clone(this), {
                    url: this.url,
                    status: this.status,
                    statusText: this.statusText,
                    headers: this.headers,
                    ok: this.ok,
                    redirected: this.redirected
                });
            }
        }
        Body.mixIn(Response.prototype);
        Object.defineProperties(Response.prototype, {
            url: {
                enumerable: true
            },
            status: {
                enumerable: true
            },
            ok: {
                enumerable: true
            },
            redirected: {
                enumerable: true
            },
            statusText: {
                enumerable: true
            },
            headers: {
                enumerable: true
            },
            clone: {
                enumerable: true
            }
        });
        Object.defineProperty(Response.prototype, Symbol.toStringTag, {
            value: "Response",
            writable: false,
            enumerable: false,
            configurable: true
        });
        const INTERNALS$2 = Symbol("Request internals");
        const URL = Url.URL || whatwgUrl.URL;
        const parse_url = Url.parse;
        const format_url = Url.format;
        function parseURL(urlStr) {
            if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
                urlStr = new URL(urlStr).toString();
            }
            return parse_url(urlStr);
        }
        const streamDestructionSupported = "destroy" in Stream.Readable.prototype;
        function isRequest(input) {
            return typeof input === "object" && typeof input[INTERNALS$2] === "object";
        }
        function isAbortSignal(signal) {
            const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
            return !!(proto && proto.constructor.name === "AbortSignal");
        }
        class Request {
            constructor(input) {
                let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                let parsedURL;
                if (!isRequest(input)) {
                    if (input && input.href) {
                        parsedURL = parseURL(input.href);
                    } else {
                        parsedURL = parseURL(`${input}`);
                    }
                    input = {};
                } else {
                    parsedURL = parseURL(input.url);
                }
                let method = init.method || input.method || "GET";
                method = method.toUpperCase();
                if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
                    throw new TypeError("Request with GET/HEAD method cannot have body");
                }
                let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
                Body.call(this, inputBody, {
                    timeout: init.timeout || input.timeout || 0,
                    size: init.size || input.size || 0
                });
                const headers = new Headers(init.headers || input.headers || {});
                if (inputBody != null && !headers.has("Content-Type")) {
                    const contentType = extractContentType(inputBody);
                    if (contentType) {
                        headers.append("Content-Type", contentType);
                    }
                }
                let signal = isRequest(input) ? input.signal : null;
                if ("signal" in init) signal = init.signal;
                if (signal != null && !isAbortSignal(signal)) {
                    throw new TypeError("Expected signal to be an instanceof AbortSignal");
                }
                this[INTERNALS$2] = {
                    method: method,
                    redirect: init.redirect || input.redirect || "follow",
                    headers: headers,
                    parsedURL: parsedURL,
                    signal: signal
                };
                this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
                this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
                this.counter = init.counter || input.counter || 0;
                this.agent = init.agent || input.agent;
            }
            get method() {
                return this[INTERNALS$2].method;
            }
            get url() {
                return format_url(this[INTERNALS$2].parsedURL);
            }
            get headers() {
                return this[INTERNALS$2].headers;
            }
            get redirect() {
                return this[INTERNALS$2].redirect;
            }
            get signal() {
                return this[INTERNALS$2].signal;
            }
            clone() {
                return new Request(this);
            }
        }
        Body.mixIn(Request.prototype);
        Object.defineProperty(Request.prototype, Symbol.toStringTag, {
            value: "Request",
            writable: false,
            enumerable: false,
            configurable: true
        });
        Object.defineProperties(Request.prototype, {
            method: {
                enumerable: true
            },
            url: {
                enumerable: true
            },
            headers: {
                enumerable: true
            },
            redirect: {
                enumerable: true
            },
            clone: {
                enumerable: true
            },
            signal: {
                enumerable: true
            }
        });
        function getNodeRequestOptions(request) {
            const parsedURL = request[INTERNALS$2].parsedURL;
            const headers = new Headers(request[INTERNALS$2].headers);
            if (!headers.has("Accept")) {
                headers.set("Accept", "*/*");
            }
            if (!parsedURL.protocol || !parsedURL.hostname) {
                throw new TypeError("Only absolute URLs are supported");
            }
            if (!/^https?:$/.test(parsedURL.protocol)) {
                throw new TypeError("Only HTTP(S) protocols are supported");
            }
            if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
                throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
            }
            let contentLengthValue = null;
            if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
                contentLengthValue = "0";
            }
            if (request.body != null) {
                const totalBytes = getTotalBytes(request);
                if (typeof totalBytes === "number") {
                    contentLengthValue = String(totalBytes);
                }
            }
            if (contentLengthValue) {
                headers.set("Content-Length", contentLengthValue);
            }
            if (!headers.has("User-Agent")) {
                headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
            }
            if (request.compress && !headers.has("Accept-Encoding")) {
                headers.set("Accept-Encoding", "gzip,deflate");
            }
            let agent = request.agent;
            if (typeof agent === "function") {
                agent = agent(parsedURL);
            }
            if (!headers.has("Connection") && !agent) {
                headers.set("Connection", "close");
            }
            return Object.assign({}, parsedURL, {
                method: request.method,
                headers: exportNodeCompatibleHeaders(headers),
                agent: agent
            });
        }
        function AbortError(message) {
            Error.call(this, message);
            this.type = "aborted";
            this.message = message;
            Error.captureStackTrace(this, this.constructor);
        }
        AbortError.prototype = Object.create(Error.prototype);
        AbortError.prototype.constructor = AbortError;
        AbortError.prototype.name = "AbortError";
        const URL$1 = Url.URL || whatwgUrl.URL;
        const PassThrough$1 = Stream.PassThrough;
        const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
            const orig = new URL$1(original).hostname;
            const dest = new URL$1(destination).hostname;
            return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
        };
        function fetch(url, opts) {
            if (!fetch.Promise) {
                throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
            }
            Body.Promise = fetch.Promise;
            return new fetch.Promise((function(resolve, reject) {
                const request = new Request(url, opts);
                const options = getNodeRequestOptions(request);
                const send = (options.protocol === "https:" ? https : http).request;
                const signal = request.signal;
                let response = null;
                const abort = function abort() {
                    let error = new AbortError("The user aborted a request.");
                    reject(error);
                    if (request.body && request.body instanceof Stream.Readable) {
                        request.body.destroy(error);
                    }
                    if (!response || !response.body) return;
                    response.body.emit("error", error);
                };
                if (signal && signal.aborted) {
                    abort();
                    return;
                }
                const abortAndFinalize = function abortAndFinalize() {
                    abort();
                    finalize();
                };
                const req = send(options);
                let reqTimeout;
                if (signal) {
                    signal.addEventListener("abort", abortAndFinalize);
                }
                function finalize() {
                    req.abort();
                    if (signal) signal.removeEventListener("abort", abortAndFinalize);
                    clearTimeout(reqTimeout);
                }
                if (request.timeout) {
                    req.once("socket", (function(socket) {
                        reqTimeout = setTimeout((function() {
                            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
                            finalize();
                        }), request.timeout);
                    }));
                }
                req.on("error", (function(err) {
                    reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
                    finalize();
                }));
                req.on("response", (function(res) {
                    clearTimeout(reqTimeout);
                    const headers = createHeadersLenient(res.headers);
                    if (fetch.isRedirect(res.statusCode)) {
                        const location = headers.get("Location");
                        let locationURL = null;
                        try {
                            locationURL = location === null ? null : new URL$1(location, request.url).toString();
                        } catch (err) {
                            if (request.redirect !== "manual") {
                                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                                finalize();
                                return;
                            }
                        }
                        switch (request.redirect) {
                          case "error":
                            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                            finalize();
                            return;

                          case "manual":
                            if (locationURL !== null) {
                                try {
                                    headers.set("Location", locationURL);
                                } catch (err) {
                                    reject(err);
                                }
                            }
                            break;

                          case "follow":
                            if (locationURL === null) {
                                break;
                            }
                            if (request.counter >= request.follow) {
                                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                                finalize();
                                return;
                            }
                            const requestOpts = {
                                headers: new Headers(request.headers),
                                follow: request.follow,
                                counter: request.counter + 1,
                                agent: request.agent,
                                compress: request.compress,
                                method: request.method,
                                body: request.body,
                                signal: request.signal,
                                timeout: request.timeout,
                                size: request.size
                            };
                            if (!isDomainOrSubdomain(request.url, locationURL)) {
                                for (const name of [ "authorization", "www-authenticate", "cookie", "cookie2" ]) {
                                    requestOpts.headers.delete(name);
                                }
                            }
                            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                                finalize();
                                return;
                            }
                            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                                requestOpts.method = "GET";
                                requestOpts.body = undefined;
                                requestOpts.headers.delete("content-length");
                            }
                            resolve(fetch(new Request(locationURL, requestOpts)));
                            finalize();
                            return;
                        }
                    }
                    res.once("end", (function() {
                        if (signal) signal.removeEventListener("abort", abortAndFinalize);
                    }));
                    let body = res.pipe(new PassThrough$1);
                    const response_options = {
                        url: request.url,
                        status: res.statusCode,
                        statusText: res.statusMessage,
                        headers: headers,
                        size: request.size,
                        timeout: request.timeout,
                        counter: request.counter
                    };
                    const codings = headers.get("Content-Encoding");
                    if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    const zlibOptions = {
                        flush: zlib.Z_SYNC_FLUSH,
                        finishFlush: zlib.Z_SYNC_FLUSH
                    };
                    if (codings == "gzip" || codings == "x-gzip") {
                        body = body.pipe(zlib.createGunzip(zlibOptions));
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    if (codings == "deflate" || codings == "x-deflate") {
                        const raw = res.pipe(new PassThrough$1);
                        raw.once("data", (function(chunk) {
                            if ((chunk[0] & 15) === 8) {
                                body = body.pipe(zlib.createInflate());
                            } else {
                                body = body.pipe(zlib.createInflateRaw());
                            }
                            response = new Response(body, response_options);
                            resolve(response);
                        }));
                        return;
                    }
                    if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
                        body = body.pipe(zlib.createBrotliDecompress());
                        response = new Response(body, response_options);
                        resolve(response);
                        return;
                    }
                    response = new Response(body, response_options);
                    resolve(response);
                }));
                writeToStream(req, request);
            }));
        }
        fetch.isRedirect = function(code) {
            return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
        };
        fetch.Promise = commonjsGlobal.Promise;
        module.exports = exports = fetch;
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.default = exports;
        exports.Headers = Headers;
        exports.Request = Request;
        exports.Response = Response;
        exports.FetchError = FetchError;
    })(lib$1, lib$1.exports);
    var fetch = getDefaultExportFromCjs(lib$1.exports);
    const readFile = util.promisify(fs.readFile);
    const writeFile = util.promisify(fs.writeFile);
    function getFilename(path$1, params) {
        const digest = Checksum160.hash(Bytes.from(path$1 + (params ? JSON.stringify(params) : ""), "utf8")).hexString;
        return path.join(__dirname, "../data", digest + ".json");
    }
    function getExisting(filename) {
        return __awaiter(this, void 0, void 0, (function*() {
            try {
                const data = yield readFile(filename);
                return JSON.parse(data.toString("utf8"));
            } catch (error) {
                if (error.code !== "ENOENT") {
                    throw error;
                }
            }
        }));
    }
    function mockFetch(path, params) {
        return __awaiter(this, void 0, void 0, (function*() {
            const filename = getFilename(path, params);
            if (process.env["MOCK"] !== "overwrite") {
                const existing = yield getExisting(filename);
                if (existing) {
                    return new lib$1.exports.Response(existing.text, {
                        status: existing.status,
                        headers: existing.headers
                    });
                }
            }
            if (process.env["MOCK"]) {
                const response = yield fetch(path, params);
                const json = yield response.clone().json();
                yield writeFile(filename, JSON.stringify({
                    request: {
                        path: path,
                        params: params
                    },
                    headers: Object.fromEntries(response.headers.entries()),
                    status: response.status,
                    json: json,
                    text: JSON.stringify(json)
                }, undefined, 4));
                return response;
            } else {
                throw new Error(`No data for ${path}`);
            }
        }));
    }
    function makeClient(url) {
        return new APIClient({
            provider: new FetchProvider(url || mockUrl, {
                fetch: mockFetch
            })
        });
    }
    makeClient();
    suite("context", (function() {
        suite("pre-sign", (function() {
            test("prepend action on `action`", (function() {
                return __awaiter(this, void 0, void 0, (function*() {}));
            }));
        }));
    }));
    var pako = {};
    var deflate$4 = {};
    var deflate$3 = {};
    var trees = {};
    const Z_FIXED$1 = 4;
    const Z_BINARY = 0;
    const Z_TEXT = 1;
    const Z_UNKNOWN$1 = 2;
    function zero$1(buf) {
        let len = buf.length;
        while (--len >= 0) {
            buf[len] = 0;
        }
    }
    const STORED_BLOCK = 0;
    const STATIC_TREES = 1;
    const DYN_TREES = 2;
    const MIN_MATCH$1 = 3;
    const MAX_MATCH$1 = 258;
    const LENGTH_CODES$1 = 29;
    const LITERALS$1 = 256;
    const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    const D_CODES$1 = 30;
    const BL_CODES$1 = 19;
    const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    const MAX_BITS$1 = 15;
    const Buf_size = 16;
    const MAX_BL_BITS = 7;
    const END_BLOCK = 256;
    const REP_3_6 = 16;
    const REPZ_3_10 = 17;
    const REPZ_11_138 = 18;
    const extra_lbits = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ]);
    const extra_dbits = new Uint8Array([ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ]);
    const extra_blbits = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ]);
    const bl_order = new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);
    const DIST_CODE_LEN = 512;
    const static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    const static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    const _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    const base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    const base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
    }
    let static_l_desc;
    let static_d_desc;
    let static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
    }
    const d_code = dist => dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    const put_short = (s, w) => {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    const send_bits = (s, value, length) => {
        if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
        }
    };
    const send_code = (s, c, tree) => {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    };
    const bi_reverse = (code, len) => {
        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        } while (--len > 0);
        return res >>> 1;
    };
    const bi_flush = s => {
        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    };
    const gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
            s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
                continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
        }
        if (overflow === 0) {
            return;
        }
        do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
                bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) {
                    continue;
                }
                if (tree[m * 2 + 1] !== bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    };
    const gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS$1 + 1);
        let code = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS$1; bits++) {
            code = code + bl_count[bits - 1] << 1;
            next_code[bits] = code;
        }
        for (n = 0; n <= max_code; n++) {
            let len = tree[n * 2 + 1];
            if (len === 0) {
                continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    };
    const tr_static_init = () => {
        let n;
        let bits;
        let length;
        let code;
        let dist;
        const bl_count = new Array(MAX_BITS$1 + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code;
            }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code;
            }
        }
        dist >>= 7;
        for (;code < D_CODES$1; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                _dist_code[256 + dist++] = code;
            }
        }
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
            bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
        }
        while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
        }
        while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
        for (n = 0; n < D_CODES$1; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    const init_block = s => {
        let n;
        for (n = 0; n < L_CODES$1; n++) {
            s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES$1; n++) {
            s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES$1; n++) {
            s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
    };
    const bi_windup = s => {
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    };
    const smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    const pqdownheap = (s, tree, k) => {
        const v = s.heap[k];
        let j = k << 1;
        while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
        }
        s.heap[k] = v;
    };
    const compress_block = (s, ltree, dtree) => {
        let dist;
        let lc;
        let sx = 0;
        let code;
        let extra;
        if (s.sym_next !== 0) {
            do {
                dist = s.pending_buf[s.sym_buf + sx++] & 255;
                dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
                lc = s.pending_buf[s.sym_buf + sx++];
                if (dist === 0) {
                    send_code(s, lc, ltree);
                } else {
                    code = _length_code[lc];
                    send_code(s, code + LITERALS$1 + 1, ltree);
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                    }
                    dist--;
                    code = d_code(dist);
                    send_code(s, code, dtree);
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                    }
                }
            } while (sx < s.sym_next);
        }
        send_code(s, END_BLOCK, ltree);
    };
    const build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE$1;
        for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
                s.static_len -= stree[node * 2 + 1];
            }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
        }
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
    };
    const scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    s.bl_tree[curlen * 2]++;
                }
                s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]++;
            } else {
                s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };
    const send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(s, curlen, s.bl_tree);
                } while (--count !== 0);
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };
    const build_bl_tree = s => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                break;
            }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    };
    const send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    const detect_data_type = s => {
        let block_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, block_mask >>>= 1) {
            if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                return Z_BINARY;
            }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
        }
        for (n = 32; n < LITERALS$1; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
                return Z_TEXT;
            }
        }
        return Z_BINARY;
    };
    let static_init_done = false;
    const _tr_init$1 = s => {
        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
    };
    const _tr_stored_block$1 = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        bi_windup(s);
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
            s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
    };
    const _tr_align$1 = s => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    };
    const _tr_flush_block$1 = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN$1) {
                s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
            }
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block$1(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
        } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
            bi_windup(s);
        }
    };
    const _tr_tally$1 = (s, dist, lc) => {
        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
        } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.sym_next === s.sym_end;
    };
    trees._tr_init = _tr_init$1;
    trees._tr_stored_block = _tr_stored_block$1;
    trees._tr_flush_block = _tr_flush_block$1;
    trees._tr_tally = _tr_tally$1;
    trees._tr_align = _tr_align$1;
    const adler32$2 = (adler, buf, len, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
    };
    var adler32_1 = adler32$2;
    const makeTable = () => {
        let c, table = [];
        for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
        }
        return table;
    };
    const crcTable = new Uint32Array(makeTable());
    const crc32$2 = (crc, buf, len, pos) => {
        const t = crcTable;
        const end = pos + len;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
    };
    var crc32_1 = crc32$2;
    var messages = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    };
    var constants$1 = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
    const {_tr_init: _tr_init, _tr_stored_block: _tr_stored_block, _tr_flush_block: _tr_flush_block, _tr_tally: _tr_tally, _tr_align: _tr_align} = trees;
    const adler32$1 = adler32_1;
    const crc32$1 = crc32_1;
    const msg$2 = messages;
    const {Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED: Z_FILTERED, Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY, Z_RLE: Z_RLE, Z_FIXED: Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN: Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2} = constants$1;
    const MAX_MEM_LEVEL = 9;
    const MAX_WBITS$1 = 15;
    const DEF_MEM_LEVEL = 8;
    const LENGTH_CODES = 29;
    const LITERALS = 256;
    const L_CODES = LITERALS + 1 + LENGTH_CODES;
    const D_CODES = 30;
    const BL_CODES = 19;
    const HEAP_SIZE = 2 * L_CODES + 1;
    const MAX_BITS = 15;
    const MIN_MATCH = 3;
    const MAX_MATCH = 258;
    const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    const PRESET_DICT = 32;
    const INIT_STATE = 42;
    const GZIP_STATE = 57;
    const EXTRA_STATE = 69;
    const NAME_STATE = 73;
    const COMMENT_STATE = 91;
    const HCRC_STATE = 103;
    const BUSY_STATE = 113;
    const FINISH_STATE = 666;
    const BS_NEED_MORE = 1;
    const BS_BLOCK_DONE = 2;
    const BS_FINISH_STARTED = 3;
    const BS_FINISH_DONE = 4;
    const OS_CODE = 3;
    const err = (strm, errorCode) => {
        strm.msg = msg$2[errorCode];
        return errorCode;
    };
    const rank = f => f * 2 - (f > 4 ? 9 : 0);
    const zero = buf => {
        let len = buf.length;
        while (--len >= 0) {
            buf[len] = 0;
        }
    };
    const slide_hash = s => {
        let n, m;
        let p;
        let wsize = s.w_size;
        n = s.hash_size;
        p = n;
        do {
            m = s.head[--p];
            s.head[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
        n = wsize;
        p = n;
        do {
            m = s.prev[--p];
            s.prev[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
    };
    let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    let HASH = HASH_ZLIB;
    const flush_pending = strm => {
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) {
            return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    };
    const flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    };
    const put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
    };
    const putShortMSB = (s, b) => {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
    };
    const read_buf = (strm, buf, start, size) => {
        let len = strm.avail_in;
        if (len > size) {
            len = size;
        }
        if (len === 0) {
            return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32$1(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
            strm.adler = crc32$1(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
    };
    const longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
        }
        do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
            }
            scan += 2;
            match++;
            do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
            }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    };
    const fill_window = s => {
        const _w_size = s.w_size;
        let n, more, str;
        do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                s.block_start -= _w_size;
                if (s.insert > s.strstart) {
                    s.insert = s.strstart;
                }
                slide_hash(s);
                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
                while (s.insert) {
                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    const deflate_stored = (s, flush) => {
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
            len = 65535;
            have = s.bi_valid + 42 >> 3;
            if (s.strm.avail_out < have) {
                break;
            }
            have = s.strm.avail_out - have;
            left = s.strstart - s.block_start;
            if (len > left + s.strm.avail_in) {
                len = left + s.strm.avail_in;
            }
            if (len > have) {
                len = have;
            }
            if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
                break;
            }
            last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
            _tr_stored_block(s, 0, 0, last);
            s.pending_buf[s.pending - 4] = len;
            s.pending_buf[s.pending - 3] = len >> 8;
            s.pending_buf[s.pending - 2] = ~len;
            s.pending_buf[s.pending - 1] = ~len >> 8;
            flush_pending(s.strm);
            if (left) {
                if (left > len) {
                    left = len;
                }
                s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
                s.strm.next_out += left;
                s.strm.avail_out -= left;
                s.strm.total_out += left;
                s.block_start += left;
                len -= left;
            }
            if (len) {
                read_buf(s.strm, s.strm.output, s.strm.next_out, len);
                s.strm.next_out += len;
                s.strm.avail_out -= len;
                s.strm.total_out += len;
            }
        } while (last === 0);
        used -= s.strm.avail_in;
        if (used) {
            if (used >= s.w_size) {
                s.matches = 2;
                s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
                s.strstart = s.w_size;
                s.insert = s.strstart;
            } else {
                if (s.window_size - s.strstart <= used) {
                    s.strstart -= s.w_size;
                    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                    if (s.matches < 2) {
                        s.matches++;
                    }
                    if (s.insert > s.strstart) {
                        s.insert = s.strstart;
                    }
                }
                s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
                s.strstart += used;
                s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
            }
            s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }
        if (last) {
            return BS_FINISH_DONE;
        }
        if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
            return BS_BLOCK_DONE;
        }
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
            s.block_start -= s.w_size;
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
                s.matches++;
            }
            have += s.w_size;
            if (s.insert > s.strstart) {
                s.insert = s.strstart;
            }
        }
        if (have > s.strm.avail_in) {
            have = s.strm.avail_in;
        }
        if (have) {
            read_buf(s.strm, s.window, s.strstart, have);
            s.strstart += have;
            s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }
        have = s.bi_valid + 42 >> 3;
        have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
            len = left > have ? have : left;
            last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
            _tr_stored_block(s, s.block_start, len, last);
            s.block_start += len;
            flush_pending(s.strm);
        }
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    const deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                    s.match_length--;
                    do {
                        s.strstart++;
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    } while (--s.match_length !== 0);
                    s.strstart++;
                } else {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
                }
            } else {
                bflush = _tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                    s.match_length = MIN_MATCH - 1;
                }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            } else if (s.match_available) {
                bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
                if (bflush) {
                    flush_block_only(s, false);
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (;;) {
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                bflush = _tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_huff = (s, flush) => {
        let bflush;
        for (;;) {
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH$2) {
                        return BS_NEED_MORE;
                    }
                    break;
                }
            }
            s.match_length = 0;
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    }
    const configuration_table = [ new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ];
    const lm_init = s => {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    };
    function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED$2;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero(this.depth);
        this.sym_buf = 0;
        this.lit_bufsize = 0;
        this.sym_next = 0;
        this.sym_end = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
    }
    const deflateStateCheck = strm => {
        if (!strm) {
            return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
            return 1;
        }
        return 0;
    };
    const deflateResetKeep = strm => {
        if (deflateStateCheck(strm)) {
            return err(strm, Z_STREAM_ERROR$2);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
            s.wrap = -s.wrap;
        }
        s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK$3;
    };
    const deflateReset = strm => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK$3) {
            lm_init(strm.state);
        }
        return ret;
    };
    const deflateSetHeader = (strm, head) => {
        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
            return Z_STREAM_ERROR$2;
        }
        strm.state.gzhead = head;
        return Z_OK$3;
    };
    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
        if (!strm) {
            return Z_STREAM_ERROR$2;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION$1) {
            level = 6;
        }
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
            return err(strm, Z_STREAM_ERROR$2);
        }
        if (windowBits === 8) {
            windowBits = 9;
        }
        const s = new DeflateState;
        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.sym_buf = s.lit_bufsize;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
    };
    const deflateInit = (strm, level) => deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    const deflate$2 = (strm, flush) => {
        if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
        }
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
            return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === INIT_STATE && s.wrap === 0) {
            s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
            let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
            } else if (s.level < 6) {
                level_flags = 1;
            } else if (s.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
                header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        if (s.status === GZIP_STATE) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
                flush_pending(strm);
                if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            } else {
                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 255);
                    put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                    strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
            }
        }
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
                let beg = s.pending;
                let left = (s.gzhead.extra.length & 65535) - s.gzindex;
                while (s.pending + left > s.pending_buf_size) {
                    let copy = s.pending_buf_size - s.pending;
                    s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
                    s.pending = s.pending_buf_size;
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    s.gzindex += copy;
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                    beg = 0;
                    left -= copy;
                }
                let gzhead_extra = new Uint8Array(s.gzhead.extra);
                s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
                s.pending += left;
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex = 0;
            }
            s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
                let beg = s.pending;
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex = 0;
            }
            s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
                let beg = s.pending;
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
            }
            s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                }
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
            }
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
            let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                }
                return Z_OK$3;
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    _tr_align(s);
                } else if (flush !== Z_BLOCK$1) {
                    _tr_stored_block(s, 0, 0, false);
                    if (flush === Z_FULL_FLUSH$1) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            }
        }
        if (flush !== Z_FINISH$3) {
            return Z_OK$3;
        }
        if (s.wrap <= 0) {
            return Z_STREAM_END$3;
        }
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
        } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
            s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    const deflateEnd = strm => {
        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }
        const status = strm.state.status;
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    const deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR$2;
        }
        if (wrap === 1) {
            strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
            if (wrap === 0) {
                zero(s.head);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
            }
            let tmpDict = new Uint8Array(s.w_size);
            tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
            let str = s.strstart;
            let n = s.lookahead - (MIN_MATCH - 1);
            do {
                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK$3;
    };
    deflate$3.deflateInit = deflateInit;
    deflate$3.deflateInit2 = deflateInit2;
    deflate$3.deflateReset = deflateReset;
    deflate$3.deflateResetKeep = deflateResetKeep;
    deflate$3.deflateSetHeader = deflateSetHeader;
    deflate$3.deflate = deflate$2;
    deflate$3.deflateEnd = deflateEnd;
    deflate$3.deflateSetDictionary = deflateSetDictionary;
    deflate$3.deflateInfo = "pako deflate (from Nodeca project)";
    var common = {};
    const _has = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    common.assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
            const source = sources.shift();
            if (!source) {
                continue;
            }
            if (typeof source !== "object") {
                throw new TypeError(source + "must be non-object");
            }
            for (const p in source) {
                if (_has(source, p)) {
                    obj[p] = source[p];
                }
            }
        }
        return obj;
    };
    common.flattenChunks = chunks => {
        let len = 0;
        for (let i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
        }
        const result = new Uint8Array(len);
        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
            let chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
        }
        return result;
    };
    var strings$2 = {};
    let STR_APPLY_UIA_OK = true;
    try {
        String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
        STR_APPLY_UIA_OK = false;
    }
    const _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    strings$2.string2buf = str => {
        if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
            return (new TextEncoder).encode(str);
        }
        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                    m_pos++;
                }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                    m_pos++;
                }
            }
            if (c < 128) {
                buf[i++] = c;
            } else if (c < 2048) {
                buf[i++] = 192 | c >>> 6;
                buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
                buf[i++] = 224 | c >>> 12;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
            } else {
                buf[i++] = 240 | c >>> 18;
                buf[i++] = 128 | c >>> 12 & 63;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
            }
        }
        return buf;
    };
    const buf2binstring = (buf, len) => {
        if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK) {
                return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
            }
        }
        let result = "";
        for (let i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
        }
        return result;
    };
    strings$2.buf2string = (buf, max) => {
        const len = max || buf.length;
        if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
            return (new TextDecoder).decode(buf.subarray(0, max));
        }
        let i, out;
        const utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
            let c = buf[i++];
            if (c < 128) {
                utf16buf[out++] = c;
                continue;
            }
            let c_len = _utf8len[c];
            if (c_len > 4) {
                utf16buf[out++] = 65533;
                i += c_len - 1;
                continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 63;
                c_len--;
            }
            if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
            }
            if (c < 65536) {
                utf16buf[out++] = c;
            } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
            }
        }
        return buf2binstring(utf16buf, out);
    };
    strings$2.utf8border = (buf, max) => {
        max = max || buf.length;
        if (max > buf.length) {
            max = buf.length;
        }
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
        }
        if (pos < 0) {
            return max;
        }
        if (pos === 0) {
            return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    function ZStream$2() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
    }
    var zstream = ZStream$2;
    const zlib_deflate = deflate$3;
    const utils$1 = common;
    const strings$1 = strings$2;
    const msg$1 = messages;
    const ZStream$1 = zstream;
    const toString$1 = Object.prototype.toString;
    const {Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH: Z_SYNC_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1} = constants$1;
    function Deflate$1(options) {
        this.options = utils$1.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream$1;
        this.strm.avail_out = 0;
        let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK$2) {
            throw new Error(msg$1[status]);
        }
        if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
            let dict;
            if (typeof opt.dictionary === "string") {
                dict = strings$1.string2buf(opt.dictionary);
            } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(opt.dictionary);
            } else {
                dict = opt.dictionary;
            }
            status = zlib_deflate.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK$2) {
                throw new Error(msg$1[status]);
            }
            this._dict_set = true;
        }
    }
    Deflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
            return false;
        }
        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode; else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
        if (typeof data === "string") {
            strm.input = strings$1.string2buf(data);
        } else if (toString$1.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (;;) {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }
            status = zlib_deflate.deflate(strm, _flush_mode);
            if (status === Z_STREAM_END$2) {
                if (strm.next_out > 0) {
                    this.onData(strm.output.subarray(0, strm.next_out));
                }
                status = zlib_deflate.deflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === Z_OK$2;
            }
            if (strm.avail_out === 0) {
                this.onData(strm.output);
                continue;
            }
            if (_flush_mode > 0 && strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }
            if (strm.avail_in === 0) break;
        }
        return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK$2) {
            this.result = utils$1.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    function deflate$1(input, options) {
        const deflator = new Deflate$1(options);
        deflator.push(input, true);
        if (deflator.err) {
            throw deflator.msg || msg$1[deflator.err];
        }
        return deflator.result;
    }
    function deflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return deflate$1(input, options);
    }
    function gzip$1(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate$1(input, options);
    }
    deflate$4.Deflate = Deflate$1;
    deflate$4.deflate = deflate$1;
    deflate$4.deflateRaw = deflateRaw$1;
    deflate$4.gzip = gzip$1;
    deflate$4.constants = constants$1;
    var inflate$4 = {};
    var inflate$3 = {};
    const BAD$1 = 16209;
    const TYPE$1 = 16191;
    var inffast = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
            if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
            }
            here = lcode[hold & lmask];
            dolen: for (;;) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                    output[_out++] = here & 65535;
                } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        len += hold & (1 << op) - 1;
                        hold >>>= op;
                        bits -= op;
                    }
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist: for (;;) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                            dist = here & 65535;
                            op &= 15;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                            }
                            dist += hold & (1 << op) - 1;
                            if (dist > dmax) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD$1;
                                break top;
                            }
                            hold >>>= op;
                            bits -= op;
                            op = _out - beg;
                            if (dist > op) {
                                op = dist - op;
                                if (op > whave) {
                                    if (state.sane) {
                                        strm.msg = "invalid distance too far back";
                                        state.mode = BAD$1;
                                        break top;
                                    }
                                }
                                from = 0;
                                from_source = s_window;
                                if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = 0;
                                        if (wnext < len) {
                                            op = wnext;
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist;
                                            from_source = output;
                                        }
                                    }
                                } else {
                                    from += wnext - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                                while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                }
                                if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                        output[_out++] = from_source[from++];
                                    }
                                }
                            } else {
                                from = _out - dist;
                                do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                } while (len > 2);
                                if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                        output[_out++] = output[from++];
                                    }
                                }
                            }
                        } else if ((op & 64) === 0) {
                            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dodist;
                        } else {
                            strm.msg = "invalid distance code";
                            state.mode = BAD$1;
                            break top;
                        }
                        break;
                    }
                } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                } else if (op & 32) {
                    state.mode = TYPE$1;
                    break top;
                } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD$1;
                    break top;
                }
                break;
            }
        } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
    };
    const MAXBITS = 15;
    const ENOUGH_LENS$1 = 852;
    const ENOUGH_DISTS$1 = 592;
    const CODES$1 = 0;
    const LENS$1 = 1;
    const DISTS$1 = 2;
    const lbase = new Uint16Array([ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ]);
    const lext = new Uint8Array([ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ]);
    const dbase = new Uint16Array([ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ]);
    const dext = new Uint8Array([ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ]);
    const inflate_table$1 = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let match;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
                break;
            }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
        }
        for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
                break;
            }
        }
        if (root < min) {
            root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }
        }
        if (left > 0 && (type === CODES$1 || max !== 1)) {
            return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }
        if (type === CODES$1) {
            base = extra = work;
            match = 20;
        } else if (type === LENS$1) {
            base = lbase;
            extra = lext;
            match = 257;
        } else {
            base = dbase;
            extra = dext;
            match = 0;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
        }
        for (;;) {
            here_bits = len - drop;
            if (work[sym] + 1 < match) {
                here_op = 0;
                here_val = work[sym];
            } else if (work[sym] >= match) {
                here_op = extra[work[sym] - match];
                here_val = base[work[sym] - match];
            } else {
                here_op = 32 + 64;
                here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
                if (len === max) {
                    break;
                }
                len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
                if (drop === 0) {
                    drop = root;
                }
                next += min;
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                    left -= count[curr + drop];
                    if (left <= 0) {
                        break;
                    }
                    curr++;
                    left <<= 1;
                }
                used += 1 << curr;
                if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
                    return 1;
                }
                low = huff & mask;
                table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
        }
        if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
    };
    var inftrees = inflate_table$1;
    const adler32 = adler32_1;
    const crc32 = crc32_1;
    const inflate_fast = inffast;
    const inflate_table = inftrees;
    const CODES = 0;
    const LENS = 1;
    const DISTS = 2;
    const {Z_FINISH: Z_FINISH$1, Z_BLOCK: Z_BLOCK, Z_TREES: Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR: Z_BUF_ERROR, Z_DEFLATED: Z_DEFLATED} = constants$1;
    const HEAD = 16180;
    const FLAGS = 16181;
    const TIME = 16182;
    const OS = 16183;
    const EXLEN = 16184;
    const EXTRA = 16185;
    const NAME = 16186;
    const COMMENT = 16187;
    const HCRC = 16188;
    const DICTID = 16189;
    const DICT = 16190;
    const TYPE = 16191;
    const TYPEDO = 16192;
    const STORED = 16193;
    const COPY_ = 16194;
    const COPY = 16195;
    const TABLE = 16196;
    const LENLENS = 16197;
    const CODELENS = 16198;
    const LEN_ = 16199;
    const LEN = 16200;
    const LENEXT = 16201;
    const DIST = 16202;
    const DISTEXT = 16203;
    const MATCH = 16204;
    const LIT = 16205;
    const CHECK = 16206;
    const LENGTH = 16207;
    const DONE = 16208;
    const BAD = 16209;
    const MEM = 16210;
    const SYNC = 16211;
    const ENOUGH_LENS = 852;
    const ENOUGH_DISTS = 592;
    const MAX_WBITS = 15;
    const DEF_WBITS = MAX_WBITS;
    const zswap32 = q => (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    function InflateState() {
        this.strm = null;
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
    }
    const inflateStateCheck = strm => {
        if (!strm) {
            return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
            return 1;
        }
        return 0;
    };
    const inflateResetKeep = strm => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK$1;
    };
    const inflateReset = strm => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
    };
    const inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else {
            wrap = (windowBits >> 4) + 5;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR$1;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    };
    const inflateInit2 = (strm, windowBits) => {
        if (!strm) {
            return Z_STREAM_ERROR$1;
        }
        const state = new InflateState;
        strm.state = state;
        state.strm = strm;
        state.window = null;
        state.mode = HEAD;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK$1) {
            strm.state = null;
        }
        return ret;
    };
    const inflateInit = strm => inflateInit2(strm, DEF_WBITS);
    let virgin = true;
    let lenfix, distfix;
    const fixedtables = state => {
        if (virgin) {
            lenfix = new Int32Array(512);
            distfix = new Int32Array(32);
            let sym = 0;
            while (sym < 144) {
                state.lens[sym++] = 8;
            }
            while (sym < 256) {
                state.lens[sym++] = 9;
            }
            while (sym < 280) {
                state.lens[sym++] = 7;
            }
            while (sym < 288) {
                state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                bits: 9
            });
            sym = 0;
            while (sym < 32) {
                state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5
            });
            virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    };
    const updatewindow = (strm, src, end, copy) => {
        let dist;
        const state = strm.state;
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new Uint8Array(state.wsize);
        }
        if (copy >= state.wsize) {
            state.window.set(src.subarray(end - state.wsize, end), 0);
            state.wnext = 0;
            state.whave = state.wsize;
        } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
            copy -= dist;
            if (copy) {
                state.window.set(src.subarray(end - copy, end), 0);
                state.wnext = copy;
                state.whave = state.wsize;
            } else {
                state.wnext += dist;
                if (state.wnext === state.wsize) {
                    state.wnext = 0;
                }
                if (state.whave < state.wsize) {
                    state.whave += dist;
                }
            }
        }
        return 0;
    };
    const inflate$2 = (strm, flush) => {
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);
        if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.mode === TYPE) {
            state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK$1;
        inf_leave: for (;;) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                }
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                    if (state.wbits === 0) {
                        state.wbits = 15;
                    }
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                }
                if (state.head) {
                    state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                    state.wbits = len;
                }
                if (len > 15 || len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                }
                state.dmax = 1 << state.wbits;
                state.flags = 0;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;

              case FLAGS:
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                }
                if (state.head) {
                    state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;

              case TIME:
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.time = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;

              case OS:
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                }
                if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;

              case EXLEN:
                if (state.flags & 1024) {
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                        state.head.extra_len = hold;
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state.head) {
                    state.head.extra = null;
                }
                state.mode = EXTRA;

              case EXTRA:
                if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy) {
                        if (state.head) {
                            len = state.head.extra_len - state.length;
                            if (!state.head.extra) {
                                state.head.extra = new Uint8Array(state.head.extra_len);
                            }
                            state.head.extra.set(input.subarray(next, next + copy), len);
                        }
                        if (state.flags & 512 && state.wrap & 4) {
                            state.check = crc32(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        state.length -= copy;
                    }
                    if (state.length) {
                        break inf_leave;
                    }
                }
                state.length = 0;
                state.mode = NAME;

              case NAME:
                if (state.flags & 2048) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.name += String.fromCharCode(len);
                        }
                    } while (len && copy < have);
                    if (state.flags & 512 && state.wrap & 4) {
                        state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;

              case COMMENT:
                if (state.flags & 4096) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.comment += String.fromCharCode(len);
                        }
                    } while (len && copy < have);
                    if (state.flags & 512 && state.wrap & 4) {
                        state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.comment = null;
                }
                state.mode = HCRC;

              case HCRC:
                if (state.flags & 512) {
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.check & 65535)) {
                        strm.msg = "header crc mismatch";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;

              case DICTID:
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;

              case DICT:
                if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT$1;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;

              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                }

              case TYPEDO:
                if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                }
                while (bits < 3) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;

                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                    }
                    break;

                  case 2:
                    state.mode = TABLE;
                    break;

                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;

              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }

              case COPY_:
                state.mode = COPY;

              case COPY:
                copy = state.length;
                if (copy) {
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy > left) {
                        copy = left;
                    }
                    if (copy === 0) {
                        break inf_leave;
                    }
                    output.set(input.subarray(next, next + copy), put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                }
                state.mode = TYPE;
                break;

              case TABLE:
                while (bits < 14) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = LENLENS;

              case LENLENS:
                while (state.have < state.ncode) {
                    while (bits < 3) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                }
                while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                    bits: state.lenbits
                };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = CODELENS;

              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                    for (;;) {
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n = here_bits + 2;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                            }
                            len = state.lens[state.have - 1];
                            copy = 3 + (hold & 3);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n = here_bits + 3;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 3 + (hold & 7);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n = here_bits + 7;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 11 + (hold & 127);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                            strm.msg = "invalid bit length repeat";
                            state.mode = BAD;
                            break;
                        }
                        while (copy--) {
                            state.lens[state.have++] = len;
                        }
                    }
                }
                if (state.mode === BAD) {
                    break;
                }
                if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                }
                state.lenbits = 9;
                opts = {
                    bits: state.lenbits
                };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                    bits: state.distbits
                };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }

              case LEN_:
                state.mode = LEN;

              case LEN:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                        state.back = -1;
                    }
                    break;
                }
                state.back = 0;
                for (;;) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (;;) {
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                    state.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;

              case LENEXT:
                if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;

              case DIST:
                for (;;) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (;;) {
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;

              case DISTEXT:
                if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                }
                state.mode = MATCH;

              case MATCH:
                if (left === 0) {
                    break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                        if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break;
                        }
                    }
                    if (copy > state.wnext) {
                        copy -= state.wnext;
                        from = state.wsize - copy;
                    } else {
                        from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                        copy = state.length;
                    }
                    from_source = state.window;
                } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                }
                if (copy > left) {
                    copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                    output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                    state.mode = LEN;
                }
                break;

              case LIT:
                if (left === 0) {
                    break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;

              case CHECK:
                if (state.wrap) {
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (state.wrap & 4 && _out) {
                        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = LENGTH;

              case LENGTH:
                if (state.wrap && state.flags) {
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                        strm.msg = "incorrect length check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = DONE;

              case DONE:
                ret = Z_STREAM_END$1;
                break inf_leave;

              case BAD:
                ret = Z_DATA_ERROR$1;
                break inf_leave;

              case MEM:
                return Z_MEM_ERROR$1;

              case SYNC:
              default:
                return Z_STREAM_ERROR$1;
            }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap & 4 && _out) {
            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    };
    const inflateEnd = strm => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        let state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK$1;
    };
    const inflateGetHeader = (strm, head) => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR$1;
        }
        state.head = head;
        head.done = false;
        return Z_OK$1;
    };
    const inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR$1;
        }
        if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
                return Z_DATA_ERROR$1;
            }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR$1;
        }
        state.havedict = 1;
        return Z_OK$1;
    };
    inflate$3.inflateReset = inflateReset;
    inflate$3.inflateReset2 = inflateReset2;
    inflate$3.inflateResetKeep = inflateResetKeep;
    inflate$3.inflateInit = inflateInit;
    inflate$3.inflateInit2 = inflateInit2;
    inflate$3.inflate = inflate$2;
    inflate$3.inflateEnd = inflateEnd;
    inflate$3.inflateGetHeader = inflateGetHeader;
    inflate$3.inflateSetDictionary = inflateSetDictionary;
    inflate$3.inflateInfo = "pako inflate (from Nodeca project)";
    function GZheader$1() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
    }
    var gzheader = GZheader$1;
    const zlib_inflate = inflate$3;
    const utils = common;
    const strings = strings$2;
    const msg = messages;
    const ZStream = zstream;
    const GZheader = gzheader;
    const toString = Object.prototype.toString;
    const {Z_NO_FLUSH: Z_NO_FLUSH, Z_FINISH: Z_FINISH, Z_OK: Z_OK, Z_STREAM_END: Z_STREAM_END, Z_NEED_DICT: Z_NEED_DICT, Z_STREAM_ERROR: Z_STREAM_ERROR, Z_DATA_ERROR: Z_DATA_ERROR, Z_MEM_ERROR: Z_MEM_ERROR} = constants$1;
    function Inflate$1(options) {
        this.options = utils.assign({
            chunkSize: 1024 * 64,
            windowBits: 15,
            to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
                opt.windowBits = -15;
            }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
            }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream;
        this.strm.avail_out = 0;
        let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== Z_OK) {
            throw new Error(msg[status]);
        }
        this.header = new GZheader;
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
                opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
                status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
                if (status !== Z_OK) {
                    throw new Error(msg[status]);
                }
            }
        }
    }
    Inflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended) return false;
        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode; else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (;;) {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status = zlib_inflate.inflate(strm, _flush_mode);
            if (status === Z_NEED_DICT && dictionary) {
                status = zlib_inflate.inflateSetDictionary(strm, dictionary);
                if (status === Z_OK) {
                    status = zlib_inflate.inflate(strm, _flush_mode);
                } else if (status === Z_DATA_ERROR) {
                    status = Z_NEED_DICT;
                }
            }
            while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
                zlib_inflate.inflateReset(strm);
                status = zlib_inflate.inflate(strm, _flush_mode);
            }
            switch (status) {
              case Z_STREAM_ERROR:
              case Z_DATA_ERROR:
              case Z_NEED_DICT:
              case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            last_avail_out = strm.avail_out;
            if (strm.next_out) {
                if (strm.avail_out === 0 || status === Z_STREAM_END) {
                    if (this.options.to === "string") {
                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                        let tail = strm.next_out - next_out_utf8;
                        let utf8str = strings.buf2string(strm.output, next_out_utf8);
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                        this.onData(utf8str);
                    } else {
                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                    }
                }
            }
            if (status === Z_OK && last_avail_out === 0) continue;
            if (status === Z_STREAM_END) {
                status = zlib_inflate.inflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return true;
            }
            if (strm.avail_in === 0) break;
        }
        return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK) {
            if (this.options.to === "string") {
                this.result = this.chunks.join("");
            } else {
                this.result = utils.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    function inflate$1(input, options) {
        const inflator = new Inflate$1(options);
        inflator.push(input);
        if (inflator.err) throw inflator.msg || msg[inflator.err];
        return inflator.result;
    }
    function inflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return inflate$1(input, options);
    }
    inflate$4.Inflate = Inflate$1;
    inflate$4.inflate = inflate$1;
    inflate$4.inflateRaw = inflateRaw$1;
    inflate$4.ungzip = inflate$1;
    inflate$4.constants = constants$1;
    const {Deflate: Deflate, deflate: deflate, deflateRaw: deflateRaw, gzip: gzip} = deflate$4;
    const {Inflate: Inflate, inflate: inflate, inflateRaw: inflateRaw, ungzip: ungzip} = inflate$4;
    const constants = constants$1;
    pako.Deflate = Deflate;
    pako.deflate = deflate;
    pako.deflateRaw = deflateRaw;
    pako.gzip = gzip;
    pako.Inflate = Inflate;
    pako.inflate = inflate;
    pako.inflateRaw = inflateRaw;
    pako.ungzip = ungzip;
    pako.constants = constants;
    /**
     * EOSIO Signing Request v2.5.2
     * https://github.com/greymass/eosio-signing-request
     *
     * @license
     * Copyright © 2021 Greymass Inc.
     * 
     * Permission is hereby granted, free of charge, to any person
     * obtaining a copy of this software and associated documentation
     * files (the “Software”), to deal in the Software without
     * restriction, including without limitation the rights to use,
     * copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the
     * Software is furnished to do so, subject to the following
     * conditions:
     * 
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     * OTHER DEALINGS IN THE SOFTWARE.
     * 
     * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR
     * INTENDED FOR USE IN THE DESIGN, CONSTRUCTION, OPERATION OR
     * MAINTENANCE OF ANY MILITARY FACILITY.
     */    const baseCharset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const lookup = new Uint8Array(256);
    for (let i = 0; i < 62; i++) {
        lookup[baseCharset.charCodeAt(i)] = i;
    }
    lookup[43] = lookup[45] = 62;
    lookup[47] = lookup[95] = 63;
    function encode(data, urlSafe = true) {
        const byteLength = data.byteLength;
        const byteRemainder = byteLength % 3;
        const mainLength = byteLength - byteRemainder;
        const charset = baseCharset + (urlSafe ? "-_" : "+/");
        const parts = [];
        let a;
        let b;
        let c;
        let d;
        let chunk;
        for (let i = 0; i < mainLength; i += 3) {
            chunk = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
            a = (chunk & 16515072) >> 18;
            b = (chunk & 258048) >> 12;
            c = (chunk & 4032) >> 6;
            d = chunk & 63;
            parts.push(charset[a] + charset[b] + charset[c] + charset[d]);
        }
        if (byteRemainder === 1) {
            chunk = data[mainLength];
            a = (chunk & 252) >> 2;
            b = (chunk & 3) << 4;
            parts.push(charset[a] + charset[b]);
        } else if (byteRemainder === 2) {
            chunk = data[mainLength] << 8 | data[mainLength + 1];
            a = (chunk & 64512) >> 10;
            b = (chunk & 1008) >> 4;
            c = (chunk & 15) << 2;
            parts.push(charset[a] + charset[b] + charset[c]);
        }
        return parts.join("");
    }
    function decode(input) {
        const byteLength = input.length * .75;
        const data = new Uint8Array(byteLength);
        let a;
        let b;
        let c;
        let d;
        let p = 0;
        for (let i = 0; i < input.length; i += 4) {
            a = lookup[input.charCodeAt(i)];
            b = lookup[input.charCodeAt(i + 1)];
            c = lookup[input.charCodeAt(i + 2)];
            d = lookup[input.charCodeAt(i + 3)];
            data[p++] = a << 2 | b >> 4;
            data[p++] = (b & 15) << 4 | c >> 2;
            data[p++] = (c & 3) << 6 | d & 63;
        }
        return data;
    }
    var ChainName;
    (function(ChainName) {
        ChainName[ChainName["UNKNOWN"] = 0] = "UNKNOWN";
        ChainName[ChainName["EOS"] = 1] = "EOS";
        ChainName[ChainName["TELOS"] = 2] = "TELOS";
        ChainName[ChainName["JUNGLE"] = 3] = "JUNGLE";
        ChainName[ChainName["KYLIN"] = 4] = "KYLIN";
        ChainName[ChainName["WORBLI"] = 5] = "WORBLI";
        ChainName[ChainName["BOS"] = 6] = "BOS";
        ChainName[ChainName["MEETONE"] = 7] = "MEETONE";
        ChainName[ChainName["INSIGHTS"] = 8] = "INSIGHTS";
        ChainName[ChainName["BEOS"] = 9] = "BEOS";
        ChainName[ChainName["WAX"] = 10] = "WAX";
        ChainName[ChainName["PROTON"] = 11] = "PROTON";
        ChainName[ChainName["FIO"] = 12] = "FIO";
    })(ChainName || (ChainName = {}));
    let ChainId = class ChainId extends Checksum256 {
        static from(value) {
            if (isInstanceOf(value, this)) {
                return value;
            }
            if (typeof value === "number") {
                value = ChainIdLookup.get(value);
                if (!value) {
                    throw new Error("Unknown chain id alias");
                }
            }
            return super.from(value);
        }
        get chainVariant() {
            const name = this.chainName;
            if (name !== ChainName.UNKNOWN) {
                return ChainIdVariant.from([ "chain_alias", name ]);
            }
            return ChainIdVariant.from(this);
        }
        get chainName() {
            const cid = this.hexString;
            for (const [n, id] of ChainIdLookup) {
                if (id === cid) {
                    return n;
                }
            }
            return ChainName.UNKNOWN;
        }
    };
    ChainId = __decorate([ TypeAlias("chain_id") ], ChainId);
    let ChainAlias = class ChainAlias extends UInt8 {};
    ChainAlias = __decorate([ TypeAlias("chain_alias") ], ChainAlias);
    let ChainIdVariant = class ChainIdVariant extends Variant {
        get chainId() {
            if (isInstanceOf(this.value, ChainId)) {
                return this.value;
            }
            return ChainId.from(Number(this.value.value));
        }
    };
    ChainIdVariant = __decorate([ Variant.type("variant_id", [ ChainAlias, ChainId ]) ], ChainIdVariant);
    const ChainIdLookup = new Map([ [ ChainName.EOS, "aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906" ], [ ChainName.TELOS, "4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11" ], [ ChainName.JUNGLE, "e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473" ], [ ChainName.KYLIN, "5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191" ], [ ChainName.WORBLI, "73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f" ], [ ChainName.BOS, "d5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86" ], [ ChainName.MEETONE, "cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422" ], [ ChainName.INSIGHTS, "b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664" ], [ ChainName.BEOS, "b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4" ], [ ChainName.WAX, "1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4" ], [ ChainName.PROTON, "384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0" ], [ ChainName.FIO, "21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c" ] ]);
    var RequestFlags_1;
    let AccountName = class AccountName extends Name {};
    AccountName = __decorate([ TypeAlias("account_name") ], AccountName);
    let PermissionName = class PermissionName extends Name {};
    PermissionName = __decorate([ TypeAlias("permission_name") ], PermissionName);
    let IdentityV2 = class IdentityV2 extends Struct {};
    __decorate([ Struct.field(PermissionLevel, {
        optional: true
    }) ], IdentityV2.prototype, "permission", void 0);
    IdentityV2 = __decorate([ Struct.type("identity") ], IdentityV2);
    let IdentityV3 = class IdentityV3 extends Struct {};
    __decorate([ Struct.field("name") ], IdentityV3.prototype, "scope", void 0);
    __decorate([ Struct.field(PermissionLevel, {
        optional: true
    }) ], IdentityV3.prototype, "permission", void 0);
    IdentityV3 = __decorate([ Struct.type("identity") ], IdentityV3);
    let RequestVariantV2 = class RequestVariantV2 extends Variant {};
    RequestVariantV2 = __decorate([ Variant.type("variant_req", [ Action, {
        type: Action,
        array: true
    }, Transaction, IdentityV2 ]) ], RequestVariantV2);
    let RequestVariantV3 = class RequestVariantV3 extends Variant {};
    RequestVariantV3 = __decorate([ Variant.type("variant_req", [ Action, {
        type: Action,
        array: true
    }, Transaction, IdentityV3 ]) ], RequestVariantV3);
    let RequestFlags = RequestFlags_1 = class RequestFlags extends UInt8 {
        get broadcast() {
            return (Number(this) & RequestFlags_1.broadcast) !== 0;
        }
        set broadcast(enabled) {
            this.setFlag(RequestFlags_1.broadcast, enabled);
        }
        get background() {
            return (Number(this) & RequestFlags_1.background) !== 0;
        }
        set background(enabled) {
            this.setFlag(RequestFlags_1.background, enabled);
        }
        setFlag(flag, enabled) {
            if (enabled) {
                this.value = UInt8.from(Number(this) | flag).value;
            } else {
                this.value = UInt8.from(Number(this) & ~flag).value;
            }
        }
    };
    RequestFlags.broadcast = 1 << 0;
    RequestFlags.background = 1 << 1;
    RequestFlags = RequestFlags_1 = __decorate([ TypeAlias("request_flags") ], RequestFlags);
    let InfoPair = class InfoPair extends Struct {};
    __decorate([ Struct.field("string") ], InfoPair.prototype, "key", void 0);
    __decorate([ Struct.field("bytes") ], InfoPair.prototype, "value", void 0);
    InfoPair = __decorate([ Struct.type("info_pair") ], InfoPair);
    let RequestDataV2 = class RequestDataV2 extends Struct {};
    __decorate([ Struct.field(ChainIdVariant) ], RequestDataV2.prototype, "chain_id", void 0);
    __decorate([ Struct.field(RequestVariantV2) ], RequestDataV2.prototype, "req", void 0);
    __decorate([ Struct.field(RequestFlags) ], RequestDataV2.prototype, "flags", void 0);
    __decorate([ Struct.field("string") ], RequestDataV2.prototype, "callback", void 0);
    __decorate([ Struct.field(InfoPair, {
        array: true
    }) ], RequestDataV2.prototype, "info", void 0);
    RequestDataV2 = __decorate([ Struct.type("signing_request") ], RequestDataV2);
    let RequestDataV3 = class RequestDataV3 extends Struct {};
    __decorate([ Struct.field(ChainIdVariant) ], RequestDataV3.prototype, "chain_id", void 0);
    __decorate([ Struct.field(RequestVariantV3) ], RequestDataV3.prototype, "req", void 0);
    __decorate([ Struct.field(RequestFlags) ], RequestDataV3.prototype, "flags", void 0);
    __decorate([ Struct.field("string") ], RequestDataV3.prototype, "callback", void 0);
    __decorate([ Struct.field(InfoPair, {
        array: true
    }) ], RequestDataV3.prototype, "info", void 0);
    RequestDataV3 = __decorate([ Struct.type("signing_request") ], RequestDataV3);
    let RequestSignature = class RequestSignature extends Struct {};
    __decorate([ Struct.field("name") ], RequestSignature.prototype, "signer", void 0);
    __decorate([ Struct.field("signature") ], RequestSignature.prototype, "signature", void 0);
    RequestSignature = __decorate([ Struct.type("request_signature") ], RequestSignature);
    var IdentityProof_1;
    let IdentityProof = IdentityProof_1 = class IdentityProof extends Struct {
        static from(value) {
            if (isInstanceOf(value, IdentityProof_1)) {
                return value;
            } else if (typeof value === "string") {
                return IdentityProof_1.fromString(value);
            } else {
                return super.from(value);
            }
        }
        static fromString(string) {
            const parts = string.split(" ");
            if (parts.length !== 2 || parts[0] !== "EOSIO") {
                throw new Error("Invalid IdentityProof string");
            }
            const data = decode(parts[1]);
            return Serializer.decode({
                data: data,
                type: IdentityProof_1
            });
        }
        static fromPayload(payload, options = {}) {
            const request = SigningRequest.from(payload.req, options);
            if (!(request.version >= 3 && request.isIdentity())) {
                throw new Error("Not an identity request");
            }
            return this.from({
                chainId: payload.cid || request.getChainId(),
                scope: request.getIdentityScope(),
                expiration: payload.ex,
                signer: {
                    actor: payload.sa,
                    permission: payload.sp
                },
                signature: payload.sig
            });
        }
        get transaction() {
            const action = Action.from({
                account: "",
                name: "identity",
                authorization: [ this.signer ],
                data: IdentityV3.from({
                    scope: this.scope,
                    permission: this.signer
                })
            });
            return Transaction.from({
                ref_block_num: 0,
                ref_block_prefix: 0,
                expiration: this.expiration,
                actions: [ action ]
            });
        }
        recover() {
            return this.signature.recoverDigest(this.transaction.signingDigest(this.chainId));
        }
        verify(auth, currentTime) {
            const now = TimePointSec.from(currentTime || new Date).toMilliseconds();
            return now < this.expiration.toMilliseconds() && Authority.from(auth).hasPermission(this.recover());
        }
        toString() {
            const data = Serializer.encode({
                object: this
            });
            return `EOSIO ${encode(data.array, false)}`;
        }
    };
    __decorate([ Struct.field(ChainId) ], IdentityProof.prototype, "chainId", void 0);
    __decorate([ Struct.field(Name) ], IdentityProof.prototype, "scope", void 0);
    __decorate([ Struct.field(TimePointSec) ], IdentityProof.prototype, "expiration", void 0);
    __decorate([ Struct.field(PermissionLevel) ], IdentityProof.prototype, "signer", void 0);
    __decorate([ Struct.field(Signature) ], IdentityProof.prototype, "signature", void 0);
    IdentityProof = IdentityProof_1 = __decorate([ Struct.type("identity_proof") ], IdentityProof);
    const PlaceholderName = Name.from("............1");
    const PlaceholderPermission = Name.from("............2");
    const PlaceholderAuth = PermissionLevel.from({
        actor: PlaceholderName,
        permission: PlaceholderPermission
    });
    class SigningRequest {
        constructor(version, data, zlib, abiProvider, signature) {
            if (data.flags.broadcast && data.req.variantName === "identity") {
                throw new Error("Invalid request (identity request cannot be broadcast)");
            }
            this.version = version;
            this.data = data;
            this.zlib = zlib;
            this.abiProvider = abiProvider;
            this.signature = signature;
        }
        static identityAbi(version) {
            const abi = Serializer.synthesize(this.identityType(version));
            abi.actions = [ {
                name: "identity",
                type: "identity",
                ricardian_contract: ""
            } ];
            return abi;
        }
        static identityType(version) {
            return version === 2 ? IdentityV2 : IdentityV3;
        }
        static storageType(version) {
            return version === 2 ? RequestDataV2 : RequestDataV3;
        }
        static async create(args, options = {}) {
            let actions;
            if (args.action) {
                actions = [ args.action ];
            } else if (args.actions) {
                actions = args.actions;
            } else if (args.transaction) {
                actions = args.transaction.actions || [];
            } else {
                actions = [];
            }
            const requiredAbis = actions.filter((action => !Bytes.isBytes(action.data) && action.data.constructor.abiName === undefined)).map((action => Name.from(action.account)));
            const abis = {};
            if (requiredAbis.length > 0) {
                const provider = options.abiProvider;
                if (!provider) {
                    throw new Error("Missing abi provider");
                }
                const accountAbis = await Promise.all(requiredAbis.map((account => provider.getAbi(account))));
                for (const [idx, abi] of accountAbis.entries()) {
                    abis[requiredAbis[idx].toString()] = abi;
                }
            }
            return this.createSync(args, options, abis);
        }
        static createSync(args, options = {}, abis = {}) {
            let version = 2;
            const data = {};
            const encode = action => encodeAction(action, abis);
            if (args.chainId === null) {
                version = 3;
            }
            if (args.identity !== undefined) {
                if (args.identity.scope) {
                    version = 3;
                }
                data.req = [ "identity", this.identityType(version).from(args.identity) ];
            } else if (args.action && !args.actions && !args.transaction) {
                data.req = [ "action", encode(args.action) ];
            } else if (args.actions && !args.action && !args.transaction) {
                if (args.actions.length === 1) {
                    data.req = [ "action", encode(args.actions[0]) ];
                } else {
                    data.req = [ "action[]", args.actions.map(encode) ];
                }
            } else if (args.transaction && !args.action && !args.actions) {
                const tx = args.transaction;
                if (tx.expiration === undefined) {
                    tx.expiration = "1970-01-01T00:00:00.000";
                }
                if (tx.ref_block_num === undefined) {
                    tx.ref_block_num = 0;
                }
                if (tx.ref_block_prefix === undefined) {
                    tx.ref_block_prefix = 0;
                }
                if (tx.context_free_actions === undefined) {
                    tx.context_free_actions = [];
                }
                if (tx.transaction_extensions === undefined) {
                    tx.transaction_extensions = [];
                }
                if (tx.delay_sec === undefined) {
                    tx.delay_sec = 0;
                }
                if (tx.max_cpu_usage_ms === undefined) {
                    tx.max_cpu_usage_ms = 0;
                }
                if (tx.max_net_usage_words === undefined) {
                    tx.max_net_usage_words = 0;
                }
                if (tx.actions === undefined) {
                    tx.actions = [];
                }
                if (tx.context_free_actions === undefined) {
                    tx.context_free_actions = [];
                }
                tx.actions = tx.actions.map(encode);
                data.req = [ "transaction", tx ];
            } else {
                throw new TypeError("Invalid arguments: Must have exactly one of action, actions or transaction");
            }
            if (args.chainId === null) {
                data.chain_id = ChainIdVariant.from([ "chain_alias", 0 ]);
            } else {
                data.chain_id = ChainId.from(args.chainId || ChainName.EOS).chainVariant;
            }
            const flags = RequestFlags.from(0);
            let callback = "";
            flags.broadcast = args.broadcast !== undefined ? args.broadcast : data.req[0] !== "identity";
            if (typeof args.callback === "string") {
                callback = args.callback;
            } else if (typeof args.callback === "object") {
                callback = args.callback.url;
                flags.background = args.callback.background || false;
            }
            data.flags = flags;
            data.callback = callback;
            data.info = [];
            if (typeof args.info === "object") {
                for (const key in args.info) {
                    const isOwn = Object.prototype.hasOwnProperty.call(args.info, key);
                    if (isOwn) {
                        let value = args.info[key];
                        if (typeof value === "string") {
                            value = Bytes.from(value, "utf8");
                        } else if (!(value instanceof Bytes)) {
                            value = Serializer.encode({
                                object: value
                            });
                        }
                        data.info.push({
                            key: key,
                            value: value
                        });
                    }
                }
            }
            if (args.chainIds && args.chainId === null) {
                const ids = args.chainIds.map((id => ChainId.from(id).chainVariant));
                data.info.push({
                    key: "chain_ids",
                    value: Serializer.encode({
                        object: ids,
                        type: {
                            type: ChainIdVariant,
                            array: true
                        }
                    })
                });
            }
            const req = new SigningRequest(version, this.storageType(version).from(data), options.zlib, options.abiProvider);
            if (options.signatureProvider) {
                req.sign(options.signatureProvider);
            }
            return req;
        }
        static identity(args, options = {}) {
            let permission = {
                actor: args.account || PlaceholderName,
                permission: args.permission || PlaceholderPermission
            };
            if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {
                permission = undefined;
            }
            return this.createSync({
                ...args,
                identity: {
                    permission: permission,
                    scope: args.scope
                },
                broadcast: false
            }, options);
        }
        static fromTransaction(chainId, serializedTransaction, options = {}) {
            const id = ChainId.from(chainId);
            serializedTransaction = Bytes.from(serializedTransaction);
            const encoder = new ABIEncoder;
            encoder.writeByte(2);
            encoder.writeArray(Serializer.encode({
                object: id.chainVariant
            }).array);
            encoder.writeByte(2);
            encoder.writeArray(Bytes.from(serializedTransaction).array);
            encoder.writeByte(RequestFlags.broadcast);
            encoder.writeByte(0);
            encoder.writeByte(0);
            return SigningRequest.fromData(encoder.getData(), options);
        }
        static from(uri, options = {}) {
            if (typeof uri !== "string") {
                throw new Error("Invalid request uri");
            }
            const [scheme, path] = uri.split(":");
            if (scheme !== "esr" && scheme !== "web+esr") {
                throw new Error("Invalid scheme");
            }
            const data = decode(path.startsWith("//") ? path.slice(2) : path);
            return SigningRequest.fromData(data, options);
        }
        static fromData(data, options = {}) {
            data = Bytes.from(data);
            const header = data.array[0];
            const version = header & ~(1 << 7);
            if (version !== 2 && version !== 3) {
                throw new Error("Unsupported protocol version");
            }
            let payload = data.droppingFirst(1);
            if ((header & 1 << 7) !== 0) {
                if (!options.zlib) {
                    throw new Error("Compressed URI needs zlib");
                }
                payload = Bytes.from(options.zlib.inflateRaw(payload.array));
            }
            const decoder = new ABIDecoder(payload.array);
            const req = Serializer.decode({
                data: decoder,
                type: this.storageType(version)
            });
            let sig;
            if (decoder.canRead()) {
                sig = Serializer.decode({
                    data: decoder,
                    type: RequestSignature
                });
            }
            return new SigningRequest(version, req, options.zlib, options.abiProvider, sig);
        }
        sign(signatureProvider) {
            const message = this.getSignatureDigest();
            this.signature = RequestSignature.from(signatureProvider.sign(message));
        }
        getSignatureDigest() {
            const prefix = [ this.version, 114, 101, 113, 117, 101, 115, 116 ];
            return Checksum256.hash(Bytes.from(prefix).appending(this.getData()));
        }
        setSignature(signer, signature) {
            this.signature = RequestSignature.from({
                signer: signer,
                signature: signature
            });
        }
        setCallback(url, background) {
            this.data.callback = url;
            this.data.flags.background = background;
        }
        setBroadcast(broadcast) {
            this.data.flags.broadcast = broadcast;
        }
        encode(compress, slashes) {
            const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;
            if (shouldCompress && this.zlib === undefined) {
                throw new Error("Need zlib to compress");
            }
            let header = this.version;
            const data = this.getData();
            const sigData = this.getSignatureData();
            let array = new Uint8Array(data.byteLength + sigData.byteLength);
            array.set(data, 0);
            array.set(sigData, data.byteLength);
            if (shouldCompress) {
                const deflated = this.zlib.deflateRaw(array);
                if (array.byteLength > deflated.byteLength) {
                    header |= 1 << 7;
                    array = deflated;
                }
            }
            const out = new Uint8Array(1 + array.byteLength);
            out[0] = header;
            out.set(array, 1);
            let scheme = "esr:";
            if (slashes !== false) {
                scheme += "//";
            }
            return scheme + encode(out);
        }
        getData() {
            return Serializer.encode({
                object: this.data
            }).array;
        }
        getSignatureData() {
            if (!this.signature) {
                return new Uint8Array(0);
            }
            return Serializer.encode({
                object: this.signature
            }).array;
        }
        getRequiredAbis() {
            return this.getRawActions().filter((action => !isIdentity(action))).map((action => action.account)).filter(((value, index, self) => self.indexOf(value) === index));
        }
        requiresTapos() {
            const tx = this.getRawTransaction();
            return !this.isIdentity() && !hasTapos(tx);
        }
        async fetchAbis(abiProvider) {
            const required = this.getRequiredAbis();
            if (required.length > 0) {
                const provider = abiProvider || this.abiProvider;
                if (!provider) {
                    throw new Error("Missing ABI provider");
                }
                const abis = new Map;
                await Promise.all(required.map((async account => {
                    abis.set(account.toString(), ABI.from(await provider.getAbi(account)));
                })));
                return abis;
            } else {
                return new Map;
            }
        }
        resolveActions(abis, signer) {
            return this.getRawActions().map((rawAction => {
                let abi;
                if (isIdentity(rawAction)) {
                    abi = this.constructor.identityAbi(this.version);
                } else {
                    const rawAbi = abis.get(rawAction.account.toString());
                    if (!rawAbi) {
                        throw new Error(`Missing ABI definition for ${rawAction.account}`);
                    }
                    abi = ABI.from(rawAbi);
                }
                const type = abi.getActionType(rawAction.name);
                if (!type) {
                    throw new Error(`Missing type for action ${rawAction.account}:${rawAction.name} in ABI`);
                }
                let data = rawAction.decodeData(abi);
                let authorization = rawAction.authorization;
                if (signer) {
                    const signerPerm = PermissionLevel.from(signer);
                    const resolve = value => {
                        if (value instanceof Name) {
                            if (value.equals(PlaceholderName)) {
                                return signerPerm.actor;
                            } else if (value.equals(PlaceholderPermission)) {
                                return signerPerm.permission;
                            } else {
                                return value;
                            }
                        } else if (Array.isArray(value)) {
                            return value.map(resolve);
                        } else if (typeof value === "object" && value !== null) {
                            for (const key of Object.keys(value)) {
                                value[key] = resolve(value[key]);
                            }
                            return value;
                        } else {
                            return value;
                        }
                    };
                    data = resolve(data);
                    authorization = authorization.map((auth => {
                        let {actor: actor, permission: permission} = auth;
                        if (actor.equals(PlaceholderName)) {
                            actor = signerPerm.actor;
                        }
                        if (permission.equals(PlaceholderPermission)) {
                            permission = signerPerm.permission;
                        }
                        if (permission.equals(PlaceholderName)) {
                            permission = signerPerm.permission;
                        }
                        return PermissionLevel.from({
                            actor: actor,
                            permission: permission
                        });
                    }));
                }
                return {
                    ...rawAction,
                    authorization: authorization,
                    data: data
                };
            }));
        }
        resolveTransaction(abis, signer, ctx = {}) {
            const tx = this.getRawTransaction();
            if (!this.isIdentity() && !hasTapos(tx)) {
                if (ctx.expiration !== undefined && ctx.ref_block_num !== undefined && ctx.ref_block_prefix !== undefined) {
                    tx.expiration = TimePointSec.from(ctx.expiration);
                    tx.ref_block_num = UInt16.from(ctx.ref_block_num, "truncate");
                    tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);
                } else if (ctx.block_num !== undefined && ctx.ref_block_prefix !== undefined && ctx.timestamp !== undefined) {
                    tx.expiration = expirationTime(ctx.timestamp, ctx.expire_seconds);
                    tx.ref_block_num = UInt16.from(ctx.block_num, "truncate");
                    tx.ref_block_prefix = UInt32.from(ctx.ref_block_prefix);
                } else {
                    throw new Error("Invalid transaction context, need either a reference block or explicit TaPoS values");
                }
            } else if (this.isIdentity() && this.version > 2) {
                tx.expiration = ctx.expiration ? TimePointSec.from(ctx.expiration) : expirationTime(ctx.timestamp, ctx.expire_seconds);
            }
            const actions = this.resolveActions(abis, signer);
            const context_free_actions = tx.context_free_actions;
            return {
                ...tx,
                context_free_actions: context_free_actions,
                actions: actions
            };
        }
        resolve(abis, signer, ctx = {}) {
            const tx = this.resolveTransaction(abis, signer, ctx);
            const actions = tx.actions.map((action => {
                let abi;
                if (isIdentity(action)) {
                    abi = this.constructor.identityAbi(this.version);
                } else {
                    abi = abis.get(action.account.toString());
                }
                if (!abi) {
                    throw new Error(`Missing ABI definition for ${action.account}`);
                }
                const type = abi.getActionType(action.name);
                const data = Serializer.encode({
                    object: action.data,
                    type: type,
                    abi: abi
                });
                return Action.from({
                    ...action,
                    data: data
                });
            }));
            const transaction = Transaction.from({
                ...tx,
                actions: actions
            });
            let chainId;
            if (this.isMultiChain()) {
                if (!ctx.chainId) {
                    throw new Error("Missing chosen chain ID for multi-chain request");
                }
                chainId = ChainId.from(ctx.chainId);
                const ids = this.getChainIds();
                if (ids && !ids.some((id => chainId.equals(id)))) {
                    throw new Error("Trying to resolve for chain ID not defined in request");
                }
            } else {
                chainId = this.getChainId();
            }
            return new ResolvedSigningRequest(this, PermissionLevel.from(signer), transaction, tx, chainId);
        }
        getChainId() {
            return this.data.chain_id.chainId;
        }
        getChainIds() {
            if (!this.isMultiChain()) {
                return null;
            }
            const ids = this.getInfoKey("chain_ids", {
                type: ChainIdVariant,
                array: true
            });
            if (ids) {
                return ids.map((id => id.chainId));
            }
            return null;
        }
        setChainIds(ids) {
            const value = ids.map((id => ChainId.from(id).chainVariant));
            this.setInfoKey("chain_ids", value, {
                type: ChainIdVariant,
                array: true
            });
        }
        isMultiChain() {
            return this.data.chain_id.variantIdx === 0 && this.data.chain_id.value.equals(ChainName.UNKNOWN);
        }
        getRawActions() {
            const req = this.data.req;
            switch (req.variantName) {
              case "action":
                return [ req.value ];

              case "action[]":
                return req.value;

              case "identity":
                {
                    if (this.version === 2) {
                        const id = req.value;
                        let data = "0101000000000000000200000000000000";
                        let authorization = [ PlaceholderAuth ];
                        if (id.permission) {
                            data = Serializer.encode({
                                object: id
                            });
                            authorization = [ id.permission ];
                        }
                        return [ Action.from({
                            account: "",
                            name: "identity",
                            authorization: authorization,
                            data: data
                        }) ];
                    } else {
                        let {scope: scope, permission: permission} = req.value;
                        if (!permission) {
                            permission = PlaceholderAuth;
                        }
                        const data = Serializer.encode({
                            object: {
                                scope: scope,
                                permission: permission
                            },
                            type: IdentityV3
                        });
                        return [ Action.from({
                            account: "",
                            name: "identity",
                            authorization: [ permission ],
                            data: data
                        }) ];
                    }
                }

              case "transaction":
                return req.value.actions;

              default:
                throw new Error("Invalid signing request data");
            }
        }
        getRawTransaction() {
            const req = this.data.req;
            switch (req.variantName) {
              case "transaction":
                return Transaction.from({
                    ...req.value
                });

              case "action":
              case "action[]":
              case "identity":
                return Transaction.from({
                    actions: this.getRawActions(),
                    context_free_actions: [],
                    transaction_extensions: [],
                    expiration: "1970-01-01T00:00:00.000",
                    ref_block_num: 0,
                    ref_block_prefix: 0,
                    max_cpu_usage_ms: 0,
                    max_net_usage_words: 0,
                    delay_sec: 0
                });

              default:
                throw new Error("Invalid signing request data");
            }
        }
        isIdentity() {
            return this.data.req.variantName === "identity";
        }
        shouldBroadcast() {
            if (this.isIdentity()) {
                return false;
            }
            return this.data.flags.broadcast;
        }
        getIdentity() {
            if (!this.isIdentity()) {
                return null;
            }
            const id = this.data.req.value;
            if (id.permission && !id.permission.actor.equals(PlaceholderName)) {
                return id.permission.actor;
            }
            return null;
        }
        getIdentityPermission() {
            if (!this.isIdentity()) {
                return null;
            }
            const id = this.data.req.value;
            if (id.permission && !id.permission.permission.equals(PlaceholderPermission)) {
                return id.permission.permission;
            }
            return null;
        }
        getIdentityScope() {
            if (!this.isIdentity() || this.version <= 2) {
                return null;
            }
            const id = this.data.req.value;
            return id.scope;
        }
        getRawInfo() {
            const rv = {};
            for (const {key: key, value: value} of this.data.info) {
                rv[key] = value;
            }
            return rv;
        }
        getRawInfoKey(key) {
            const pair = this.data.info.find((pair => pair.key === key));
            if (pair) {
                return pair.value;
            }
        }
        setRawInfoKey(key, value) {
            let pair = this.data.info.find((pair => pair.key === key));
            if (!pair) {
                pair = InfoPair.from({
                    key: key,
                    value: value
                });
                this.data.info.push(pair);
            } else {
                pair.value = Bytes.from(value);
            }
        }
        setInfoKey(key, object, type) {
            let data;
            if (typeof object === "string" && !type) {
                data = Bytes.from(object, "utf8");
            } else {
                data = Serializer.encode({
                    object: object,
                    type: type
                });
            }
            this.setRawInfoKey(key, data);
        }
        getInfoKey(key, type) {
            const data = this.getRawInfoKey(key);
            if (data) {
                if (type) {
                    return Serializer.decode({
                        data: data,
                        type: type
                    });
                } else {
                    return data.utf8String;
                }
            }
        }
        clone() {
            let signature;
            if (this.signature) {
                signature = RequestSignature.from(JSON.parse(JSON.stringify(this.signature)));
            }
            const RequestData = this.constructor.storageType(this.version);
            const data = RequestData.from(JSON.parse(JSON.stringify(this.data)));
            return new SigningRequest(this.version, data, this.zlib, this.abiProvider, signature);
        }
        toString() {
            return this.encode();
        }
        toJSON() {
            return this.encode();
        }
    }
    class ResolvedSigningRequest {
        constructor(request, signer, transaction, resolvedTransaction, chainId) {
            this.request = request;
            this.signer = signer;
            this.transaction = transaction;
            this.resolvedTransaction = resolvedTransaction;
            this.chainId = chainId;
        }
        static async fromPayload(payload, options = {}) {
            const request = SigningRequest.from(payload.req, options);
            const abis = await request.fetchAbis();
            return request.resolve(abis, {
                actor: payload.sa,
                permission: payload.sp
            }, {
                ref_block_num: payload.rbn,
                ref_block_prefix: payload.rid,
                expiration: payload.ex,
                chainId: payload.cid || request.getChainId()
            });
        }
        get serializedTransaction() {
            return Serializer.encode({
                object: this.transaction
            }).array;
        }
        get signingDigest() {
            return this.transaction.signingDigest(this.chainId);
        }
        get signingData() {
            return this.transaction.signingData(this.chainId);
        }
        getCallback(signatures, blockNum) {
            const {callback: callback, flags: flags} = this.request.data;
            if (!callback || callback.length === 0) {
                return null;
            }
            if (!signatures || signatures.length === 0) {
                throw new Error("Must have at least one signature to resolve callback");
            }
            const sigs = signatures.map((sig => Signature.from(sig)));
            const payload = {
                sig: String(sigs[0]),
                tx: String(this.transaction.id),
                rbn: String(this.transaction.ref_block_num),
                rid: String(this.transaction.ref_block_prefix),
                ex: String(this.transaction.expiration),
                req: this.request.encode(),
                sa: String(this.signer.actor),
                sp: String(this.signer.permission),
                cid: String(this.chainId)
            };
            for (const [n, sig] of sigs.slice(1).entries()) {
                payload[`sig${n}`] = String(sig);
            }
            if (blockNum) {
                payload.bn = String(UInt32.from(blockNum));
            }
            const url = callback.replace(/({{([a-z0-9]+)}})/g, ((_1, _2, m) => payload[m] || ""));
            return {
                background: flags.background,
                payload: payload,
                url: url
            };
        }
        getIdentityProof(signature) {
            if (!this.request.isIdentity()) {
                throw new Error("Not a identity request");
            }
            return IdentityProof.from({
                chainId: this.chainId,
                scope: this.request.getIdentityScope(),
                expiration: this.transaction.expiration,
                signer: this.signer,
                signature: signature
            });
        }
    }
    function encodeAction(action, abis) {
        if (Bytes.isBytes(action.data) || action.data.constructor.abiName !== undefined) {
            return Action.from(action);
        }
        const abi = abis[String(Name.from(action.account))];
        if (!abi) {
            throw new Error(`Missing ABI for ${action.account}`);
        }
        return Action.from(action, abi);
    }
    function isIdentity(action) {
        const account = Name.from(action.account);
        const name = Name.from(action.name);
        return account.rawValue.equals(0) && name.equals("identity");
    }
    function hasTapos(tx) {
        return !(tx.expiration.equals(0) && tx.ref_block_num.equals(0) && tx.ref_block_prefix.equals(0));
    }
    function expirationTime(timestamp, expireSeconds = 60) {
        const ts = TimePointSec.from(timestamp || new Date);
        const exp = UInt32.from(expireSeconds);
        return TimePointSec.fromInteger(ts.value.adding(exp));
    }
    /**
     * @wharfkit/session v0.1.1
     * https://github.com/wharfkit/session
     *
     * @license
     * Copyright (c) 2021 FFF00 Agents AB & Greymass Inc. All Rights Reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification,
     * are permitted provided that the following conditions are met:
     * 
     *  1. Redistribution of source code must retain the above copyright notice, this
     *     list of conditions and the following disclaimer.
     * 
     *  2. Redistribution in binary form must reproduce the above copyright notice,
     *     this list of conditions and the following disclaimer in the documentation
     *     and/or other materials provided with the distribution.
     * 
     *  3. Neither the name of the copyright holder nor the names of its contributors
     *     may be used to endorse or promote products derived from this software without
     *     specific prior written permission.
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
     * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     * OF THE POSSIBILITY OF SUCH DAMAGE.
     * 
     * YOU ACKNOWLEDGE THAT THIS SOFTWARE IS NOT DESIGNED, LICENSED OR INTENDED FOR USE
     * IN THE DESIGN, CONSTRUCTION, OPERATION OR MAINTENANCE OF ANY MILITARY FACILITY.
     */    let ChainDefinition = class ChainDefinition extends Struct {};
    __decorate([ Struct.field("checksum256") ], ChainDefinition.prototype, "id", void 0);
    __decorate([ Struct.field("string") ], ChainDefinition.prototype, "url", void 0);
    ChainDefinition = __decorate([ Struct.type("chain_definition") ], ChainDefinition);
    function getFetch(options) {
        if (options && options.fetch) {
            return options.fetch;
        }
        if (typeof window !== "undefined" && window.fetch) {
            return window.fetch.bind(window);
        }
        if (typeof global !== "undefined" && global.fetch) {
            return global.fetch.bind(global);
        }
        throw new Error("Missing fetch");
    }
    var TransactHookTypes;
    (function(TransactHookTypes) {
        TransactHookTypes["beforeSign"] = "beforeSign";
        TransactHookTypes["afterSign"] = "afterSign";
        TransactHookTypes["beforeBroadcast"] = "beforeBroadcast";
        TransactHookTypes["afterBroadcast"] = "afterBroadcast";
    })(TransactHookTypes || (TransactHookTypes = {}));
    class TransactContext {
        constructor(options) {
            this.hooks = {
                afterBroadcast: [],
                afterSign: [],
                beforeBroadcast: [],
                beforeSign: []
            };
            this.client = options.client;
            this.fetch = options.fetch;
            this.session = options.session;
            this.transactPluginsOptions = options.transactPluginsOptions || {};
            options.transactPlugins?.forEach((plugin => {
                plugin.register(this);
            }));
        }
        addHook(t, hook) {
            this.hooks[t].push(hook);
        }
    }
    class AbstractTransactPlugin {}
    class BaseTransactPlugin extends AbstractTransactPlugin {
        register() {}
    }
    class Session {
        constructor(options) {
            this.allowModify = true;
            this.broadcast = true;
            this.transactPluginsOptions = {};
            this.chain = ChainDefinition.from(options.chain);
            if (options.allowModify !== undefined) {
                this.allowModify = options.allowModify;
            }
            if (options.broadcast !== undefined) {
                this.broadcast = options.broadcast;
            }
            if (options.fetch) {
                this.fetch = options.fetch;
            } else {
                this.fetch = getFetch(options);
            }
            if (options.transactPlugins) {
                this.transactPlugins = options.transactPlugins;
            } else {
                this.transactPlugins = [ new BaseTransactPlugin ];
            }
            if (options.transactPluginsOptions) {
                this.transactPluginsOptions = options.transactPluginsOptions;
            }
            this.permissionLevel = PermissionLevel.from(options.permissionLevel);
            this.wallet = options.walletPlugin;
        }
        get account() {
            return this.permissionLevel.actor;
        }
        get permission() {
            return this.permissionLevel.permission;
        }
        get client() {
            return new APIClient({
                provider: new FetchProvider(this.chain.url, {
                    fetch: this.fetch
                })
            });
        }
        upgradeTransaction(args) {
            const anyArgs = args;
            if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {
                return args = {
                    transaction: {
                        expiration: "1970-01-01T00:00:00",
                        ref_block_num: 0,
                        ref_block_prefix: 0,
                        max_net_usage_words: 0,
                        max_cpu_usage_ms: 0,
                        delay_sec: 0,
                        ...anyArgs
                    }
                };
            }
            return args;
        }
        async createRequest(args) {
            const abiProvider = {
                getAbi: async account => {
                    const response = await this.client.v1.chain.get_abi(account);
                    if (!response.abi) {
                        throw new Error("could not load abi");
                    }
                    return response.abi;
                }
            };
            const options = {
                abiProvider: abiProvider,
                zlib: pako
            };
            if (args.request && args.request instanceof SigningRequest) {
                return SigningRequest.from(String(args.request), options);
            } else if (args.request) {
                return SigningRequest.from(args.request, options);
            } else {
                args = this.upgradeTransaction(args);
                const request = await SigningRequest.create({
                    ...args,
                    chainId: this.chain.id
                }, options);
                return request;
            }
        }
        async transact(args, options) {
            const context = new TransactContext({
                client: this.client,
                fetch: this.fetch,
                transactPlugins: options?.transactPlugins || this.transactPlugins,
                transactPluginsOptions: options?.transactPluginsOptions || this.transactPluginsOptions,
                session: this.permissionLevel
            });
            const request = await this.createRequest(args);
            const result = {
                chain: this.chain,
                request: request,
                resolved: undefined,
                signatures: [],
                signer: this.permissionLevel,
                transaction: undefined
            };
            const allowModify = options && typeof options.allowModify !== "undefined" ? options.allowModify : this.allowModify;
            const willBroadcast = options && typeof options.broadcast !== "undefined" ? options.broadcast : this.broadcast;
            for (const hook of context.hooks.beforeSign) {
                const response = await hook(result.request.clone(), context);
                if (allowModify) {
                    result.request = response.request.clone();
                }
                if (response.signatures) {
                    result.signatures = [ ...result.signatures, ...response.signatures ];
                }
            }
            const info = await context.client.v1.chain.get_info();
            const expireSeconds = 120;
            const header = info.getTransactionHeader(expireSeconds);
            const abis = await result.request.fetchAbis();
            result.resolved = await result.request.resolve(abis, this.permissionLevel, header);
            result.transaction = result.resolved.resolvedTransaction;
            const signature = await this.wallet.sign(this.chain, result.resolved);
            result.signatures.push(signature);
            for (const hook of context.hooks.afterSign) await hook(result.request.clone(), context);
            if (willBroadcast) {
                for (const hook of context.hooks.beforeBroadcast) await hook(result.request.clone(), context);
                const signed = SignedTransaction.from({
                    ...result.resolved.transaction,
                    signatures: result.signatures
                });
                result.response = await context.client.v1.chain.send_transaction(signed);
                for (const hook of context.hooks.afterBroadcast) await hook(result.request.clone(), context);
            }
            return result;
        }
    }
    var LoginHookTypes;
    (function(LoginHookTypes) {
        LoginHookTypes["beforeLogin"] = "beforeLogin";
        LoginHookTypes["afterLogin"] = "afterLogin";
    })(LoginHookTypes || (LoginHookTypes = {}));
    class AbstractLoginPlugin {}
    class BaseLoginPlugin extends AbstractLoginPlugin {
        register() {}
    }
    class SessionKit {
        constructor(options) {
            this.transactPluginsOptions = {};
            this.appName = Name.from(options.appName);
            this.chains = options.chains.map((chain => ChainDefinition.from(chain)));
            if (options.fetch) {
                this.fetch = options.fetch;
            }
            if (options.loginPlugins) {
                this.loginPlugins = options.loginPlugins;
            } else {
                this.loginPlugins = [ new BaseLoginPlugin ];
            }
            if (options.transactPlugins) {
                this.transactPlugins = options.transactPlugins;
            } else {
                this.transactPlugins = [ new BaseTransactPlugin ];
            }
            if (options.transactPluginsOptions) {
                this.transactPluginsOptions = options.transactPluginsOptions;
            }
            this.walletPlugins = options.walletPlugins;
        }
        getChain(id) {
            const chainId = Checksum256.from(id);
            const chain = this.chains.find((c => c.id.equals(chainId)));
            if (!chain) {
                throw new Error(`No ChainDefinition found for ${chainId}`);
            }
            return chain;
        }
        async login(options) {
            const chain = this.chains[0];
            const context = {
                chain: chain,
                fetch: this.fetch,
                permissionLevel: "eosio@active",
                transactPlugins: options?.transactPlugins || this.transactPlugins,
                transactPluginsOptions: options?.transactPluginsOptions || this.transactPluginsOptions,
                walletPlugin: this.walletPlugins[0]
            };
            const walletOptions = {
                appName: this.appName,
                chains: this.chains,
                context: context
            };
            if (options?.walletPlugin) {
                context.walletPlugin = options.walletPlugin;
            }
            if (options?.chain) {
                context.chain = this.getChain(options.chain);
            }
            if (options?.permissionLevel) {
                context.permissionLevel = PermissionLevel.from(options.permissionLevel);
            }
            const response = await context.walletPlugin.login(walletOptions);
            context.chain = response.chain;
            context.permissionLevel = response.permissionLevel;
            return new Session(context);
        }
    }
    class WalletPluginPrivateKey {
        constructor(options) {
            this.privateKey = PrivateKey.from(options.privateKey);
        }
        login(options) {
            return {
                chain: ChainDefinition.from({
                    id: Checksum256.from(options.context.chain.id),
                    url: options.context.chain.url
                }),
                permissionLevel: PermissionLevel.from(options.context.permissionLevel)
            };
        }
        sign(chain, resolved) {
            const transaction = Transaction.from(resolved.transaction);
            const digest = transaction.signingDigest(Checksum256.from(chain.id));
            return this.privateKey.signDigest(digest);
        }
    }
    function makeContext() {
        return new TransactContext({
            client: new APIClient({
                provider: new FetchProvider(mockUrl, {
                    fetch: mockFetch
                })
            }),
            fetch: mockFetch,
            session: PermissionLevel.from("wharfkit1125@test")
        });
    }
    function mockTransactHook(request) {
        return __awaiter(this, void 0, void 0, (function*() {
            return {
                request: request,
                signatures: []
            };
        }));
    }
    class MockTransactPlugin extends AbstractTransactPlugin {
        register(context) {
            context.addHook(TransactHookTypes.beforeSign, mockTransactHook);
            context.addHook(TransactHookTypes.afterSign, mockTransactHook);
            context.addHook(TransactHookTypes.beforeBroadcast, mockTransactHook);
            context.addHook(TransactHookTypes.afterBroadcast, mockTransactHook);
        }
    }
    function mockTransactResourceProviderPresignHook(request, context) {
        return __awaiter(this, void 0, void 0, (function*() {
            const options = context.transactPluginsOptions;
            if (options.disableExamplePlugin) {
                return {
                    request: request,
                    signatures: []
                };
            }
            const cloned = request.clone();
            class noop extends Struct {}
            noop.abiName = "noop";
            noop.abiFields = [];
            const newAction = Action.from({
                account: "greymassnoop",
                name: "noop",
                authorization: [ {
                    actor: "greymassfuel",
                    permission: "cosign"
                } ],
                data: noop.from({})
            });
            if (cloned.data.req.value instanceof Action) {
                cloned.data.req.value = [ newAction, cloned.data.req.value ];
                cloned.data.req.variantIdx = 1;
            } else if (cloned.data.req.value instanceof Array) {
                cloned.data.req.value.unshift(newAction);
            } else if (cloned.data.req.value instanceof Transaction) {
                cloned.data.req.value.actions.unshift(newAction);
            } else {
                throw new Error("Unrecognized data type in request.");
            }
            return {
                request: cloned,
                signatures: []
            };
        }));
    }
    class MockTransactResourceProviderPlugin$1 extends AbstractTransactPlugin {
        register(context) {
            context.addHook(TransactHookTypes.beforeSign, mockTransactResourceProviderPresignHook);
        }
    }
    let Transfer$1 = class Transfer extends Struct {};
    __decorate([ Struct.field("name") ], Transfer$1.prototype, "from", void 0);
    __decorate([ Struct.field("name") ], Transfer$1.prototype, "to", void 0);
    __decorate([ Struct.field("asset") ], Transfer$1.prototype, "quantity", void 0);
    __decorate([ Struct.field("string") ], Transfer$1.prototype, "memo", void 0);
    Transfer$1 = __decorate([ Struct.type("transfer") ], Transfer$1);
    function makeMockAction(memo) {
        const transfer = Transfer$1.from({
            from: mockAccountName,
            to: "teamgreymass",
            quantity: "0.1337 EOS",
            memo: memo || "wharfkit is the best <3"
        });
        const action = Action.from({
            authorization: [ {
                actor: mockAccountName,
                permission: mockPermissionName
            } ],
            account: "eosio.token",
            name: "transfer",
            data: transfer
        });
        return action;
    }
    function makeMockActions(memo) {
        return [ makeMockAction(memo) ];
    }
    function makeMockTransaction(info, memo) {
        const header = info.getTransactionHeader(90);
        const actions = makeMockActions(memo);
        const transaction = Transaction.from(Object.assign(Object.assign({}, header), {
            actions: actions
        }));
        return transaction;
    }
    const client$1 = makeClient();
    const context = makeContext();
    const beforeSignHooks = () => {
        suite("beforeSign", (function() {
            test("prepend action on `action`", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const request = yield SigningRequest.create({
                        action: makeMockAction()
                    }, {
                        zlib: pako
                    });
                    const response = yield mockTransactResourceProviderPresignHook(request, context);
                    chai.assert.notDeepEqual(request.data.req.value, response.request.data.req.value);
                    const {value: value} = response.request.data.req;
                    if (value instanceof Array) {
                        const [noop, transfer] = value;
                        chai.assert.equal(value.length, 2);
                        chai.assert.isTrue(Name.from("greymassnoop").equals(noop.account));
                        chai.assert.isTrue(Name.from("greymassfuel").equals(noop.authorization[0].actor));
                        chai.assert.isTrue(Name.from("eosio.token").equals(transfer.account));
                        chai.assert.isTrue(Name.from(mockAccountName).equals(transfer.authorization[0].actor));
                    } else {
                        chai.assert.fail("Expected modified request to be an array.");
                    }
                }));
            }));
            test("prepend action on `actions`", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const request = yield SigningRequest.create({
                        actions: [ makeMockAction(), makeMockAction() ],
                        chainId: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d"
                    }, {
                        zlib: pako
                    });
                    const response = yield mockTransactResourceProviderPresignHook(request, context);
                    chai.assert.notDeepEqual(request.data.req.value, response.request.data.req.value);
                    const {value: value} = response.request.data.req;
                    if (value instanceof Array) {
                        const [noop, transfer] = value;
                        chai.assert.equal(value.length, 3);
                        chai.assert.isTrue(Name.from("greymassnoop").equals(noop.account));
                        chai.assert.isTrue(Name.from("greymassfuel").equals(noop.authorization[0].actor));
                        chai.assert.isTrue(Name.from("eosio.token").equals(transfer.account));
                        chai.assert.isTrue(Name.from(mockAccountName).equals(transfer.authorization[0].actor));
                    }
                }));
            }));
            test("prepend action on `transaction`", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const request = yield SigningRequest.create({
                        transaction: makeMockTransaction(yield client$1.v1.chain.get_info()),
                        chainId: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d"
                    }, {
                        zlib: pako
                    });
                    const response = yield mockTransactResourceProviderPresignHook(request, context);
                    chai.assert.notDeepEqual(request.data.req.value, response.request.data.req.value);
                    const {value: value} = response.request.data.req;
                    if (value instanceof Transaction) {
                        const {actions: actions} = value;
                        const [noop, transfer] = actions;
                        chai.assert.instanceOf(actions, Array);
                        chai.assert.equal(actions.length, 2);
                        chai.assert.isTrue(Name.from("greymassnoop").equals(noop.account));
                        chai.assert.isTrue(Name.from("greymassfuel").equals(noop.authorization[0].actor));
                        chai.assert.isTrue(Name.from("eosio.token").equals(transfer.account));
                        chai.assert.isTrue(Name.from(mockAccountName).equals(transfer.authorization[0].actor));
                    }
                }));
            }));
        }));
    };
    makeClient();
    makeContext();
    const afterSignHooks = () => {
        suite("afterSign", (function() {
            test("TODO", (function() {
                return __awaiter(this, void 0, void 0, (function*() {}));
            }));
        }));
    };
    const beforeBroadcastHooks = () => {
        suite("beforeBroadcast", (function() {
            test("TODO", (function() {
                return __awaiter(this, void 0, void 0, (function*() {}));
            }));
        }));
    };
    const afterBroadcastHooks = () => {
        suite("afterBroadcast", (function() {
            test("TODO", (function() {
                return __awaiter(this, void 0, void 0, (function*() {}));
            }));
        }));
    };
    const beforeLoginHooks = () => {
        suite("beforeLogin", (function() {
            test("TODO", (function() {
                return __awaiter(this, void 0, void 0, (function*() {}));
            }));
        }));
    };
    const afterLoginHooks = () => {
        suite("afterLogin", (function() {
            test("TODO", (function() {
                return __awaiter(this, void 0, void 0, (function*() {}));
            }));
        }));
    };
    suite("hooks", (function() {
        suite("transactHooks", (function() {
            beforeSignHooks();
            afterSignHooks();
            beforeBroadcastHooks();
            afterBroadcastHooks();
        }));
        suite("loginHooks", (function() {
            beforeLoginHooks();
            afterLoginHooks();
        }));
    }));
    const privateKey = PrivateKey.from(mockPrivateKey);
    function makeWallet() {
        return new WalletPluginPrivateKey({
            privateKey: privateKey
        });
    }
    const defaultSessionKitOptions = {
        appName: "demo.app",
        chains: [ {
            id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
            url: "https://jungle4.greymass.com"
        } ],
        fetch: mockFetch,
        walletPlugins: [ makeWallet() ]
    };
    suite("kit", (function() {
        suite("construct", (function() {
            test("instance", (function() {
                const sessionKit = new SessionKit(defaultSessionKitOptions);
                chai.assert.instanceOf(sessionKit, SessionKit);
            }));
            suite("options", (function() {
                suite("transactPlugins", (function() {
                    test("default", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const sessionKit = new SessionKit(defaultSessionKitOptions);
                            chai.assert.lengthOf(sessionKit.transactPlugins, 1);
                            chai.assert.instanceOf(sessionKit.transactPlugins[0], BaseTransactPlugin);
                        }));
                    }));
                    test("override", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const sessionKit = new SessionKit(Object.assign(Object.assign({}, defaultSessionKitOptions), {
                                transactPlugins: [ new MockTransactPlugin ]
                            }));
                            chai.assert.lengthOf(sessionKit.transactPlugins, 1);
                            chai.assert.instanceOf(sessionKit.transactPlugins[0], MockTransactPlugin);
                        }));
                    }));
                }));
            }));
        }));
        suite("login", (function() {
            test("default", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const sessionKit = new SessionKit(defaultSessionKitOptions);
                    const session = yield sessionKit.login();
                    chai.assert.instanceOf(session, Session);
                }));
            }));
            test("specify chain id", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const sessionKit = new SessionKit(defaultSessionKitOptions);
                    const session = yield sessionKit.login({
                        chain: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d"
                    });
                    chai.assert.instanceOf(session, Session);
                }));
            }));
            test("specify permission (typed)", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const sessionKit = new SessionKit(defaultSessionKitOptions);
                    const session = yield sessionKit.login({
                        permissionLevel: PermissionLevel.from(mockPermissionLevel)
                    });
                    chai.assert.instanceOf(session, Session);
                }));
            }));
            test("specify permission (untyped)", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const sessionKit = new SessionKit(defaultSessionKitOptions);
                    const session = yield sessionKit.login({
                        permissionLevel: mockPermissionLevel
                    });
                    chai.assert.instanceOf(session, Session);
                }));
            }));
            test("specify wallet plugin", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const sessionKit = new SessionKit(defaultSessionKitOptions);
                    const session = yield sessionKit.login({
                        walletPlugin: makeWallet()
                    });
                    chai.assert.instanceOf(session, Session);
                }));
            }));
        }));
    }));
    const wallet$2 = makeWallet();
    class MockTransactResourceProviderPlugin extends AbstractTransactPlugin {
        constructor(options) {
            super();
            this.allowFees = false;
            if (typeof options.allowFees !== "undefined") {
                this.allowFees = options.allowFees;
            }
            if (options.url) {
                this.url = options.url;
            }
        }
        register(context) {
            context.addHook(TransactHookTypes.beforeSign, ((request, context) => this.request(request, context)));
        }
        request(request, context) {
            return __awaiter(this, void 0, void 0, (function*() {
                this.validateRequest(request, context);
                const response = yield context.fetch(this.url, {
                    method: "POST",
                    body: JSON.stringify({
                        ref: "unittest",
                        request: request,
                        signer: context.session
                    })
                });
                const json = yield response.json();
                if (response.status === 400) {
                    return {
                        request: request
                    };
                }
                yield this.validateResponseData(json);
                const modified = yield this.createRequest(json, context);
                return {
                    request: modified,
                    signatures: json.data.signatures.map((sig => Signature.from(sig)))
                };
            }));
        }
        createRequest(response, context) {
            return __awaiter(this, void 0, void 0, (function*() {
                const abiProvider = {
                    getAbi: account => __awaiter(this, void 0, void 0, (function*() {
                        const response = yield context.client.v1.chain.get_abi(account);
                        if (!response.abi) {
                            throw new Error("could not load abi");
                        }
                        return response.abi;
                    }))
                };
                const request = yield SigningRequest.create({
                    transaction: response.data.request[1]
                }, {
                    abiProvider: abiProvider,
                    zlib: pako
                });
                if (response.code === 402 && response.data.fee) {
                    request.setInfoKey("txfee", Asset.from(response.data.fee));
                }
                if (response.data.costs) {
                    request.setInfoKey("txfeecpu", response.data.costs.cpu);
                    request.setInfoKey("txfeenet", response.data.costs.net);
                    request.setInfoKey("txfeeram", response.data.costs.ram);
                }
                return request;
            }));
        }
        validateRequest(request, context) {
            const firstAction = request.getRawActions()[0];
            const firstAuthorizer = firstAction.authorization[0];
            if (!firstAuthorizer.actor.equals(context.session.actor)) {
                throw new Error("The first authorizer of the transaction does not match this session.");
            }
        }
        validateResponseData(response) {
            return __awaiter(this, void 0, void 0, (function*() {
                if (!response) {
                    throw new Error("Resource provider did not respond to the request.");
                }
                if (response.code === 402 && !response.data.fee) {
                    throw new Error("Resource provider returned a response indicating required payment, but provided no fee amount.");
                }
                if (!response.data.signatures || !response.data.signatures[0]) {
                    throw new Error("Resource provider did not return a signature.");
                }
            }));
        }
    }
    const mockResourceProviderPlugin = new MockTransactResourceProviderPlugin({
        url: "https://jungle4.greymass.com/v1/resource_provider/request_transaction"
    });
    const mockSessionOptions$2 = {
        chain: {
            id: mockChainId,
            url: mockUrl
        },
        fetch: mockFetch,
        permissionLevel: "wharfkit1131@test",
        transactPlugins: [ mockResourceProviderPlugin ],
        walletPlugin: wallet$2
    };
    let Transfer = class Transfer extends Struct {};
    __decorate([ Struct.field(Name) ], Transfer.prototype, "from", void 0);
    __decorate([ Struct.field(Name) ], Transfer.prototype, "to", void 0);
    __decorate([ Struct.field(Asset) ], Transfer.prototype, "quantity", void 0);
    __decorate([ Struct.field("string") ], Transfer.prototype, "memo", void 0);
    Transfer = __decorate([ Struct.type("transfer") ], Transfer);
    const resourceProviderPlugin = () => {
        suite("resource provider", (function() {
            test("provides free transaction", (function() {
                var _a, _b, _c, _d, _e;
                return __awaiter(this, void 0, void 0, (function*() {
                    this.slow(1e4);
                    const session = new Session(mockSessionOptions$2);
                    const action = {
                        authorization: [ {
                            actor: "wharfkit1131",
                            permission: "test"
                        } ],
                        account: "eosio.token",
                        name: "transfer",
                        data: {
                            from: "wharfkit1131",
                            to: "wharfkittest",
                            quantity: "0.0001 EOS",
                            memo: "wharfkit is the best <3"
                        }
                    };
                    const response = yield session.transact({
                        action: action
                    });
                    if (response.resolved && response.transaction) {
                        chai.assert.lengthOf((_a = response.transaction) === null || _a === void 0 ? void 0 : _a.actions, 2);
                        chai.assert.equal(String((_b = response.transaction) === null || _b === void 0 ? void 0 : _b.actions[0].account), "greymassnoop");
                        chai.assert.equal(String((_c = response.transaction) === null || _c === void 0 ? void 0 : _c.actions[0].authorization[0].actor), "greymassfuel");
                        chai.assert.equal(String((_d = response.transaction) === null || _d === void 0 ? void 0 : _d.actions[0].authorization[0].permission), "cosign");
                        chai.assert.isTrue(Action.from(Object.assign(Object.assign({}, action), {
                            data: Transfer.from(action.data)
                        })).data.equals((_e = response.resolved) === null || _e === void 0 ? void 0 : _e.transaction.actions[1].data));
                    } else {
                        chai.assert.fail("No transaction was returned from transact call.");
                    }
                }));
            }));
        }));
    };
    const defaultWalletOptions = {
        privateKey: privateKey
    };
    const privateKeyWallet = () => {
        suite("privatekey", (function() {
            test("construct", (function() {
                const wallet = new WalletPluginPrivateKey(defaultWalletOptions);
                chai.assert.instanceOf(wallet, WalletPluginPrivateKey);
            }));
            test("throws error with invalid privatekey", (function() {
                chai.assert.throws((() => {
                    new WalletPluginPrivateKey({
                        privateKey: "foo"
                    });
                }), Error);
            }));
        }));
    };
    suite("plugins", (function() {
        suite("transact", (function() {
            resourceProviderPlugin();
        }));
        suite("wallet", (function() {
            privateKeyWallet();
        }));
    }));
    const sessionOptions = {
        chain: {
            id: mockChainId,
            url: mockUrl
        },
        permissionLevel: mockPermissionLevel,
        walletPlugin: new WalletPluginPrivateKey({
            privateKey: mockPrivateKey
        }),
        fetch: mockFetch
    };
    const nodejsUsage = () => {
        suite("nodejs", (function() {
            test("session", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    this.slow(1e4);
                    const session = new Session(sessionOptions);
                    const response = yield session.transact({
                        action: {
                            authorization: [ {
                                actor: mockAccountName,
                                permission: mockPermissionName
                            } ],
                            account: "eosio.token",
                            name: "transfer",
                            data: {
                                from: mockAccountName,
                                to: "teamgreymass",
                                quantity: "0.1337 EOS",
                                memo: "wharfkit is the best <3"
                            }
                        }
                    });
                    chai.assert.instanceOf(response.signatures[0], Signature);
                }));
            }));
        }));
    };
    const wallet$1 = makeWallet();
    const action = makeMockAction();
    const mockSessionOptions$1 = {
        broadcast: false,
        chain: ChainDefinition.from({
            id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
            url: "https://jungle4.greymass.com"
        }),
        fetch: mockFetch,
        permissionLevel: PermissionLevel.from(mockPermissionLevel),
        walletPlugin: wallet$1
    };
    const mockTransactOptions = {
        transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
    };
    suite("session", (function() {
        let session;
        setup((function() {
            session = new Session(mockSessionOptions$1);
        }));
        nodejsUsage();
        suite("construct", (function() {
            test("instance", (function() {
                chai.assert.instanceOf(session, Session);
            }));
            suite("options", (function() {
                suite("allowModify", (function() {
                    test("default: true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const result = yield session.transact({
                                action: action
                            }, mockTransactOptions);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session(Object.assign(Object.assign({}, mockSessionOptions$1), {
                                allowModify: true
                            }));
                            const result = yield testSession.transact({
                                action: action
                            }, mockTransactOptions);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("false", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session(Object.assign(Object.assign({}, mockSessionOptions$1), {
                                allowModify: false
                            }));
                            const result = yield testSession.transact({
                                action: action
                            }, mockTransactOptions);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 1);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                }));
                suite("broadcast", (function() {
                    test("default: true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session({
                                chain: ChainDefinition.from({
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                }),
                                fetch: mockFetch,
                                permissionLevel: PermissionLevel.from(mockPermissionLevel),
                                walletPlugin: wallet$1
                            });
                            const result = yield testSession.transact({
                                action: action
                            });
                            chai.assert.isDefined(result.response);
                        }));
                    }));
                    test("true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session(Object.assign(Object.assign({}, mockSessionOptions$1), {
                                broadcast: true
                            }));
                            const result = yield testSession.transact({
                                action: action
                            }, {
                                broadcast: true
                            });
                            chai.assert.isDefined(result.response);
                        }));
                    }));
                    test("false", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session(Object.assign(Object.assign({}, mockSessionOptions$1), {
                                broadcast: false
                            }));
                            const result = yield testSession.transact({
                                action: action
                            }, {
                                broadcast: false
                            });
                            chai.assert.isUndefined(result.response);
                        }));
                    }));
                }));
                suite("passed as", (function() {
                    test("typed values", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session({
                                chain: ChainDefinition.from({
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                }),
                                fetch: mockFetch,
                                permissionLevel: PermissionLevel.from("account@permission"),
                                walletPlugin: wallet$1
                            });
                            chai.assert.instanceOf(testSession, Session);
                        }));
                    }));
                    test("untyped values", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const testSession = new Session({
                                chain: {
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                },
                                fetch: mockFetch,
                                permissionLevel: "account@permission",
                                walletPlugin: wallet$1
                            });
                            chai.assert.instanceOf(testSession, Session);
                        }));
                    }));
                }));
                suite("transactPlugins", (function() {
                    test("default", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const sessionKit = new SessionKit({
                                appName: "demo.app",
                                chains: [ {
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                } ],
                                fetch: mockFetch,
                                walletPlugins: [ makeWallet() ]
                            });
                            const session = yield sessionKit.login();
                            chai.assert.instanceOf(session, Session);
                            chai.assert.lengthOf(session.transactPlugins, 1);
                            chai.assert.instanceOf(session.transactPlugins[0], BaseTransactPlugin);
                        }));
                    }));
                    test("inherit", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const sessionKit = new SessionKit({
                                appName: "demo.app",
                                chains: [ {
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                } ],
                                fetch: mockFetch,
                                transactPlugins: [ new MockTransactPlugin ],
                                walletPlugins: [ makeWallet() ]
                            });
                            const session = yield sessionKit.login();
                            chai.assert.instanceOf(session, Session);
                            chai.assert.lengthOf(session.transactPlugins, 1);
                            chai.assert.instanceOf(session.transactPlugins[0], MockTransactPlugin);
                        }));
                    }));
                    test("override", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const sessionKit = new SessionKit({
                                appName: "demo.app",
                                chains: [ {
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                } ],
                                fetch: mockFetch,
                                walletPlugins: [ makeWallet() ]
                            });
                            const session = yield sessionKit.login({
                                transactPlugins: [ new MockTransactPlugin ]
                            });
                            chai.assert.instanceOf(session, Session);
                            chai.assert.lengthOf(session.transactPlugins, 1);
                            chai.assert.instanceOf(session.transactPlugins[0], MockTransactPlugin);
                        }));
                    }));
                }));
            }));
        }));
        test("getters", (function() {
            chai.assert.equal(session.account, PermissionLevel.from(mockSessionOptions$1.permissionLevel).actor);
            chai.assert.equal(session.permission, PermissionLevel.from(mockSessionOptions$1.permissionLevel).permission);
        }));
    }));
    const client = makeClient();
    const wallet = makeWallet();
    const mockSessionOptions = {
        broadcast: false,
        chain: ChainDefinition.from({
            id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
            url: "https://jungle4.greymass.com"
        }),
        fetch: mockFetch,
        permissionLevel: PermissionLevel.from(mockPermissionLevel),
        walletPlugin: wallet
    };
    function mockData() {
        return __awaiter(this, void 0, void 0, (function*() {
            const info = yield client.v1.chain.get_info();
            const action = yield makeMockAction();
            const actions = yield makeMockActions();
            const transaction = yield makeMockTransaction(info);
            const session = new Session(mockSessionOptions);
            return {
                action: action,
                actions: actions,
                info: info,
                session: session,
                transaction: transaction
            };
        }));
    }
    function assetValidTransactResponse(result) {
        chai.assert.instanceOf(result.chain, ChainDefinition);
        chai.assert.instanceOf(result.request, SigningRequest);
        chai.assert.instanceOf(result.resolved, ResolvedSigningRequest);
        chai.assert.instanceOf(result.signatures, Array);
        chai.assert.instanceOf(result.signatures[0], Signature);
        chai.assert.instanceOf(result.signer, PermissionLevel);
    }
    suite("transact", (function() {
        suite("args", (function() {
            suite("action", (function() {
                test("typed", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {action: action, session: session} = yield mockData();
                        const result = yield session.transact({
                            action: action
                        });
                        assetValidTransactResponse(result);
                    }));
                }));
                test("untyped", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {action: action, session: session} = yield mockData();
                        const result = yield session.transact({
                            action: Serializer.objectify(action)
                        });
                        assetValidTransactResponse(result);
                    }));
                }));
            }));
            suite("actions", (function() {
                test("typed", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {actions: actions, session: session} = yield mockData();
                        const result = yield session.transact({
                            actions: actions
                        });
                        assetValidTransactResponse(result);
                    }));
                }));
                test("untyped", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {actions: actions, session: session} = yield mockData();
                        const result = yield session.transact({
                            actions: Serializer.objectify(actions)
                        });
                        assetValidTransactResponse(result);
                    }));
                }));
            }));
            suite("transaction", (function() {
                test("typed", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {session: session, transaction: transaction} = yield mockData();
                        const result = yield session.transact({
                            transaction: transaction
                        });
                        assetValidTransactResponse(result);
                    }));
                }));
                test("untyped", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {session: session, transaction: transaction} = yield mockData();
                        const result = yield session.transact({
                            transaction: Serializer.objectify(transaction)
                        });
                        assetValidTransactResponse(result);
                    }));
                }));
                test("as typed param", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {session: session, transaction: transaction} = yield mockData();
                        const result = yield session.transact(transaction);
                        assetValidTransactResponse(result);
                    }));
                }));
                test("retain headers", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {session: session, transaction: transaction} = yield mockData();
                        const result = yield session.transact(transaction);
                        assetValidTransactResponse(result);
                        if (result.transaction) {
                            chai.assert.equal(transaction.delay_sec, result.transaction.delay_sec);
                            chai.assert.equal(transaction.expiration, result.transaction.expiration);
                            chai.assert.equal(transaction.ref_block_num, result.transaction.ref_block_num);
                            chai.assert.equal(transaction.ref_block_prefix, result.transaction.ref_block_prefix);
                            chai.assert.equal(transaction.max_net_usage_words, result.transaction.max_net_usage_words);
                            chai.assert.equal(transaction.max_cpu_usage_ms, result.transaction.max_cpu_usage_ms);
                        } else {
                            chai.assert.fail("Transaction was not returned in result.");
                        }
                    }));
                }));
                test("as untyped param", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {session: session, transaction: transaction} = yield mockData();
                        const result = yield session.transact(Serializer.objectify(transaction));
                        assetValidTransactResponse(result);
                    }));
                }));
            }));
            suite("signing request", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    test("string", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {session: session} = yield mockData();
                            const result = yield session.transact({
                                request: "esr:gmNgZGBY1mTC_MoglIGBIVzX5uxZRqAQGDBBaSOYQMPGiXGxar2ntKB8Flf_YBAt6BocpBCQWJmTn5hSrOAWEq7IzMAAAA"
                            });
                            assetValidTransactResponse(result);
                        }));
                    }));
                    test("object", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {session: session} = yield mockData();
                            const result = yield session.transact({
                                request: SigningRequest.from("esr:gmNgZGBY1mTC_MoglIGBIVzX5uxZRqAQGDBBaSOYQMPGiXGxar2ntKB8Flf_YBAt6BocpBCQWJmTn5hSrOAWEq7IzMAAAA", {
                                    zlib: pako
                                })
                            });
                            assetValidTransactResponse(result);
                        }));
                    }));
                }));
            }));
            suite("invalid", (function() {
                test("no abi for contract", (function() {
                    return __awaiter(this, void 0, void 0, (function*() {
                        const {action: action, session: session} = yield mockData();
                        const data = Serializer.objectify(action);
                        data.account = "";
                        session.transact({
                            action: data
                        }).catch((error => {
                            chai.assert.equal(error.message, "No data for /v1/chain/get_abi");
                        }));
                    }));
                }));
            }));
        }));
        suite("options", (function() {
            return __awaiter(this, void 0, void 0, (function*() {
                suite("allowModify", (function() {
                    test("default: true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                allowModify: true,
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                allowModify: true,
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("false", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                allowModify: false,
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 1);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                }));
                suite("broadcast", (function() {
                    test("default: true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action} = yield mockData();
                            const session = new Session({
                                chain: ChainDefinition.from({
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                }),
                                fetch: mockFetch,
                                permissionLevel: PermissionLevel.from(mockPermissionLevel),
                                walletPlugin: wallet
                            });
                            const result = yield session.transact({
                                action: action
                            });
                            chai.assert.isDefined(result.response);
                            assetValidTransactResponse(result);
                        }));
                    }));
                    test("true", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                broadcast: true
                            });
                            chai.assert.isDefined(result.response);
                            assetValidTransactResponse(result);
                        }));
                    }));
                    test("false", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                broadcast: false
                            });
                            chai.assert.isUndefined(result.response);
                            assetValidTransactResponse(result);
                        }));
                    }));
                }));
                suite("transactPlugins", (function() {
                    test("inherit", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action} = yield mockData();
                            const session = new Session(Object.assign(Object.assign({}, mockSessionOptions), {
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            }));
                            const result = yield session.transact({
                                action: action
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("override (class)", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("override (function)", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const debugHook = (request, context) => __awaiter(this, void 0, void 0, (function*() {
                                if (context.transactPluginsOptions.logging) {
                                    console.log(Serializer.objectify(request.getRawTransaction()));
                                }
                                return {
                                    request: request,
                                    signatures: []
                                };
                            }));
                            const debugPlugin = {
                                register(context) {
                                    context.addHook(TransactHookTypes.beforeSign, debugHook);
                                    context.addHook(TransactHookTypes.afterSign, debugHook);
                                    context.addHook(TransactHookTypes.beforeBroadcast, debugHook);
                                    context.addHook(TransactHookTypes.afterBroadcast, debugHook);
                                }
                            };
                            const result = yield session.transact({
                                action: action
                            }, {
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1, debugPlugin ],
                                transactPluginsOptions: {
                                    logging: false
                                }
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 2);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("triggers", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action, session: session} = yield mockData();
                            const result = yield session.transact({
                                action: action
                            }, {
                                transactPlugins: [ new MockTransactPlugin ]
                            });
                            assetValidTransactResponse(result);
                        }));
                    }));
                }));
                suite("transactPluginsOptions", (function() {
                    test("transact", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action} = yield mockData();
                            const session = new Session(Object.assign(Object.assign({}, mockSessionOptions), {
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            }));
                            const result = yield session.transact({
                                action: action
                            }, {
                                transactPluginsOptions: {
                                    disableExamplePlugin: true
                                }
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 1);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("session constructor", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action} = yield mockData();
                            const session = new Session(Object.assign(Object.assign({}, mockSessionOptions), {
                                transactPluginsOptions: {
                                    disableExamplePlugin: true
                                },
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ]
                            }));
                            const result = yield session.transact({
                                action: action
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 1);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("kit constructor", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action} = yield mockData();
                            const sessionKit = new SessionKit({
                                appName: "demo.app",
                                chains: [ {
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                } ],
                                fetch: mockFetch,
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ],
                                transactPluginsOptions: {
                                    disableExamplePlugin: true
                                },
                                walletPlugins: [ makeWallet() ]
                            });
                            const session = yield sessionKit.login();
                            const result = yield session.transact({
                                action: action
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 1);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                    test("login", (function() {
                        return __awaiter(this, void 0, void 0, (function*() {
                            const {action: action} = yield mockData();
                            const sessionKit = new SessionKit({
                                appName: "demo.app",
                                chains: [ {
                                    id: "73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d",
                                    url: "https://jungle4.greymass.com"
                                } ],
                                fetch: mockFetch,
                                transactPlugins: [ new MockTransactResourceProviderPlugin$1 ],
                                walletPlugins: [ makeWallet() ]
                            });
                            const session = yield sessionKit.login({
                                transactPluginsOptions: {
                                    disableExamplePlugin: true
                                }
                            });
                            const result = yield session.transact({
                                action: action
                            });
                            assetValidTransactResponse(result);
                            if (result && result.transaction && result.transaction.actions) {
                                chai.assert.lengthOf(result.transaction.actions, 1);
                            } else {
                                chai.assert.fail("Transaction with actions was not returned in result.");
                            }
                        }));
                    }));
                }));
            }));
        }));
        suite("response", (function() {
            test("type check", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const {session: session, transaction: transaction} = yield mockData();
                    const result = yield session.transact(transaction, {
                        broadcast: false
                    });
                    assetValidTransactResponse(result);
                }));
            }));
            test("decoded transaction", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const {session: session} = yield mockData();
                    const result = yield session.transact({
                        request: SigningRequest.from("esr:gmNgZGBY1mTC_MoglIGBIVzX5uxZRqAQGDBBaSOYQMPGiXGxar2ntKB8Flf_YBAt6BocpBCQWJmTn5hSrOAWEq7IzMAAAA", {
                            zlib: pako
                        })
                    });
                    chai.assert.exists(result.transaction);
                    if (result.transaction) {
                        chai.assert.equal(result.transaction.actions[0].authorization[0].actor, PermissionLevel.from(mockSessionOptions.permissionLevel).actor);
                        chai.assert.equal(result.transaction.actions[0].authorization[0].permission, PermissionLevel.from(mockSessionOptions.permissionLevel).permission);
                        chai.assert.equal(result.transaction.actions[0].data.from, PermissionLevel.from(mockSessionOptions.permissionLevel).actor);
                    } else {
                        chai.assert.fail("Decoded transaction was not returned in result.");
                    }
                }));
            }));
            test("resolved request", (function() {
                return __awaiter(this, void 0, void 0, (function*() {
                    const {session: session} = yield mockData();
                    const result = yield session.transact({
                        request: SigningRequest.from("esr:gmNgZGBY1mTC_MoglIGBIVzX5uxZRqAQGDBBaSOYQMPGiXGxar2ntKB8Flf_YBAt6BocpBCQWJmTn5hSrOAWEq7IzMAAAA", {
                            zlib: pako
                        })
                    });
                    chai.assert.exists(result.resolved);
                    const {resolved: resolved} = result;
                    chai.assert.equal(resolved === null || resolved === void 0 ? void 0 : resolved.transaction.actions[0].authorization[0].actor, PermissionLevel.from(mockSessionOptions.permissionLevel).actor);
                    chai.assert.equal(resolved === null || resolved === void 0 ? void 0 : resolved.transaction.actions[0].authorization[0].permission, PermissionLevel.from(mockSessionOptions.permissionLevel).permission);
                }));
            }));
            test("valid signatures", (function() {
                var _a;
                return __awaiter(this, void 0, void 0, (function*() {
                    const {action: action, session: session} = yield mockData();
                    const result = yield session.transact({
                        action: action
                    });
                    const transaction = (_a = result.resolved) === null || _a === void 0 ? void 0 : _a.transaction;
                    if (transaction) {
                        const digest = transaction.signingDigest(mockSessionOptions.chain.id);
                        const [signature] = result.signatures;
                        const publicKey = signature.recoverDigest(digest);
                        chai.assert.isTrue(publicKey.equals(wallet.privateKey.toPublic()));
                    } else {
                        chai.assert.fail("Transaction was not resolved from request.");
                    }
                }));
            }));
        }));
    }));
})(require$0$1, require$1$1, require$2, require$4, require$5, path, undefined, fs, chai);
</script>
    <script class="mocha-exec">
      mocha.run();
    </script>
  </body>
</html>
